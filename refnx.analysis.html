<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>refnx.analysis package &mdash; refnx 0.0.5.dev0+ad01c85 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.5.dev0+ad01c85',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="refnx 0.0.5.dev0+ad01c85 documentation" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="refnx-analysis-package">
<h1>refnx.analysis package<a class="headerlink" href="#refnx-analysis-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-refnx.analysis.curvefitter">
<span id="refnx-analysis-curvefitter-module"></span><h2>refnx.analysis.curvefitter module<a class="headerlink" href="#module-refnx.analysis.curvefitter" title="Permalink to this headline">¶</a></h2>
<p>Created on Sun Dec 21 15:37:29 2014</p>
<p>&#64;author: Andrew Nelson</p>
<dl class="class">
<dt id="refnx.analysis.curvefitter.CurveFitter">
<em class="property">class </em><code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">CurveFitter</code><span class="sig-paren">(</span><em>fitfunc</em>, <em>data</em>, <em>params</em>, <em>mask=None</em>, <em>fcn_args=()</em>, <em>fcn_kws=None</em>, <em>kws=None</em>, <em>callback=None</em>, <em>costfun=None</em>, <em>lnpost=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">lmfit.minimizer.Minimizer</span></code></p>
<blockquote>
<div>A curvefitting class that extends <a class="reference external" href="http://lmfit.github.io/lmfit-py/fitting.html#Minimizer.Minimizer" title="(in lmfit v)"><code class="docutils literal"><span class="pre">Minimizer.Minimizer</span></code></a></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fitfunc</strong> : callable</p>
<blockquote>
<div><p>Function calculating the generative model for the fit.  Should have
the signature: <code class="docutils literal"><span class="pre">fitfunc(x,</span> <span class="pre">params,</span> <span class="pre">*fcn_args,</span> <span class="pre">**fcn_kws)</span></code>. You
can also supply a <a class="reference internal" href="#refnx.analysis.curvefitter.FitFunction" title="refnx.analysis.curvefitter.FitFunction"><code class="xref py py-class docutils literal"><span class="pre">FitFunction</span></code></a> instance.</p>
</div></blockquote>
<p><strong>data</strong> : sequence, <a class="reference internal" href="refnx.dataset.html#refnx.dataset.Data1D" title="refnx.dataset.Data1D"><code class="xref py py-class docutils literal"><span class="pre">refnx.dataset.Data1D</span></code></a> instance, str or file-like object</p>
<blockquote>
<div><p>A sequence containing the data to be analysed.
If <cite>data</cite> is a sequence then:</p>
<blockquote>
<div><ul>
<li><p class="first">data[0] - the independent variable (x-data)</p>
</li>
<li><p class="first">data[1] - the dependent (observed) variable (y-data)</p>
</li>
<li><dl class="first docutils">
<dt>data[2] - measured uncertainty in the dependent variable,</dt>
<dd><p class="first last">expressed as a standard deviation.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Only data[0] and data[1] are required, data[2] is optional. If data[2]
is not specified then the measured uncertainty is set to unity.</p>
<p><cite>data</cite> can also be a <a class="reference internal" href="refnx.dataset.html#refnx.dataset.Data1D" title="refnx.dataset.Data1D"><code class="xref py py-class docutils literal"><span class="pre">refnx.dataset.Data1D</span></code></a> instance containing the data.
If <cite>data</cite> is a string, or file-like object then the string or file-like
object refers to a file containing the data. The data will be loaded
through the <a class="reference internal" href="refnx.dataset.html#refnx.dataset.Data1D" title="refnx.dataset.Data1D"><code class="xref py py-class docutils literal"><span class="pre">refnx.dataset.Data1D</span></code></a> constructor.</p>
</div></blockquote>
<p><strong>params</strong> : <a class="reference external" href="http://lmfit.github.io/lmfit-py/parameters.html#lmfit.parameter.Parameters" title="(in lmfit v)"><code class="xref py py-class docutils literal"><span class="pre">lmfit.parameter.Parameters</span></code></a> instance</p>
<blockquote>
<div><p>Specifies the parameter set for the fit</p>
</div></blockquote>
<p><strong>mask</strong> : np.ndarray, optional</p>
<blockquote>
<div><p>A boolean array with the same shape as <cite>y</cite>.  If <cite>mask is True</cite>
then that point is excluded from the residuals calculation.</p>
</div></blockquote>
<p><strong>fcn_args</strong> : tuple, optional</p>
<blockquote>
<div><p>Extra parameters required to fully specify fitfunc.</p>
</div></blockquote>
<p><strong>fcn_kws</strong> : dict, optional</p>
<blockquote>
<div><p>Extra keyword parameters needed to fully specify fitfunc.</p>
</div></blockquote>
<p><strong>kws</strong> : dict, optional</p>
<blockquote>
<div><p>Keywords passed to the minimizer.</p>
</div></blockquote>
<p><strong>callback</strong> : callable, optional</p>
<blockquote>
<div><p>A function called at each minimization step. Has the signature:
<code class="docutils literal"><span class="pre">callback(params,</span> <span class="pre">iter,</span> <span class="pre">resid,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></p>
</div></blockquote>
<p><strong>costfun</strong> : callable, optional</p>
<blockquote>
<div><p>specifies your own cost function to minimize. Has the signature:
<code class="docutils literal"><span class="pre">costfun(pars,</span> <span class="pre">generative,</span> <span class="pre">y,</span> <span class="pre">e,</span> <span class="pre">*fcn_args,</span> <span class="pre">**fcn_kws)</span></code> where <cite>pars</cite>
is a <cite>lmfit.Parameters</cite> instance, <cite>generative</cite> is an array returned by
<cite>fitfunc</cite>, and <cite>y</cite> and <cite>e</cite> correspond to the <cite>data[1]</cite> and
<cite>data[2]</cite> arrays. <cite>costfun</cite> should return a single value. See Notes for
further details.</p>
</div></blockquote>
<p><strong>lnpost</strong> : callable, optional</p>
<blockquote class="last">
<div><p>specifies your own log-posterior probablility function. This is only
relevant applies to the <cite>emcee</cite> method. Has the signature:
<code class="docutils literal"><span class="pre">lnpost(pars,</span> <span class="pre">generative,</span> <span class="pre">y,</span> <span class="pre">e,</span> <span class="pre">*fcn_args,</span> <span class="pre">**fcn_kws)</span></code> where <cite>pars</cite>
is a <cite>lmfit.Parameters</cite> instance, <cite>generative</cite> is an array returned by
<cite>fitfunc</cite>, and <cite>y</cite> and <cite>e</cite> correspond to the <cite>data[1]</cite> and
<cite>data[2]</cite> arrays. <cite>lnpost</cite> should return a single float value. See
<a class="reference internal" href="#refnx.analysis.curvefitter.CurveFitter.emcee" title="refnx.analysis.curvefitter.CurveFitter.emcee"><code class="xref py py-meth docutils literal"><span class="pre">CurveFitter.emcee</span></code></a> for further details.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The default cost function for CurveFitter is:</p>
<div class="math">
\[\chi^2=\sum \left(\frac{\mathrm{data[1]} - \mathrm{fitfunc}}{\mathrm{data[2]}}\right)^2\]</div>
<p>This user defined cost function can be used to specify other cost
functions for <cite>differential_evolution</cite>, <cite>leastsq</cite>, <cite>least_squares</cite>.</p>
<dl class="attribute">
<dt id="refnx.analysis.curvefitter.CurveFitter.data">
<code class="descname">data</code><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The unmasked data, and the mask</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>(x, y, e, mask)</strong> : data tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.curvefitter.CurveFitter.emcee">
<code class="descname">emcee</code><span class="sig-paren">(</span><em>params=None</em>, <em>steps=1000</em>, <em>nwalkers=100</em>, <em>burn=0</em>, <em>thin=1</em>, <em>ntemps=1</em>, <em>pos=None</em>, <em>reuse_sampler=False</em>, <em>workers=1</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.emcee"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter.emcee" title="Permalink to this definition">¶</a></dt>
<dd><p>Bayesian sampling of the posterior distribution for the parameters
using the <cite>emcee</cite> Markov Chain Monte Carlo package. By default the
method assumes that the prior is Uniform. To implement non-uniform
priors use the <cite>lnpost</cite> kwd when constructing the CurveFitter. You
need to have <cite>emcee</cite> installed to use this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters, optional</p>
<blockquote>
<div><p>Parameters to use as starting point. If this is not specified
then the Parameters used to initialise the CurveFitter object are
used.</p>
</div></blockquote>
<p><strong>steps</strong> : int, optional</p>
<blockquote>
<div><p>How many samples you would like to draw from the posterior
distribution for each of the walkers?</p>
</div></blockquote>
<p><strong>nwalkers</strong> : int, optional</p>
<blockquote>
<div><p>Should be set so <span class="math">\(nwalkers &gt;&gt; nvarys\)</span>, where <cite>nvarys</cite> are
the number of parameters being varied during the fit.
&#8220;Walkers are the members of the ensemble. They are almost like
separate Metropolis-Hastings chains but, of course, the proposal
distribution for a given walker depends on the positions of all
the other walkers in the ensemble.&#8221; - from the <cite>emcee</cite> webpage.</p>
</div></blockquote>
<p><strong>burn</strong> : int, optional</p>
<blockquote>
<div><p>Discard this many samples from the start of the sampling regime.</p>
</div></blockquote>
<p><strong>thin</strong> : int, optional</p>
<blockquote>
<div><p>Only accept 1 in every <cite>thin</cite> samples.</p>
</div></blockquote>
<p><strong>ntemps</strong> : int, optional</p>
<blockquote>
<div><p>If <cite>ntemps &gt; 1</cite> perform a Parallel Tempering.</p>
</div></blockquote>
<p><strong>pos</strong> : np.ndarray, optional</p>
<blockquote>
<div><p>Specify the initial positions for the sampler.  If <cite>ntemps == 1</cite>
then <cite>pos.shape</cite> should be <cite>(nwalkers, nvarys)</cite>. Otherwise,
<cite>(ntemps, nwalkers, nvarys)</cite>. You can also initialise using a
previous chain that had the same <cite>ntemps</cite>, <cite>nwalkers</cite> and
<cite>nvarys</cite>. Note that <cite>nvarys</cite> may be one larger than you expect it
to be if your <cite>userfcn</cite> returns an array and <cite>is_weighted is
False</cite>.</p>
</div></blockquote>
<p><strong>reuse_sampler</strong> : bool, optional</p>
<blockquote>
<div><p>If you have already run <cite>emcee</cite> on a given <cite>Minimizer</cite> object then
it possesses an internal <code class="docutils literal"><span class="pre">sampler</span></code> attribute. You can continue to
draw from the same sampler (retaining the chain history) if you set
this option to <cite>True</cite>. Otherwise a new sampler is created. The
<cite>nwalkers</cite>, <cite>ntemps</cite>, <cite>pos</cite>, and <cite>params</cite> keywords are ignored with
this option.
<strong>Important</strong>: the Parameters used to create the sampler must not
change in-between calls to <cite>emcee</cite>. Alteration of Parameters
would include changed <code class="docutils literal"><span class="pre">min</span></code>, <code class="docutils literal"><span class="pre">max</span></code>, <code class="docutils literal"><span class="pre">vary</span></code> and <code class="docutils literal"><span class="pre">expr</span></code>
attributes. This may happen, for example, if you use an altered
Parameters object and call the <cite>minimize</cite> method in-between calls
to <cite>emcee</cite>.</p>
</div></blockquote>
<p><strong>workers</strong> : Pool-like or int, optional</p>
<blockquote>
<div><p>For parallelization of sampling.  It can be any Pool-like object
with a map method that follows the same calling sequence as the
built-in <cite>map</cite> function. If int is given as the argument, then a
multiprocessing-based pool is spawned internally with the
corresponding number of parallel processes. &#8216;mpi4py&#8217;-based
parallelization and &#8216;joblib&#8217;-based parallelization pools can also
be used here. <strong>Note</strong>: because of multiprocessing overhead it may
only be worth parallelising if the objective function is expensive
to calculate, or if there are a large number of objective
evaluations per step (<cite>ntemps * nwalkers * nvarys</cite>).</p>
</div></blockquote>
<p><strong>seed</strong> : int or <cite>np.random.RandomState</cite>, optional</p>
<blockquote>
<div><p>If <cite>seed</cite> is an int, a new <cite>np.random.RandomState</cite> instance is used,
seeded with <cite>seed</cite>.
If <cite>seed</cite> is already a <cite>np.random.RandomState</cite> instance, then that
<cite>np.random.RandomState</cite> instance is used.
Specify <cite>seed</cite> for repeatable minimizations.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">result: MinimizerResult</p>
<blockquote class="last">
<div><p>MinimizerResult object containing updated params, statistics,
etc. The <cite>MinimizerResult</cite> also contains the <code class="docutils literal"><span class="pre">chain</span></code>,
<code class="docutils literal"><span class="pre">flatchain</span></code> and <code class="docutils literal"><span class="pre">lnprob</span></code> attributes. The <code class="docutils literal"><span class="pre">chain</span></code>
and <code class="docutils literal"><span class="pre">flatchain</span></code> attributes contain the samples and have the shape
<cite>(nwalkers, (steps - burn) // thin, nvarys)</cite> or
<cite>(ntemps, nwalkers, (steps - burn) // thin, nvarys)</cite>,
depending on whether Parallel tempering was used or not.
<cite>nvarys</cite> is the number of parameters that are allowed to vary.
The <code class="docutils literal"><span class="pre">flatchain</span></code> attribute is a <cite>pandas.DataFrame</cite> of the
flattened chain, <cite>chain.reshape(-1, nvarys)</cite>. To access flattened
chain values for a particular parameter use
<cite>result.flatchain[parname]</cite>. The <code class="docutils literal"><span class="pre">lnprob</span></code> attribute contains the
log probability for each sample in <code class="docutils literal"><span class="pre">chain</span></code>. The sample with the
highest probability corresponds to the maximum likelihood estimate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method samples the posterior distribution of the parameters using
Markov Chain Monte Carlo.  To do so it needs to calculate the
log-posterior probability of the model parameters, <cite>F</cite>, given the data,
<cite>D</cite>, <span class="math">\(\ln p(F_{true} | D)\)</span>. This &#8216;posterior probability&#8217; is
calculated as:</p>
<div class="math">
\[\ln p(F_{true} | D) \propto \ln p(D | F_{true}) + \ln p(F_{true})\]</div>
<p>where <span class="math">\(\ln p(D | F_{true})\)</span> is the &#8216;log-likelihood&#8217; and
<span class="math">\(\ln p(F_{true})\)</span> is the &#8216;log-prior&#8217;. The default log-prior
encodes prior information already known about the model. This method
assumes that the log-prior probability is <cite>-np.inf</cite> (impossible) if the
one of the parameters is outside its limits. The log-prior probability
term is zero if all the parameters are inside their bounds (known as a
uniform prior). The default log-likelihood function is given by <a class="reference internal" href="#r1" id="id1">[R1]</a>:</p>
<div class="math">
\[\ln p(D|F_{true}) = -\frac{1}{2}\sum_n \left[\frac{\left(g_n(F_{true}) - D_n \right)^2}{s_n^2}+\ln (2\pi s_n^2)\right]\]</div>
<p>The first summand in the square brackets represents the residual for a
given datapoint (<span class="math">\(g\)</span> being the generative model) . This term
represents <span class="math">\(\chi^2\)</span> when summed over all datapoints.</p>
<p>It is also possible to calculate your own log-posterior probability, by
constructing the CurveFitter object with a <cite>lnpost</cite> function. This
will allow you to use non-uniform priors, etc. The <cite>lnpost</cite> function
has the signature:
<code class="docutils literal"><span class="pre">lnpost(pars,</span> <span class="pre">generative,</span> <span class="pre">y,</span> <span class="pre">e,</span> <span class="pre">*fcn_args,</span> <span class="pre">**fcn_kws)</span></code>. You should
return a single float from this <cite>lnpost</cite> function</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> <a class="reference external" href="http://dan.iel.fm/emcee/current/user/line/">http://dan.iel.fm/emcee/current/user/line/</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.curvefitter.CurveFitter.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>method='leastsq'</em>, <em>params=None</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : str, optional</p>
<blockquote>
<div><p>Name of the fitting method to use.
One of:</p>
<ul class="simple">
<li>&#8216;leastsq&#8217;                -    Levenberg-Marquardt (default)</li>
<li>&#8216;nelder&#8217;                 -    Nelder-Mead</li>
<li>&#8216;lbfgsb&#8217;                 -    L-BFGS-B</li>
<li>&#8216;powell&#8217;                 -    Powell</li>
<li>&#8216;cg&#8217;                     -    Conjugate-Gradient</li>
<li>&#8216;newton&#8217;                 -    Newton-CG</li>
<li>&#8216;cobyla&#8217;                 -    Cobyla</li>
<li>&#8216;tnc&#8217;                    -    Truncate Newton</li>
<li>&#8216;trust-ncg&#8217;              -    Trust Newton-CGn</li>
<li>&#8216;dogleg&#8217;                 -    Dogleg</li>
<li>&#8216;slsqp&#8217;                  -    Sequential Linear Squares Programming</li>
<li>&#8216;differential_evolution&#8217; -    differential evolution</li>
</ul>
</div></blockquote>
<p><strong>params</strong> : Parameters, optional</p>
<blockquote>
<div><p>parameters to use as starting values</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : lmfit.MinimizerResult</p>
<blockquote class="last">
<div><p>Result object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="refnx.analysis.curvefitter.CurveFitter.is_weighted">
<code class="descname">is_weighted</code><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter.is_weighted" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the truth that the fit is weighted by measurement uncertainties</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.curvefitter.CurveFitter.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the model. This is a convenience method. Over-riding it will
not change a fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters instance</p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>model</strong> : array_like</p>
<blockquote class="last">
<div><p>The model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.curvefitter.CurveFitter.residuals">
<code class="descname">residuals</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.residuals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the difference between the data and the model. Also known as
the objective function. This is a convenience method. Over-riding it
will not change a fit.</p>
<p><span class="math">\(residuals = (fitfunc - y) / edata\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters instance</p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>residuals</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The difference between the data and the model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.curvefitter.FitFunction">
<em class="property">class </em><code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">FitFunction</code><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.FitFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/3/library/functions.html#object" title="(in Python v3.5)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>An abstract FitFunction class.</p>
<dl class="method">
<dt id="refnx.analysis.curvefitter.FitFunction.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>x</em>, <em>params</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.FitFunction.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the predictive model for the fit.
Override this method in your own fitfunction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like</p>
<blockquote>
<div><p>The independent variable for the fit</p>
</div></blockquote>
<p><strong>params</strong> : lmfit.Parameters</p>
<blockquote>
<div><p>The model parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>predictive</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The predictive model for the fitfunction.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p><cite>args</cite> and <cite>kws</cite> can be used to fully specify the fit function.
Normally you would supply these via when the <strong>FitFunction</strong> object is
constructed.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="refnx.analysis.curvefitter.FitFunction.parameter_names">
<em class="property">static </em><code class="descname">parameter_names</code><span class="sig-paren">(</span><em>nparams=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction.parameter_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.FitFunction.parameter_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a set of names for constructing an <a class="reference external" href="http://lmfit.github.io/lmfit-py/parameters.html#lmfit.parameter.Parameters" title="(in lmfit v)"><code class="xref py py-class docutils literal"><span class="pre">lmfit.parameter.Parameters</span></code></a> instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nparams: int, optional</strong></p>
<blockquote>
<div><p>&gt;= 0 - provide a set of names with length <cite>nparams</cite></p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>&#8212;&#8212;-</strong></p>
<p><strong>names: list</strong></p>
<blockquote class="last">
<div><p>names for the lmfit.Parameters instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.curvefitter.GlobalFitter">
<em class="property">class </em><code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">GlobalFitter</code><span class="sig-paren">(</span><em>fitters</em>, <em>constraints=()</em>, <em>kws=None</em>, <em>callback=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.GlobalFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#refnx.analysis.curvefitter.CurveFitter" title="refnx.analysis.curvefitter.CurveFitter"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.curvefitter.CurveFitter</span></code></a></p>
<p>Simultaneous curvefitting of multiple datasets</p>
<dl class="docutils">
<dt>fitters</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">sequence of <a class="reference internal" href="#refnx.analysis.curvefitter.CurveFitter" title="refnx.analysis.curvefitter.CurveFitter"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.curvefitter.CurveFitter</span></code></a> instances</span><dd>Contains all the fitters and fitfunctions for the global fit.</dd>
<dt>constraints</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str sequence, optional</span><dd>Of the type &#8216;dN:param_name = constraint&#8217;. Sets a constraint
expression for the parameter <cite>param_name</cite> in dataset N. The
constraint &#8216;d2:scale = 2 * d0:back&#8217; constrains the <cite>scale</cite>
parameter in dataset 2 to be twice the <cite>back</cite> parameter in
dataset 0.
<strong>Important</strong> For a parameter (<cite>d2:scale</cite> in this example) to be
constrained by this mechanism it must not have any pre-existing
constraints within its individual fitter. If there are pre-existing
constraints then those are honoured, and constraints specified here are
ignored.</dd>
<dt>kws</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span><dd>Extra minimization keywords to be passed to the minimizer of choice.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span><dd>Function called at each step of the minimization. Has the signature
<code class="docutils literal"><span class="pre">callback(params,</span> <span class="pre">iter,</span> <span class="pre">resid)</span></code></dd>
</dl>
<dl class="method">
<dt id="refnx.analysis.curvefitter.GlobalFitter.distribute_params">
<code class="descname">distribute_params</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter.distribute_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.GlobalFitter.distribute_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for re-distributing global parameter values
back into each of the original <cite>CurveFitter.params</cite> attributes.</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.curvefitter.GlobalFitter.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.GlobalFitter.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the model. This method is provided for convenience purposes
and is not used during a fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params: lmfit.Parameters</strong></p>
<blockquote>
<div><p>Specifies the entire parameter set, across all the datasets</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>model</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.curvefitter.GlobalFitter.residuals">
<code class="descname">residuals</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter.residuals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.GlobalFitter.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the difference between the data and the model. Also known as
the objective function.  This is a convenience method. Over-riding it
does not change the fitting process.
residuals = (fitfunc - y) / edata</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params: lmfit.Parameters</strong></p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>residuals</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The difference between the data and the model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.bounds">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">bounds</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.clear_bounds">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">clear_bounds</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#clear_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.clear_bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.exprs">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">exprs</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#exprs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.exprs" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and returns
the the constraint expressions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parameters</strong> : lmfit.Parameters</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>exprs</strong> : list of str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.fitfunc">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">fitfunc</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#fitfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.fitfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that can be used to say if something is a fitfunc.</p>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.names">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">names</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.to_parameters">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">to_parameters</code><span class="sig-paren">(</span><em>p0</em>, <em>varies=None</em>, <em>bounds=None</em>, <em>names=None</em>, <em>expr=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#to_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.to_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function to convert sequences into a <a class="reference external" href="http://lmfit.github.io/lmfit-py/parameters.html#lmfit.parameter.Parameters" title="(in lmfit v)"><code class="xref py py-class docutils literal"><span class="pre">lmfit.parameter.Parameters</span></code></a> instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p0</strong> : np.ndarray</p>
<blockquote>
<div><p>numpy array containing parameter values.</p>
</div></blockquote>
<p><strong>varies</strong> : bool sequence, optional</p>
<blockquote>
<div><p>Specifies whether a parameter is being held or varied.</p>
</div></blockquote>
<p><strong>bounds</strong> : sequence, optional</p>
<blockquote>
<div><p>Tuple of (min, max) pairs specifying the lower and upper bounds for
each parameter</p>
</div></blockquote>
<p><strong>name</strong> : str sequence, optional</p>
<blockquote>
<div><p>Name of each parameter</p>
</div></blockquote>
<p><strong>expr</strong> : str sequence, optional</p>
<blockquote>
<div><p>Constraints for each parameter</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>p</strong> : lmfit.Parameters instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.values">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">values</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.values" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and returns
the values</p>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.varys">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">varys</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#varys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.varys" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and finds
out which ones vary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parameters</strong> : lmfit.Parameters</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">varys: bool, sequence</p>
<blockquote class="last">
<div><p>Which parameters are varying</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-refnx.analysis.reflect">
<span id="refnx-analysis-reflect-module"></span><h2>refnx.analysis.reflect module<a class="headerlink" href="#module-refnx.analysis.reflect" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="refnx.analysis.reflect.AnalyticalReflectivityFunction">
<em class="property">class </em><code class="descclassname">refnx.analysis.reflect.</code><code class="descname">AnalyticalReflectivityFunction</code><span class="sig-paren">(</span><em>transform=None</em>, <em>dq=5.0</em>, <em>quad_order=17</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#AnalyticalReflectivityFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.AnalyticalReflectivityFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#refnx.analysis.reflect.ReflectivityFitFunction" title="refnx.analysis.reflect.ReflectivityFitFunction"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.reflect.ReflectivityFitFunction</span></code></a></p>
<p>A class for using analytical profiles in Reflectometry problems
Usage involves inheriting this class and over-riding <code class="docutils literal"><span class="pre">to_slab</span></code> and
<code class="docutils literal"><span class="pre">parameter_names</span></code>.</p>
<dl class="method">
<dt id="refnx.analysis.reflect.AnalyticalReflectivityFunction.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>x</em>, <em>parameters</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#AnalyticalReflectivityFunction.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.AnalyticalReflectivityFunction.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the reflectivity model. You should not need to over-ride
this method.</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.reflect.AnalyticalReflectivityFunction.parameter_names">
<code class="descname">parameter_names</code><span class="sig-paren">(</span><em>nparams=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#AnalyticalReflectivityFunction.parameter_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.AnalyticalReflectivityFunction.parameter_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the names of the parameters for this analytical model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nparams</strong> : int</p>
<blockquote>
<div><p>Number of parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>names</strong> : sequence</p>
<blockquote class="last">
<div><p>List containing the names of each of the parameters in this model</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.reflect.AnalyticalReflectivityFunction.sld_profile">
<code class="descname">sld_profile</code><span class="sig-paren">(</span><em>parameters</em>, <em>z=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#AnalyticalReflectivityFunction.sld_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.AnalyticalReflectivityFunction.sld_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the SLD profile. You should not need to over-ride
this method.</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.reflect.AnalyticalReflectivityFunction.to_slab">
<code class="descname">to_slab</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#AnalyticalReflectivityFunction.to_slab"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.AnalyticalReflectivityFunction.to_slab" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps Parameters from your analytical model to those suitable
for a simple slab reflectivity calculation. See <code class="docutils literal"><span class="pre">reflectivity</span></code> for
the correct output format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters or sequence</p>
<blockquote>
<div><p>Parameters specifying your analytical model</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>slab_params</strong> : lmfit.Parameters or sequence</p>
<blockquote class="last">
<div><p>Parameters usable for simple slab reflectivity calculation. See
<a class="reference internal" href="#refnx.analysis.reflect.reflectivity" title="refnx.analysis.reflect.reflectivity"><code class="xref py py-func docutils literal"><span class="pre">reflectivity</span></code></a> for the correct format for slab_params. Should
have: <cite>len(slab_params) == 4 * slab_params[0] + 8</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction">
<em class="property">class </em><code class="descclassname">refnx.analysis.reflect.</code><code class="descname">ReflectivityFitFunction</code><span class="sig-paren">(</span><em>transform=None</em>, <em>dq=5.0</em>, <em>quad_order=17</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#refnx.analysis.curvefitter.FitFunction" title="refnx.analysis.curvefitter.FitFunction"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.curvefitter.FitFunction</span></code></a></p>
<p>A sub class of <cite>refnx.analysis.curvefitter.FitFunction</cite> suited for
calculation of reflectometry profiles from a simple slab model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>transform</strong> : callable, optional</p>
<blockquote>
<div><p>If specified then this function is used to transform the data
returned by the model method. With the signature:
<code class="docutils literal"><span class="pre">transformed_y_vals</span> <span class="pre">=</span> <span class="pre">transform(x_vals,</span> <span class="pre">y_vals)</span></code>.</p>
</div></blockquote>
<p><strong>dq</strong> : float, optional</p>
<blockquote>
<div><p>Default dq/q resolution (as a percentage).</p>
</div></blockquote>
<p><strong>quad_order</strong> : int or str, optional</p>
<blockquote>
<div><p>The order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For
example 13 points may be fine for a thin layer, but will be
atrocious at describing a multilayer with Bragg peaks.</p>
</div></blockquote>
<p><strong>parallel</strong> : bool, optional</p>
<blockquote class="last">
<div><p>Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction.callback">
<code class="descname">callback</code><span class="sig-paren">(</span><em>parameters</em>, <em>iteration</em>, <em>resid</em>, <em>*fcn_args</em>, <em>**fcn_kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction.callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>x</em>, <em>parameters</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the theoretical model, given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like</p>
<blockquote>
<div><p>Q values to evaluate the reflectivity at</p>
</div></blockquote>
<p><strong>parameters</strong> : lmfit.Parameters instance or sequence</p>
<blockquote>
<div><p>Contains the parameters that are required for reflectivity
calculation. See <code class="docutils literal"><span class="pre">reflectivity</span></code> for the required parameters for
calculation</p>
</div></blockquote>
<p><strong>kwds[&#8216;dqvals&#8217;]</strong> : float or np.ndarray, optional</p>
<blockquote>
<div><p>If dqvals is a float, then a constant dQ/Q resolution smearing is
employed.  For 5% resolution smearing supply 5.
If <cite>dqvals</cite> is the same shape as q, then the array contains the
FWHM of a Gaussian approximated resolution kernel. Point by point
resolution smearing is employed.  Use this option if dQ/Q varies
across your dataset.
If <cite>dqvals.ndim == q.ndim + 2</cite> and
<cite>q.shape == dqvals[..., -3].shape</cite> then an individual resolution
kernel is applied to each measurement point.  This resolution kernel
is a probability distribution function (PDF). <cite>dqvals</cite> will have the
shape (qvals.shape, M, 2).  There are <cite>M</cite> points in the kernel.
<cite>dqvals[..., 0]</cite> holds the q values for the kernel, <cite>dqvals[..., 1]</cite>
gives the corresponding probability.</p>
</div></blockquote>
<p><strong>kwds[&#8216;quad_order&#8217;]</strong> : int, optional</p>
<blockquote>
<div><p>the order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For example,
13 points may be fine for a thin layer, but will be atrocious at
describing a multilayer with bragg peaks.</p>
</div></blockquote>
<p><strong>kwds[&#8216;parallel&#8217;]</strong> : bool, optional</p>
<blockquote>
<div><p>Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>. The
default is <cite>True</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The predictive model, i.e.
<code class="docutils literal"><span class="pre">reflectivity(x,</span> <span class="pre">parameters,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction.parameter_names">
<em class="property">static </em><code class="descname">parameter_names</code><span class="sig-paren">(</span><em>nparams=8</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.parameter_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction.parameter_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter names for a default reflectivity calculation</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction.set_dq">
<code class="descname">set_dq</code><span class="sig-paren">(</span><em>dq</em>, <em>quad_order=17</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.set_dq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction.set_dq" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the resolution information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dq</strong> : None, float or np.ndarray</p>
<blockquote>
<div><p>If <cite>None</cite> then there is no resolution smearing.
If a float, e.g. 5, then dq/q smearing of 5% is applied. If dq==0
then resolution smearing is removed.
If an np.ndarray the same length as y, it contains the FWHM of
the Gaussian approximated resolution kernel.</p>
</div></blockquote>
<p><strong>quad_order</strong> : int or &#8216;ultimate&#8217;</p>
<blockquote class="last">
<div><p>The order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For
example 13 points may be fine for a thin layer, but will be
atrocious at describing a multilayer with Bragg peaks.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction.sld_profile">
<code class="descname">sld_profile</code><span class="sig-paren">(</span><em>parameters</em>, <em>z=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.sld_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction.sld_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the SLD profile corresponding to the model parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parameters</strong> : lmfit.parameters.Parameters instance or sequence</p>
<p><strong>z</strong> : array-like, optional</p>
<blockquote>
<div><p>Interfacial distances to evaluate the SLD profile at.
z = 0 corresponds to the interfaces between the fronting medium
and the first layer</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>(z, rho_z)</strong> : tuple of np.ndarrays</p>
<blockquote class="last">
<div><p>The distance from the top interface and the SLD at that point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.reflect.Transform">
<em class="property">class </em><code class="descclassname">refnx.analysis.reflect.</code><code class="descname">Transform</code><span class="sig-paren">(</span><em>form</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#Transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.Transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/3/library/functions.html#object" title="(in Python v3.5)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Mathematical transforms of numeric data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>form</strong> : None or str</p>
<blockquote class="last">
<div><p>One of:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>&#8216;lin&#8217;</dt>
<dd><p class="first last">No transform is made</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;logY&#8217;</dt>
<dd><p class="first last">log10 transform</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;YX4&#8217;</dt>
<dd><p class="first last">YX**4 transform</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;YX2&#8217;</dt>
<dd><p class="first last">YX**2 transform</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>None</dt>
<dd><p class="first last">No transform is made</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="refnx.analysis.reflect.Transform.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>xdata</em>, <em>ydata</em>, <em>edata=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#Transform.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.Transform.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the data passed in</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xdata</strong> : array-like</p>
<p><strong>ydata</strong> : array-like</p>
<p><strong>edata</strong> : array-like</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>yt, et</strong> : tuple</p>
<blockquote class="last">
<div><p>The transformed data</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.abeles">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">abeles</code><span class="sig-paren">(</span><em>q</em>, <em>layers</em>, <em>scale=1</em>, <em>bkg=0.0</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#abeles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.abeles" title="Permalink to this definition">¶</a></dt>
<dd><p>Abeles matrix formalism for calculating reflectivity from a stratified
medium.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q</strong> : array_like</p>
<blockquote>
<div><p>the q values required for the calculation.
<span class="math">\(Q = \frac{4\pi}{\lambda}\sin(\Omega)\)</span>.
Units = Angstrom**-1</p>
</div></blockquote>
<p><strong>layers</strong> : np.ndarray</p>
<blockquote>
<div><p>coefficients required for the calculation, has shape (2 + N, 4),
where N is the number of layers</p>
<ul class="simple">
<li>layers[0, 1] - SLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[0, 2] - iSLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 0] - thickness of layer N</li>
<li>layers[N, 1] - SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 2] - iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 3] - roughness between layer N-1/N</li>
<li>layers[-1, 1] - SLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 2] - iSLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 3] - roughness between backing and last layer</li>
</ul>
</div></blockquote>
<p><strong>scale</strong> : float</p>
<blockquote>
<div><p>Multiply all reflectivities by this value.</p>
</div></blockquote>
<p><strong>bkg</strong> : float</p>
<blockquote>
<div><p>Linear background to be added to all reflectivities</p>
</div></blockquote>
<p><strong>parallel</strong> : bool</p>
<blockquote>
<div><p>Do you want to calculate in parallel? This option is only applicable if
you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is ignored if using
the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Reflectivity: np.ndarray</p>
<blockquote class="last">
<div><p>Calculated reflectivity values for each q value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.coefs_to_layer">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">coefs_to_layer</code><span class="sig-paren">(</span><em>coefs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#coefs_to_layer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.coefs_to_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts &#8216;coefs&#8217; format array to a &#8216;layer&#8217; format array .
The &#8216;layer&#8217; format is used by <a class="reference internal" href="#refnx.analysis.reflect.abeles" title="refnx.analysis.reflect.abeles"><code class="xref py py-func docutils literal"><span class="pre">abeles</span></code></a>, the &#8216;coefs&#8217; format
is used by <a class="reference internal" href="#refnx.analysis.reflect.reflectivity" title="refnx.analysis.reflect.reflectivity"><code class="xref py py-func docutils literal"><span class="pre">reflectivity</span></code></a>.
The &#8216;layer&#8217; format has N + 2 rows and 4 columns. Each row describes a
separate layer in the model. The 4 columns describe the thickness, SLD,
iSLD and roughness of each layer.
The &#8216;coefs&#8217; format is a vector description of the same information. A
vector form is required for fitting purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>coefs</strong> : np.ndarray</p>
<blockquote>
<div><ul class="simple">
<li>coefs[0] = number of layers, N</li>
<li>coefs[1] = scale factor</li>
<li>coefs[2] = SLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[3] = iSLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[4] = SLD of backing</li>
<li>coefs[5] = iSLD of backing</li>
<li>coefs[6] = background</li>
<li>coefs[7] = roughness between backing and layer N</li>
<li>coefs[4 * (N - 1) + 8] = thickness of layer N in Angstrom (layer 1 is</li>
<li>closest to fronting)</li>
<li>coefs[4 * (N - 1) + 9] = SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>coefs[4 * (N - 1) + 10] = iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>coefs[4 * (N - 1) + 11] = roughness between layer N and N-1.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">layers: np.ndarray</p>
<blockquote class="last">
<div><p>Has shape (2 + N, 4), where N is the number of layers</p>
<ul class="simple">
<li>layers[0, 1] - SLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[0, 2] - iSLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 0] - thickness of layer N</li>
<li>layers[N, 1] - SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 2] - iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 3] - roughness between layer N-1/N</li>
<li>layers[-1, 1] - SLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 2] - iSLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 3] - roughness between backing and last layer</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.gauss_legendre">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">gauss_legendre</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#gauss_legendre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.gauss_legendre" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.is_proper_abeles_input">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">is_proper_abeles_input</code><span class="sig-paren">(</span><em>coefs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#is_proper_abeles_input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.is_proper_abeles_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Test to see if the coefs array is suitable input for the <cite>reflectivity</cite>
function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>coefs</strong> : np.ndarray</p>
<blockquote>
<div><p>Coefficients used for calculating reflectivity, as passed to
<a class="reference internal" href="#refnx.analysis.reflect.reflectivity" title="refnx.analysis.reflect.reflectivity"><code class="xref py py-func docutils literal"><span class="pre">reflectivity</span></code></a></p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>&#8212;&#8212;-</strong></p>
<p><strong>is_proper_abeles_input</strong> : bool</p>
<blockquote class="last">
<div><p>Truth of whether the coeffcients have the right number of parameters
for the number of layers in the model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.layer_to_coefs">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">layer_to_coefs</code><span class="sig-paren">(</span><em>layers</em>, <em>scale=1</em>, <em>bkg=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#layer_to_coefs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.layer_to_coefs" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts &#8216;layer&#8217; format array to a &#8216;coefs&#8217; format array .
The &#8216;layer&#8217; format is used by the <a class="reference internal" href="#refnx.analysis.reflect.abeles" title="refnx.analysis.reflect.abeles"><code class="xref py py-func docutils literal"><span class="pre">abeles</span></code></a> function,
the &#8216;coefs&#8217; format is used by the <a class="reference internal" href="#refnx.analysis.reflect.reflectivity" title="refnx.analysis.reflect.reflectivity"><code class="xref py py-func docutils literal"><span class="pre">reflectivity</span></code></a> function.
The &#8216;layer&#8217; format has N + 2 rows and 4 columns. Each row describes a
separate layer in the model. The 4 columns describe the thickness, SLD,
iSLD and roughness of each layer.
The &#8216;coefs&#8217; format is a vector description of the same information. A
vector form is required for fitting purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>layers</strong> : np.ndarray</p>
<blockquote>
<div><p>Has shape (2 + N, 4), where N is the number of layers.</p>
<ul class="simple">
<li>layers[0, 1] = SLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[0, 2] = iSLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 0] = thickness of layer N</li>
<li>layers[N, 1] = SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 2] = iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 3] = roughness between layer N-1/N</li>
<li>layers[-1, 1] = SLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 2] = iSLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 3] = roughness between backing and last layer</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>coefs</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>Has shape (4 * N + 8, ), where N is the number of layers</p>
<ul class="simple">
<li>coefs[0] = number of layers, N</li>
<li>coefs[1] = scale factor</li>
<li>coefs[2] = SLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[3] = iSLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[4] = SLD of backing</li>
<li>coefs[5] = iSLD of backing</li>
<li>coefs[6] = background</li>
<li>coefs[7] = roughness between backing and layer N</li>
<li>coefs[4 * (N - 1) + 8] = thickness of layer N in Angstrom (layer 1 is
closest to fronting)</li>
<li>coefs[4 * (N - 1) + 9] = SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>coefs[4 * (N - 1) + 10] = iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>coefs[4 * (N - 1) + 11] = roughness between layer N and N-1.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.reflectivity">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">reflectivity</code><span class="sig-paren">(</span><em>q</em>, <em>coefs</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#reflectivity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.reflectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Abeles matrix formalism for calculating reflectivity from a stratified
medium.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q</strong> : np.ndarray</p>
<blockquote>
<div><p>The qvalues required for the calculation. <span class="math">\(Q=\frac{4Pi}{\lambda}\sin(\Omega)\)</span>.
Units = Angstrom**-1</p>
</div></blockquote>
<p><strong>coefs</strong> : np.ndarray</p>
<blockquote>
<div><ul class="simple">
<li>coefs[0] - number of layers, N</li>
<li>coefs[1] - scale factor</li>
<li>coefs[2] - SLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[3] - iSLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[4] - SLD of backing</li>
<li>coefs[5] - iSLD of backing</li>
<li>coefs[6] - background</li>
<li>coefs[7] - roughness between backing and layer N</li>
<li>coefs[4 * (N - 1) + 8] = thickness of layer N in Angstrom (layer 1 is
closest to fronting)</li>
<li>coefs[4 * (N - 1) + 9] - SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>coefs[4 * (N - 1) + 10] - iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>coefs[4 * (N - 1) + 11] - roughness between layer N and N-1.</li>
</ul>
</div></blockquote>
<p><strong>kwds</strong> : dict, optional</p>
<blockquote class="last">
<div><p>The following keys are used:</p>
<dl class="docutils">
<dt>&#8216;dqvals&#8217;: float or np.ndarray, optional</dt>
<dd><p class="first last">If dqvals is a float, then a constant dQ/Q resolution smearing is
employed.  For 5% resolution smearing supply 5.
If <cite>dqvals</cite> is the same shape as q, then the array contains the
FWHM of a Gaussian approximated resolution kernel. Point by point
resolution smearing is employed.  Use this option if dQ/Q varies
across your dataset.
If <cite>dqvals.ndim == q.ndim + 2</cite> and
<cite>q.shape == dqvals[..., -3].shape</cite> then an individual resolution
kernel is applied to each measurement point.  This resolution kernel
is a probability distribution function (PDF). <cite>dqvals</cite> will have the
shape (qvals.shape, M, 2).  There are <cite>M</cite> points in the kernel.
<cite>dqvals[..., 0]</cite> holds the q values for the kernel, <cite>dqvals[..., 1]</cite>
gives the corresponding probability.</p>
</dd>
<dt>&#8216;quad_order&#8217;: int, optional</dt>
<dd><p class="first last">the order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For example,
13 points may be fine for a thin layer, but will be atrocious at
describing a multilayer with bragg peaks.</p>
</dd>
<dt>&#8216;parallel&#8217;: bool, optional</dt>
<dd><p class="first last">Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>. The
default is <cite>True</cite>.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.sld_profile">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">sld_profile</code><span class="sig-paren">(</span><em>z</em>, <em>coefs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#sld_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.sld_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates an SLD profile, as a function of distance through the
interface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z</strong> : float</p>
<blockquote>
<div><p>Interfacial distance (Angstrom) measured from interface between the
fronting medium and the first layer.</p>
</div></blockquote>
<p><strong>coefs</strong> : np.ndarray</p>
<blockquote>
<div><p>The reflectivity model parameters in &#8216;layer&#8217; form. (See
<cite>reflectivity</cite>)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sld</strong> : float</p>
<blockquote class="last">
<div><p>Scattering length density / 1e-6 $AA^-2$</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This can be called in vectorised fashion.</p>
</dd></dl>

</div>
<div class="section" id="module-refnx.analysis">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-refnx.analysis" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="refnx.analysis.AnalyticalReflectivityFunction">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">AnalyticalReflectivityFunction</code><span class="sig-paren">(</span><em>transform=None</em>, <em>dq=5.0</em>, <em>quad_order=17</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#AnalyticalReflectivityFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.AnalyticalReflectivityFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#refnx.analysis.reflect.ReflectivityFitFunction" title="refnx.analysis.reflect.ReflectivityFitFunction"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.reflect.ReflectivityFitFunction</span></code></a></p>
<p>A class for using analytical profiles in Reflectometry problems
Usage involves inheriting this class and over-riding <code class="docutils literal"><span class="pre">to_slab</span></code> and
<code class="docutils literal"><span class="pre">parameter_names</span></code>.</p>
<dl class="method">
<dt id="refnx.analysis.AnalyticalReflectivityFunction.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>x</em>, <em>parameters</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#AnalyticalReflectivityFunction.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.AnalyticalReflectivityFunction.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the reflectivity model. You should not need to over-ride
this method.</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.AnalyticalReflectivityFunction.parameter_names">
<code class="descname">parameter_names</code><span class="sig-paren">(</span><em>nparams=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#AnalyticalReflectivityFunction.parameter_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.AnalyticalReflectivityFunction.parameter_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies the names of the parameters for this analytical model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nparams</strong> : int</p>
<blockquote>
<div><p>Number of parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>names</strong> : sequence</p>
<blockquote class="last">
<div><p>List containing the names of each of the parameters in this model</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.AnalyticalReflectivityFunction.sld_profile">
<code class="descname">sld_profile</code><span class="sig-paren">(</span><em>parameters</em>, <em>z=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#AnalyticalReflectivityFunction.sld_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.AnalyticalReflectivityFunction.sld_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the SLD profile. You should not need to over-ride
this method.</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.AnalyticalReflectivityFunction.to_slab">
<code class="descname">to_slab</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#AnalyticalReflectivityFunction.to_slab"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.AnalyticalReflectivityFunction.to_slab" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps Parameters from your analytical model to those suitable
for a simple slab reflectivity calculation. See <code class="docutils literal"><span class="pre">reflectivity</span></code> for
the correct output format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters or sequence</p>
<blockquote>
<div><p>Parameters specifying your analytical model</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>slab_params</strong> : lmfit.Parameters or sequence</p>
<blockquote class="last">
<div><p>Parameters usable for simple slab reflectivity calculation. See
<a class="reference internal" href="#refnx.analysis.reflectivity" title="refnx.analysis.reflectivity"><code class="xref py py-func docutils literal"><span class="pre">reflectivity</span></code></a> for the correct format for slab_params. Should
have: <cite>len(slab_params) == 4 * slab_params[0] + 8</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.CurveFitter">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">CurveFitter</code><span class="sig-paren">(</span><em>fitfunc</em>, <em>data</em>, <em>params</em>, <em>mask=None</em>, <em>fcn_args=()</em>, <em>fcn_kws=None</em>, <em>kws=None</em>, <em>callback=None</em>, <em>costfun=None</em>, <em>lnpost=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.CurveFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">lmfit.minimizer.Minimizer</span></code></p>
<blockquote>
<div>A curvefitting class that extends <a class="reference external" href="http://lmfit.github.io/lmfit-py/fitting.html#Minimizer.Minimizer" title="(in lmfit v)"><code class="docutils literal"><span class="pre">Minimizer.Minimizer</span></code></a></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fitfunc</strong> : callable</p>
<blockquote>
<div><p>Function calculating the generative model for the fit.  Should have
the signature: <code class="docutils literal"><span class="pre">fitfunc(x,</span> <span class="pre">params,</span> <span class="pre">*fcn_args,</span> <span class="pre">**fcn_kws)</span></code>. You
can also supply a <a class="reference internal" href="#refnx.analysis.FitFunction" title="refnx.analysis.FitFunction"><code class="xref py py-class docutils literal"><span class="pre">FitFunction</span></code></a> instance.</p>
</div></blockquote>
<p><strong>data</strong> : sequence, <a class="reference internal" href="refnx.dataset.html#refnx.dataset.Data1D" title="refnx.dataset.Data1D"><code class="xref py py-class docutils literal"><span class="pre">refnx.dataset.Data1D</span></code></a> instance, str or file-like object</p>
<blockquote>
<div><p>A sequence containing the data to be analysed.
If <cite>data</cite> is a sequence then:</p>
<blockquote>
<div><ul>
<li><p class="first">data[0] - the independent variable (x-data)</p>
</li>
<li><p class="first">data[1] - the dependent (observed) variable (y-data)</p>
</li>
<li><dl class="first docutils">
<dt>data[2] - measured uncertainty in the dependent variable,</dt>
<dd><p class="first last">expressed as a standard deviation.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Only data[0] and data[1] are required, data[2] is optional. If data[2]
is not specified then the measured uncertainty is set to unity.</p>
<p><cite>data</cite> can also be a <a class="reference internal" href="refnx.dataset.html#refnx.dataset.Data1D" title="refnx.dataset.Data1D"><code class="xref py py-class docutils literal"><span class="pre">refnx.dataset.Data1D</span></code></a> instance containing the data.
If <cite>data</cite> is a string, or file-like object then the string or file-like
object refers to a file containing the data. The data will be loaded
through the <a class="reference internal" href="refnx.dataset.html#refnx.dataset.Data1D" title="refnx.dataset.Data1D"><code class="xref py py-class docutils literal"><span class="pre">refnx.dataset.Data1D</span></code></a> constructor.</p>
</div></blockquote>
<p><strong>params</strong> : <a class="reference external" href="http://lmfit.github.io/lmfit-py/parameters.html#lmfit.parameter.Parameters" title="(in lmfit v)"><code class="xref py py-class docutils literal"><span class="pre">lmfit.parameter.Parameters</span></code></a> instance</p>
<blockquote>
<div><p>Specifies the parameter set for the fit</p>
</div></blockquote>
<p><strong>mask</strong> : np.ndarray, optional</p>
<blockquote>
<div><p>A boolean array with the same shape as <cite>y</cite>.  If <cite>mask is True</cite>
then that point is excluded from the residuals calculation.</p>
</div></blockquote>
<p><strong>fcn_args</strong> : tuple, optional</p>
<blockquote>
<div><p>Extra parameters required to fully specify fitfunc.</p>
</div></blockquote>
<p><strong>fcn_kws</strong> : dict, optional</p>
<blockquote>
<div><p>Extra keyword parameters needed to fully specify fitfunc.</p>
</div></blockquote>
<p><strong>kws</strong> : dict, optional</p>
<blockquote>
<div><p>Keywords passed to the minimizer.</p>
</div></blockquote>
<p><strong>callback</strong> : callable, optional</p>
<blockquote>
<div><p>A function called at each minimization step. Has the signature:
<code class="docutils literal"><span class="pre">callback(params,</span> <span class="pre">iter,</span> <span class="pre">resid,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></p>
</div></blockquote>
<p><strong>costfun</strong> : callable, optional</p>
<blockquote>
<div><p>specifies your own cost function to minimize. Has the signature:
<code class="docutils literal"><span class="pre">costfun(pars,</span> <span class="pre">generative,</span> <span class="pre">y,</span> <span class="pre">e,</span> <span class="pre">*fcn_args,</span> <span class="pre">**fcn_kws)</span></code> where <cite>pars</cite>
is a <cite>lmfit.Parameters</cite> instance, <cite>generative</cite> is an array returned by
<cite>fitfunc</cite>, and <cite>y</cite> and <cite>e</cite> correspond to the <cite>data[1]</cite> and
<cite>data[2]</cite> arrays. <cite>costfun</cite> should return a single value. See Notes for
further details.</p>
</div></blockquote>
<p><strong>lnpost</strong> : callable, optional</p>
<blockquote class="last">
<div><p>specifies your own log-posterior probablility function. This is only
relevant applies to the <cite>emcee</cite> method. Has the signature:
<code class="docutils literal"><span class="pre">lnpost(pars,</span> <span class="pre">generative,</span> <span class="pre">y,</span> <span class="pre">e,</span> <span class="pre">*fcn_args,</span> <span class="pre">**fcn_kws)</span></code> where <cite>pars</cite>
is a <cite>lmfit.Parameters</cite> instance, <cite>generative</cite> is an array returned by
<cite>fitfunc</cite>, and <cite>y</cite> and <cite>e</cite> correspond to the <cite>data[1]</cite> and
<cite>data[2]</cite> arrays. <cite>lnpost</cite> should return a single float value. See
<a class="reference internal" href="#refnx.analysis.CurveFitter.emcee" title="refnx.analysis.CurveFitter.emcee"><code class="xref py py-meth docutils literal"><span class="pre">CurveFitter.emcee</span></code></a> for further details.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The default cost function for CurveFitter is:</p>
<div class="math">
\[\chi^2=\sum \left(\frac{\mathrm{data[1]} - \mathrm{fitfunc}}{\mathrm{data[2]}}\right)^2\]</div>
<p>This user defined cost function can be used to specify other cost
functions for <cite>differential_evolution</cite>, <cite>leastsq</cite>, <cite>least_squares</cite>.</p>
<dl class="attribute">
<dt id="refnx.analysis.CurveFitter.data">
<code class="descname">data</code><a class="headerlink" href="#refnx.analysis.CurveFitter.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The unmasked data, and the mask</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>(x, y, e, mask)</strong> : data tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.CurveFitter.emcee">
<code class="descname">emcee</code><span class="sig-paren">(</span><em>params=None</em>, <em>steps=1000</em>, <em>nwalkers=100</em>, <em>burn=0</em>, <em>thin=1</em>, <em>ntemps=1</em>, <em>pos=None</em>, <em>reuse_sampler=False</em>, <em>workers=1</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.emcee"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.CurveFitter.emcee" title="Permalink to this definition">¶</a></dt>
<dd><p>Bayesian sampling of the posterior distribution for the parameters
using the <cite>emcee</cite> Markov Chain Monte Carlo package. By default the
method assumes that the prior is Uniform. To implement non-uniform
priors use the <cite>lnpost</cite> kwd when constructing the CurveFitter. You
need to have <cite>emcee</cite> installed to use this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters, optional</p>
<blockquote>
<div><p>Parameters to use as starting point. If this is not specified
then the Parameters used to initialise the CurveFitter object are
used.</p>
</div></blockquote>
<p><strong>steps</strong> : int, optional</p>
<blockquote>
<div><p>How many samples you would like to draw from the posterior
distribution for each of the walkers?</p>
</div></blockquote>
<p><strong>nwalkers</strong> : int, optional</p>
<blockquote>
<div><p>Should be set so <span class="math">\(nwalkers &gt;&gt; nvarys\)</span>, where <cite>nvarys</cite> are
the number of parameters being varied during the fit.
&#8220;Walkers are the members of the ensemble. They are almost like
separate Metropolis-Hastings chains but, of course, the proposal
distribution for a given walker depends on the positions of all
the other walkers in the ensemble.&#8221; - from the <cite>emcee</cite> webpage.</p>
</div></blockquote>
<p><strong>burn</strong> : int, optional</p>
<blockquote>
<div><p>Discard this many samples from the start of the sampling regime.</p>
</div></blockquote>
<p><strong>thin</strong> : int, optional</p>
<blockquote>
<div><p>Only accept 1 in every <cite>thin</cite> samples.</p>
</div></blockquote>
<p><strong>ntemps</strong> : int, optional</p>
<blockquote>
<div><p>If <cite>ntemps &gt; 1</cite> perform a Parallel Tempering.</p>
</div></blockquote>
<p><strong>pos</strong> : np.ndarray, optional</p>
<blockquote>
<div><p>Specify the initial positions for the sampler.  If <cite>ntemps == 1</cite>
then <cite>pos.shape</cite> should be <cite>(nwalkers, nvarys)</cite>. Otherwise,
<cite>(ntemps, nwalkers, nvarys)</cite>. You can also initialise using a
previous chain that had the same <cite>ntemps</cite>, <cite>nwalkers</cite> and
<cite>nvarys</cite>. Note that <cite>nvarys</cite> may be one larger than you expect it
to be if your <cite>userfcn</cite> returns an array and <cite>is_weighted is
False</cite>.</p>
</div></blockquote>
<p><strong>reuse_sampler</strong> : bool, optional</p>
<blockquote>
<div><p>If you have already run <cite>emcee</cite> on a given <cite>Minimizer</cite> object then
it possesses an internal <code class="docutils literal"><span class="pre">sampler</span></code> attribute. You can continue to
draw from the same sampler (retaining the chain history) if you set
this option to <cite>True</cite>. Otherwise a new sampler is created. The
<cite>nwalkers</cite>, <cite>ntemps</cite>, <cite>pos</cite>, and <cite>params</cite> keywords are ignored with
this option.
<strong>Important</strong>: the Parameters used to create the sampler must not
change in-between calls to <cite>emcee</cite>. Alteration of Parameters
would include changed <code class="docutils literal"><span class="pre">min</span></code>, <code class="docutils literal"><span class="pre">max</span></code>, <code class="docutils literal"><span class="pre">vary</span></code> and <code class="docutils literal"><span class="pre">expr</span></code>
attributes. This may happen, for example, if you use an altered
Parameters object and call the <cite>minimize</cite> method in-between calls
to <cite>emcee</cite>.</p>
</div></blockquote>
<p><strong>workers</strong> : Pool-like or int, optional</p>
<blockquote>
<div><p>For parallelization of sampling.  It can be any Pool-like object
with a map method that follows the same calling sequence as the
built-in <cite>map</cite> function. If int is given as the argument, then a
multiprocessing-based pool is spawned internally with the
corresponding number of parallel processes. &#8216;mpi4py&#8217;-based
parallelization and &#8216;joblib&#8217;-based parallelization pools can also
be used here. <strong>Note</strong>: because of multiprocessing overhead it may
only be worth parallelising if the objective function is expensive
to calculate, or if there are a large number of objective
evaluations per step (<cite>ntemps * nwalkers * nvarys</cite>).</p>
</div></blockquote>
<p><strong>seed</strong> : int or <cite>np.random.RandomState</cite>, optional</p>
<blockquote>
<div><p>If <cite>seed</cite> is an int, a new <cite>np.random.RandomState</cite> instance is used,
seeded with <cite>seed</cite>.
If <cite>seed</cite> is already a <cite>np.random.RandomState</cite> instance, then that
<cite>np.random.RandomState</cite> instance is used.
Specify <cite>seed</cite> for repeatable minimizations.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">result: MinimizerResult</p>
<blockquote class="last">
<div><p>MinimizerResult object containing updated params, statistics,
etc. The <cite>MinimizerResult</cite> also contains the <code class="docutils literal"><span class="pre">chain</span></code>,
<code class="docutils literal"><span class="pre">flatchain</span></code> and <code class="docutils literal"><span class="pre">lnprob</span></code> attributes. The <code class="docutils literal"><span class="pre">chain</span></code>
and <code class="docutils literal"><span class="pre">flatchain</span></code> attributes contain the samples and have the shape
<cite>(nwalkers, (steps - burn) // thin, nvarys)</cite> or
<cite>(ntemps, nwalkers, (steps - burn) // thin, nvarys)</cite>,
depending on whether Parallel tempering was used or not.
<cite>nvarys</cite> is the number of parameters that are allowed to vary.
The <code class="docutils literal"><span class="pre">flatchain</span></code> attribute is a <cite>pandas.DataFrame</cite> of the
flattened chain, <cite>chain.reshape(-1, nvarys)</cite>. To access flattened
chain values for a particular parameter use
<cite>result.flatchain[parname]</cite>. The <code class="docutils literal"><span class="pre">lnprob</span></code> attribute contains the
log probability for each sample in <code class="docutils literal"><span class="pre">chain</span></code>. The sample with the
highest probability corresponds to the maximum likelihood estimate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method samples the posterior distribution of the parameters using
Markov Chain Monte Carlo.  To do so it needs to calculate the
log-posterior probability of the model parameters, <cite>F</cite>, given the data,
<cite>D</cite>, <span class="math">\(\ln p(F_{true} | D)\)</span>. This &#8216;posterior probability&#8217; is
calculated as:</p>
<div class="math">
\[\ln p(F_{true} | D) \propto \ln p(D | F_{true}) + \ln p(F_{true})\]</div>
<p>where <span class="math">\(\ln p(D | F_{true})\)</span> is the &#8216;log-likelihood&#8217; and
<span class="math">\(\ln p(F_{true})\)</span> is the &#8216;log-prior&#8217;. The default log-prior
encodes prior information already known about the model. This method
assumes that the log-prior probability is <cite>-np.inf</cite> (impossible) if the
one of the parameters is outside its limits. The log-prior probability
term is zero if all the parameters are inside their bounds (known as a
uniform prior). The default log-likelihood function is given by <a class="reference internal" href="#r2" id="id4">[R2]</a>:</p>
<div class="math">
\[\ln p(D|F_{true}) = -\frac{1}{2}\sum_n \left[\frac{\left(g_n(F_{true}) - D_n \right)^2}{s_n^2}+\ln (2\pi s_n^2)\right]\]</div>
<p>The first summand in the square brackets represents the residual for a
given datapoint (<span class="math">\(g\)</span> being the generative model) . This term
represents <span class="math">\(\chi^2\)</span> when summed over all datapoints.</p>
<p>It is also possible to calculate your own log-posterior probability, by
constructing the CurveFitter object with a <cite>lnpost</cite> function. This
will allow you to use non-uniform priors, etc. The <cite>lnpost</cite> function
has the signature:
<code class="docutils literal"><span class="pre">lnpost(pars,</span> <span class="pre">generative,</span> <span class="pre">y,</span> <span class="pre">e,</span> <span class="pre">*fcn_args,</span> <span class="pre">**fcn_kws)</span></code>. You should
return a single float from this <cite>lnpost</cite> function</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R2]</td><td><em>(<a class="fn-backref" href="#id4">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> <a class="reference external" href="http://dan.iel.fm/emcee/current/user/line/">http://dan.iel.fm/emcee/current/user/line/</a></td></tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.CurveFitter.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>method='leastsq'</em>, <em>params=None</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.CurveFitter.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : str, optional</p>
<blockquote>
<div><p>Name of the fitting method to use.
One of:</p>
<ul class="simple">
<li>&#8216;leastsq&#8217;                -    Levenberg-Marquardt (default)</li>
<li>&#8216;nelder&#8217;                 -    Nelder-Mead</li>
<li>&#8216;lbfgsb&#8217;                 -    L-BFGS-B</li>
<li>&#8216;powell&#8217;                 -    Powell</li>
<li>&#8216;cg&#8217;                     -    Conjugate-Gradient</li>
<li>&#8216;newton&#8217;                 -    Newton-CG</li>
<li>&#8216;cobyla&#8217;                 -    Cobyla</li>
<li>&#8216;tnc&#8217;                    -    Truncate Newton</li>
<li>&#8216;trust-ncg&#8217;              -    Trust Newton-CGn</li>
<li>&#8216;dogleg&#8217;                 -    Dogleg</li>
<li>&#8216;slsqp&#8217;                  -    Sequential Linear Squares Programming</li>
<li>&#8216;differential_evolution&#8217; -    differential evolution</li>
</ul>
</div></blockquote>
<p><strong>params</strong> : Parameters, optional</p>
<blockquote>
<div><p>parameters to use as starting values</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : lmfit.MinimizerResult</p>
<blockquote class="last">
<div><p>Result object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="refnx.analysis.CurveFitter.is_weighted">
<code class="descname">is_weighted</code><a class="headerlink" href="#refnx.analysis.CurveFitter.is_weighted" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the truth that the fit is weighted by measurement uncertainties</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.CurveFitter.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.CurveFitter.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the model. This is a convenience method. Over-riding it will
not change a fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters instance</p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>model</strong> : array_like</p>
<blockquote class="last">
<div><p>The model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.CurveFitter.residuals">
<code class="descname">residuals</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.residuals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.CurveFitter.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the difference between the data and the model. Also known as
the objective function. This is a convenience method. Over-riding it
will not change a fit.</p>
<p><span class="math">\(residuals = (fitfunc - y) / edata\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters instance</p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>residuals</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The difference between the data and the model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.FitFunction">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">FitFunction</code><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.FitFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/3/library/functions.html#object" title="(in Python v3.5)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>An abstract FitFunction class.</p>
<dl class="method">
<dt id="refnx.analysis.FitFunction.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>x</em>, <em>params</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.FitFunction.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the predictive model for the fit.
Override this method in your own fitfunction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like</p>
<blockquote>
<div><p>The independent variable for the fit</p>
</div></blockquote>
<p><strong>params</strong> : lmfit.Parameters</p>
<blockquote>
<div><p>The model parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>predictive</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The predictive model for the fitfunction.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p><cite>args</cite> and <cite>kws</cite> can be used to fully specify the fit function.
Normally you would supply these via when the <strong>FitFunction</strong> object is
constructed.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="refnx.analysis.FitFunction.parameter_names">
<em class="property">static </em><code class="descname">parameter_names</code><span class="sig-paren">(</span><em>nparams=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction.parameter_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.FitFunction.parameter_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a set of names for constructing an <a class="reference external" href="http://lmfit.github.io/lmfit-py/parameters.html#lmfit.parameter.Parameters" title="(in lmfit v)"><code class="xref py py-class docutils literal"><span class="pre">lmfit.parameter.Parameters</span></code></a> instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nparams: int, optional</strong></p>
<blockquote>
<div><p>&gt;= 0 - provide a set of names with length <cite>nparams</cite></p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>&#8212;&#8212;-</strong></p>
<p><strong>names: list</strong></p>
<blockquote class="last">
<div><p>names for the lmfit.Parameters instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.GlobalFitter">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">GlobalFitter</code><span class="sig-paren">(</span><em>fitters</em>, <em>constraints=()</em>, <em>kws=None</em>, <em>callback=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.GlobalFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#refnx.analysis.curvefitter.CurveFitter" title="refnx.analysis.curvefitter.CurveFitter"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.curvefitter.CurveFitter</span></code></a></p>
<p>Simultaneous curvefitting of multiple datasets</p>
<dl class="docutils">
<dt>fitters</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">sequence of <a class="reference internal" href="#refnx.analysis.curvefitter.CurveFitter" title="refnx.analysis.curvefitter.CurveFitter"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.curvefitter.CurveFitter</span></code></a> instances</span><dd>Contains all the fitters and fitfunctions for the global fit.</dd>
<dt>constraints</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">str sequence, optional</span><dd>Of the type &#8216;dN:param_name = constraint&#8217;. Sets a constraint
expression for the parameter <cite>param_name</cite> in dataset N. The
constraint &#8216;d2:scale = 2 * d0:back&#8217; constrains the <cite>scale</cite>
parameter in dataset 2 to be twice the <cite>back</cite> parameter in
dataset 0.
<strong>Important</strong> For a parameter (<cite>d2:scale</cite> in this example) to be
constrained by this mechanism it must not have any pre-existing
constraints within its individual fitter. If there are pre-existing
constraints then those are honoured, and constraints specified here are
ignored.</dd>
<dt>kws</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span><dd>Extra minimization keywords to be passed to the minimizer of choice.</dd>
<dt>callback</dt>
 <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span><dd>Function called at each step of the minimization. Has the signature
<code class="docutils literal"><span class="pre">callback(params,</span> <span class="pre">iter,</span> <span class="pre">resid)</span></code></dd>
</dl>
<dl class="method">
<dt id="refnx.analysis.GlobalFitter.distribute_params">
<code class="descname">distribute_params</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter.distribute_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.GlobalFitter.distribute_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for re-distributing global parameter values
back into each of the original <cite>CurveFitter.params</cite> attributes.</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.GlobalFitter.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.GlobalFitter.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the model. This method is provided for convenience purposes
and is not used during a fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params: lmfit.Parameters</strong></p>
<blockquote>
<div><p>Specifies the entire parameter set, across all the datasets</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>model</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.GlobalFitter.residuals">
<code class="descname">residuals</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter.residuals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.GlobalFitter.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the difference between the data and the model. Also known as
the objective function.  This is a convenience method. Over-riding it
does not change the fitting process.
residuals = (fitfunc - y) / edata</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params: lmfit.Parameters</strong></p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>residuals</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The difference between the data and the model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.ReflectivityFitFunction">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">ReflectivityFitFunction</code><span class="sig-paren">(</span><em>transform=None</em>, <em>dq=5.0</em>, <em>quad_order=17</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#refnx.analysis.curvefitter.FitFunction" title="refnx.analysis.curvefitter.FitFunction"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.curvefitter.FitFunction</span></code></a></p>
<p>A sub class of <cite>refnx.analysis.curvefitter.FitFunction</cite> suited for
calculation of reflectometry profiles from a simple slab model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>transform</strong> : callable, optional</p>
<blockquote>
<div><p>If specified then this function is used to transform the data
returned by the model method. With the signature:
<code class="docutils literal"><span class="pre">transformed_y_vals</span> <span class="pre">=</span> <span class="pre">transform(x_vals,</span> <span class="pre">y_vals)</span></code>.</p>
</div></blockquote>
<p><strong>dq</strong> : float, optional</p>
<blockquote>
<div><p>Default dq/q resolution (as a percentage).</p>
</div></blockquote>
<p><strong>quad_order</strong> : int or str, optional</p>
<blockquote>
<div><p>The order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For
example 13 points may be fine for a thin layer, but will be
atrocious at describing a multilayer with Bragg peaks.</p>
</div></blockquote>
<p><strong>parallel</strong> : bool, optional</p>
<blockquote class="last">
<div><p>Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="refnx.analysis.ReflectivityFitFunction.callback">
<code class="descname">callback</code><span class="sig-paren">(</span><em>parameters</em>, <em>iteration</em>, <em>resid</em>, <em>*fcn_args</em>, <em>**fcn_kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction.callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="refnx.analysis.ReflectivityFitFunction.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>x</em>, <em>parameters</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the theoretical model, given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like</p>
<blockquote>
<div><p>Q values to evaluate the reflectivity at</p>
</div></blockquote>
<p><strong>parameters</strong> : lmfit.Parameters instance or sequence</p>
<blockquote>
<div><p>Contains the parameters that are required for reflectivity
calculation. See <code class="docutils literal"><span class="pre">reflectivity</span></code> for the required parameters for
calculation</p>
</div></blockquote>
<p><strong>kwds[&#8216;dqvals&#8217;]</strong> : float or np.ndarray, optional</p>
<blockquote>
<div><p>If dqvals is a float, then a constant dQ/Q resolution smearing is
employed.  For 5% resolution smearing supply 5.
If <cite>dqvals</cite> is the same shape as q, then the array contains the
FWHM of a Gaussian approximated resolution kernel. Point by point
resolution smearing is employed.  Use this option if dQ/Q varies
across your dataset.
If <cite>dqvals.ndim == q.ndim + 2</cite> and
<cite>q.shape == dqvals[..., -3].shape</cite> then an individual resolution
kernel is applied to each measurement point.  This resolution kernel
is a probability distribution function (PDF). <cite>dqvals</cite> will have the
shape (qvals.shape, M, 2).  There are <cite>M</cite> points in the kernel.
<cite>dqvals[..., 0]</cite> holds the q values for the kernel, <cite>dqvals[..., 1]</cite>
gives the corresponding probability.</p>
</div></blockquote>
<p><strong>kwds[&#8216;quad_order&#8217;]</strong> : int, optional</p>
<blockquote>
<div><p>the order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For example,
13 points may be fine for a thin layer, but will be atrocious at
describing a multilayer with bragg peaks.</p>
</div></blockquote>
<p><strong>kwds[&#8216;parallel&#8217;]</strong> : bool, optional</p>
<blockquote>
<div><p>Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>. The
default is <cite>True</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The predictive model, i.e.
<code class="docutils literal"><span class="pre">reflectivity(x,</span> <span class="pre">parameters,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="refnx.analysis.ReflectivityFitFunction.parameter_names">
<em class="property">static </em><code class="descname">parameter_names</code><span class="sig-paren">(</span><em>nparams=8</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.parameter_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction.parameter_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter names for a default reflectivity calculation</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.ReflectivityFitFunction.set_dq">
<code class="descname">set_dq</code><span class="sig-paren">(</span><em>dq</em>, <em>quad_order=17</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.set_dq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction.set_dq" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the resolution information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dq</strong> : None, float or np.ndarray</p>
<blockquote>
<div><p>If <cite>None</cite> then there is no resolution smearing.
If a float, e.g. 5, then dq/q smearing of 5% is applied. If dq==0
then resolution smearing is removed.
If an np.ndarray the same length as y, it contains the FWHM of
the Gaussian approximated resolution kernel.</p>
</div></blockquote>
<p><strong>quad_order</strong> : int or &#8216;ultimate&#8217;</p>
<blockquote class="last">
<div><p>The order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For
example 13 points may be fine for a thin layer, but will be
atrocious at describing a multilayer with Bragg peaks.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.ReflectivityFitFunction.sld_profile">
<code class="descname">sld_profile</code><span class="sig-paren">(</span><em>parameters</em>, <em>z=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.sld_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction.sld_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the SLD profile corresponding to the model parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parameters</strong> : lmfit.parameters.Parameters instance or sequence</p>
<p><strong>z</strong> : array-like, optional</p>
<blockquote>
<div><p>Interfacial distances to evaluate the SLD profile at.
z = 0 corresponds to the interfaces between the fronting medium
and the first layer</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>(z, rho_z)</strong> : tuple of np.ndarrays</p>
<blockquote class="last">
<div><p>The distance from the top interface and the SLD at that point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.Transform">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">Transform</code><span class="sig-paren">(</span><em>form</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#Transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/3/library/functions.html#object" title="(in Python v3.5)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Mathematical transforms of numeric data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>form</strong> : None or str</p>
<blockquote class="last">
<div><p>One of:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>&#8216;lin&#8217;</dt>
<dd><p class="first last">No transform is made</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;logY&#8217;</dt>
<dd><p class="first last">log10 transform</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;YX4&#8217;</dt>
<dd><p class="first last">YX**4 transform</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;YX2&#8217;</dt>
<dd><p class="first last">YX**2 transform</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>None</dt>
<dd><p class="first last">No transform is made</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="refnx.analysis.Transform.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>xdata</em>, <em>ydata</em>, <em>edata=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#Transform.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Transform.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the data passed in</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>xdata</strong> : array-like</p>
<p><strong>ydata</strong> : array-like</p>
<p><strong>edata</strong> : array-like</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>yt, et</strong> : tuple</p>
<blockquote class="last">
<div><p>The transformed data</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="refnx.analysis.abeles">
<code class="descclassname">refnx.analysis.</code><code class="descname">abeles</code><span class="sig-paren">(</span><em>q</em>, <em>layers</em>, <em>scale=1</em>, <em>bkg=0.0</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#abeles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.abeles" title="Permalink to this definition">¶</a></dt>
<dd><p>Abeles matrix formalism for calculating reflectivity from a stratified
medium.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q</strong> : array_like</p>
<blockquote>
<div><p>the q values required for the calculation.
<span class="math">\(Q = \frac{4\pi}{\lambda}\sin(\Omega)\)</span>.
Units = Angstrom**-1</p>
</div></blockquote>
<p><strong>layers</strong> : np.ndarray</p>
<blockquote>
<div><p>coefficients required for the calculation, has shape (2 + N, 4),
where N is the number of layers</p>
<ul class="simple">
<li>layers[0, 1] - SLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[0, 2] - iSLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 0] - thickness of layer N</li>
<li>layers[N, 1] - SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 2] - iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 3] - roughness between layer N-1/N</li>
<li>layers[-1, 1] - SLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 2] - iSLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 3] - roughness between backing and last layer</li>
</ul>
</div></blockquote>
<p><strong>scale</strong> : float</p>
<blockquote>
<div><p>Multiply all reflectivities by this value.</p>
</div></blockquote>
<p><strong>bkg</strong> : float</p>
<blockquote>
<div><p>Linear background to be added to all reflectivities</p>
</div></blockquote>
<p><strong>parallel</strong> : bool</p>
<blockquote>
<div><p>Do you want to calculate in parallel? This option is only applicable if
you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is ignored if using
the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Reflectivity: np.ndarray</p>
<blockquote class="last">
<div><p>Calculated reflectivity values for each q value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.bounds">
<code class="descclassname">refnx.analysis.</code><code class="descname">bounds</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.clear_bounds">
<code class="descclassname">refnx.analysis.</code><code class="descname">clear_bounds</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#clear_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.clear_bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.exprs">
<code class="descclassname">refnx.analysis.</code><code class="descname">exprs</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#exprs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.exprs" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and returns
the the constraint expressions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parameters</strong> : lmfit.Parameters</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>exprs</strong> : list of str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.fitfunc">
<code class="descclassname">refnx.analysis.</code><code class="descname">fitfunc</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#fitfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.fitfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that can be used to say if something is a fitfunc.</p>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.names">
<code class="descclassname">refnx.analysis.</code><code class="descname">names</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflectivity">
<code class="descclassname">refnx.analysis.</code><code class="descname">reflectivity</code><span class="sig-paren">(</span><em>q</em>, <em>coefs</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#reflectivity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Abeles matrix formalism for calculating reflectivity from a stratified
medium.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q</strong> : np.ndarray</p>
<blockquote>
<div><p>The qvalues required for the calculation. <span class="math">\(Q=\frac{4Pi}{\lambda}\sin(\Omega)\)</span>.
Units = Angstrom**-1</p>
</div></blockquote>
<p><strong>coefs</strong> : np.ndarray</p>
<blockquote>
<div><ul class="simple">
<li>coefs[0] - number of layers, N</li>
<li>coefs[1] - scale factor</li>
<li>coefs[2] - SLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[3] - iSLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[4] - SLD of backing</li>
<li>coefs[5] - iSLD of backing</li>
<li>coefs[6] - background</li>
<li>coefs[7] - roughness between backing and layer N</li>
<li>coefs[4 * (N - 1) + 8] = thickness of layer N in Angstrom (layer 1 is
closest to fronting)</li>
<li>coefs[4 * (N - 1) + 9] - SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>coefs[4 * (N - 1) + 10] - iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>coefs[4 * (N - 1) + 11] - roughness between layer N and N-1.</li>
</ul>
</div></blockquote>
<p><strong>kwds</strong> : dict, optional</p>
<blockquote class="last">
<div><p>The following keys are used:</p>
<dl class="docutils">
<dt>&#8216;dqvals&#8217;: float or np.ndarray, optional</dt>
<dd><p class="first last">If dqvals is a float, then a constant dQ/Q resolution smearing is
employed.  For 5% resolution smearing supply 5.
If <cite>dqvals</cite> is the same shape as q, then the array contains the
FWHM of a Gaussian approximated resolution kernel. Point by point
resolution smearing is employed.  Use this option if dQ/Q varies
across your dataset.
If <cite>dqvals.ndim == q.ndim + 2</cite> and
<cite>q.shape == dqvals[..., -3].shape</cite> then an individual resolution
kernel is applied to each measurement point.  This resolution kernel
is a probability distribution function (PDF). <cite>dqvals</cite> will have the
shape (qvals.shape, M, 2).  There are <cite>M</cite> points in the kernel.
<cite>dqvals[..., 0]</cite> holds the q values for the kernel, <cite>dqvals[..., 1]</cite>
gives the corresponding probability.</p>
</dd>
<dt>&#8216;quad_order&#8217;: int, optional</dt>
<dd><p class="first last">the order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For example,
13 points may be fine for a thin layer, but will be atrocious at
describing a multilayer with bragg peaks.</p>
</dd>
<dt>&#8216;parallel&#8217;: bool, optional</dt>
<dd><p class="first last">Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>. The
default is <cite>True</cite>.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.to_parameters">
<code class="descclassname">refnx.analysis.</code><code class="descname">to_parameters</code><span class="sig-paren">(</span><em>p0</em>, <em>varies=None</em>, <em>bounds=None</em>, <em>names=None</em>, <em>expr=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#to_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.to_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function to convert sequences into a <a class="reference external" href="http://lmfit.github.io/lmfit-py/parameters.html#lmfit.parameter.Parameters" title="(in lmfit v)"><code class="xref py py-class docutils literal"><span class="pre">lmfit.parameter.Parameters</span></code></a> instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p0</strong> : np.ndarray</p>
<blockquote>
<div><p>numpy array containing parameter values.</p>
</div></blockquote>
<p><strong>varies</strong> : bool sequence, optional</p>
<blockquote>
<div><p>Specifies whether a parameter is being held or varied.</p>
</div></blockquote>
<p><strong>bounds</strong> : sequence, optional</p>
<blockquote>
<div><p>Tuple of (min, max) pairs specifying the lower and upper bounds for
each parameter</p>
</div></blockquote>
<p><strong>name</strong> : str sequence, optional</p>
<blockquote>
<div><p>Name of each parameter</p>
</div></blockquote>
<p><strong>expr</strong> : str sequence, optional</p>
<blockquote>
<div><p>Constraints for each parameter</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>p</strong> : lmfit.Parameters instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.values">
<code class="descclassname">refnx.analysis.</code><code class="descname">values</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.values" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and returns
the values</p>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.varys">
<code class="descclassname">refnx.analysis.</code><code class="descname">varys</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#varys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.varys" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and finds
out which ones vary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parameters</strong> : lmfit.Parameters</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">varys: bool, sequence</p>
<blockquote class="last">
<div><p>Which parameters are varying</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">refnx.analysis package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-refnx.analysis.curvefitter">refnx.analysis.curvefitter module</a></li>
<li><a class="reference internal" href="#module-refnx.analysis.reflect">refnx.analysis.reflect module</a></li>
<li><a class="reference internal" href="#module-refnx.analysis">Module contents</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/refnx.analysis.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Andrew Nelson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
      |
      <a href="_sources/refnx.analysis.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>