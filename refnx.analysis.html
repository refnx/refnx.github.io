<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>refnx.analysis package &mdash; refnx 0.0.3 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="refnx 0.0.3 documentation" href="index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="refnx-analysis-package">
<h1>refnx.analysis package<a class="headerlink" href="#refnx-analysis-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-refnx.analysis.curvefitter">
<span id="refnx-analysis-curvefitter-module"></span><h2>refnx.analysis.curvefitter module<a class="headerlink" href="#module-refnx.analysis.curvefitter" title="Permalink to this headline">¶</a></h2>
<p>Created on Sun Dec 21 15:37:29 2014</p>
<p>&#64;author: Andrew Nelson</p>
<dl class="class">
<dt id="refnx.analysis.curvefitter.CurveFitter">
<em class="property">class </em><code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">CurveFitter</code><span class="sig-paren">(</span><em>fitfunc</em>, <em>data</em>, <em>params</em>, <em>mask=None</em>, <em>fcn_args=()</em>, <em>fcn_kws=None</em>, <em>kws=None</em>, <em>callback=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">lmfit.minimizer.Minimizer</span></code></p>
<p>A curvefitting class that extends <cite>lmfit.Minimize</cite></p>
<dl class="docutils">
<dt>fitfunc <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd>Function calculating the generative model for the fit.  Should have
the signature: <code class="docutils literal"><span class="pre">fitfunc(x,</span> <span class="pre">params,</span> <span class="pre">*fcn_args,</span> <span class="pre">**fcn_kws)</span></code>. You
can also supply a <code class="docutils literal"><span class="pre">FitFunction</span></code> instance.</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">sequence, refnx.dataset.Data1D instance, str or file-like object</span></dt>
<dd><p class="first">A sequence containing the data to be analysed.
If <cite>data</cite> is a sequence then:</p>
<blockquote>
<div><ul>
<li><p class="first">data[0] - the independent variable (x-data)</p>
</li>
<li><p class="first">data[1] - the dependent (observed) variable (y-data)</p>
</li>
<li><dl class="first docutils">
<dt>data[2] - measured uncertainty in the dependent variable, expressed</dt>
<dd><p class="first last">as a standard deviation.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Only data[0] and data[1] are required, data[2] is optional. If data[2]
is not specified then the measured uncertainty is set to unity.</p>
<p class="last"><cite>data</cite> can also be a Data1D instance containing the data.
If <cite>data</cite> is a string, or file-like object then the string or file-like
object refers to a file containing the data. The data will be loaded
through the <cite>refnx.dataset.Data1D</cite> constructor.</p>
</dd>
<dt>params <span class="classifier-delimiter">:</span> <span class="classifier">lmfit.Parameters instance</span></dt>
<dd>Specifies the parameter set for the fit</dd>
<dt>mask <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, optional</span></dt>
<dd>A boolean array with the same shape as <cite>y</cite>.  If <cite>mask is True</cite>
then that point is excluded from the residuals calculation.</dd>
<dt>fcn_args <span class="classifier-delimiter">:</span> <span class="classifier">tuple, optional</span></dt>
<dd>Extra parameters required to fully specify fitfunc.</dd>
<dt>fcn_kws <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd>Extra keyword parameters needed to fully specify fitfunc.</dd>
<dt>minimizer_kwds <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd>Keywords passed to the minimizer.</dd>
<dt>callback <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span></dt>
<dd>A function called at each minimization step. Has the signature:
<code class="docutils literal"><span class="pre">callback(params,</span> <span class="pre">iter,</span> <span class="pre">resid,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></dd>
</dl>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="attribute">
<dt id="refnx.analysis.curvefitter.CurveFitter.data">
<code class="descname">data</code><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The unmasked data, and the mask</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>(x, y, e, mask)</strong> : data tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.curvefitter.CurveFitter.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>method='leastsq'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : str, optional</p>
<blockquote>
<div><p>Name of the fitting method to use.
One of:</p>
<ul class="simple">
<li>&#8216;leastsq&#8217;                -    Levenberg-Marquardt (default)</li>
<li>&#8216;nelder&#8217;                 -    Nelder-Mead</li>
<li>&#8216;lbfgsb&#8217;                 -    L-BFGS-B</li>
<li>&#8216;powell&#8217;                 -    Powell</li>
<li>&#8216;cg&#8217;                     -    Conjugate-Gradient</li>
<li>&#8216;newton&#8217;                 -    Newton-CG</li>
<li>&#8216;cobyla&#8217;                 -    Cobyla</li>
<li>&#8216;tnc&#8217;                    -    Truncate Newton</li>
<li>&#8216;trust-ncg&#8217;              -    Trust Newton-CGn</li>
<li>&#8216;dogleg&#8217;                 -    Dogleg</li>
<li>&#8216;slsqp&#8217;                  -    Sequential Linear Squares Programming</li>
<li>&#8216;differential_evolution&#8217; -    differential evolution</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : lmfit.MinimizerResult</p>
<blockquote class="last">
<div><p>Result object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.curvefitter.CurveFitter.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the model. This is a convenience method. Over-riding it will
not change a fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters instance</p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>model</strong> : array_like</p>
<blockquote class="last">
<div><p>The model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.curvefitter.CurveFitter.residuals">
<code class="descname">residuals</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.residuals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.CurveFitter.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the difference between the data and the model. Also known as
the objective function. This is a convenience method. Over-riding it
will not change a fit.</p>
<p><span class="math">\(residuals = (fitfunc - y) / edata\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters instance</p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>residuals</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The difference between the data and the model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.curvefitter.FitFunction">
<em class="property">class </em><code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">FitFunction</code><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.FitFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>An abstract FitFunction class.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="refnx.analysis.curvefitter.FitFunction.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>x</em>, <em>params</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.FitFunction.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the predictive model for the fit.
Override this method in your own fitfunction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like</p>
<blockquote>
<div><p>The independent variable for the fit</p>
</div></blockquote>
<p><strong>params</strong> : lmfit.Parameters</p>
<blockquote>
<div><p>The model parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>predictive</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The predictive model for the fitfunction.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p><cite>args</cite> and <cite>kws</cite> can be used to fully specify the fit function.
Normally you would supply these via when the <strong>FitFunction</strong> object is
constructed.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="refnx.analysis.curvefitter.FitFunction.parameter_names">
<em class="property">static </em><code class="descname">parameter_names</code><span class="sig-paren">(</span><em>nparams=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction.parameter_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.FitFunction.parameter_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a set of names for constructing an <cite>lmfit.Parameters</cite> instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nparams: int, optional</strong></p>
<blockquote>
<div><p>&gt;= 0 - provide a set of names with length <cite>nparams</cite></p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>&#8212;&#8212;-</strong></p>
<p><strong>names: list</strong></p>
<blockquote class="last">
<div><p>names for the lmfit.Parameters instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.curvefitter.GlobalFitter">
<em class="property">class </em><code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">GlobalFitter</code><span class="sig-paren">(</span><em>fitters</em>, <em>constraints=()</em>, <em>kws=None</em>, <em>callback=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.GlobalFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#refnx.analysis.curvefitter.CurveFitter" title="refnx.analysis.curvefitter.CurveFitter"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.curvefitter.CurveFitter</span></code></a></p>
<p>Simultaneous curvefitting of multiple datasets</p>
<dl class="docutils">
<dt>fitters: sequence of CurveFitter instances</dt>
<dd>Contains all the fitters and fitfunctions for the global fit.</dd>
<dt>constraints: str sequence, optional</dt>
<dd>Of the type &#8216;dN:param_name = constraint&#8217;. Sets a constraint
expression for the parameter <cite>param_name</cite> in dataset N. The
constraint &#8216;d2:scale = 2 * d0:back&#8217; constrains the <cite>scale</cite>
parameter in dataset 2 to be twice the <cite>back</cite> parameter in
dataset 0.
<strong>Important</strong> For a parameter (<cite>d2:scale</cite> in this example) to be
constrained by this mechanism it must not have any pre-existing
constraints within its individual fitter. If there are pre-existing
constraints then those are honoured, and constraints specified here are
ignored.</dd>
<dt>kws: dict, optional</dt>
<dd>Extra minimization keywords to be passed to the minimizer of choice.</dd>
<dt>callback: callable, optional</dt>
<dd>Function called at each step of the minimization. Has the signature
<code class="docutils literal"><span class="pre">callback(params,</span> <span class="pre">iter,</span> <span class="pre">resid)</span></code></dd>
</dl>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="refnx.analysis.curvefitter.GlobalFitter.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.GlobalFitter.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the model. This method is provided for convenience purposes
and is not used during a fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params: lmfit.Parameters</strong></p>
<blockquote>
<div><p>Specifies the entire parameter set, across all the datasets</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>model</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.curvefitter.GlobalFitter.residuals">
<code class="descname">residuals</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter.residuals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.GlobalFitter.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the difference between the data and the model. Also known as
the objective function.  This is a convenience method. Over-riding it
does not change the fitting process.
residuals = (fitfunc - y) / edata</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params: lmfit.Parameters</strong></p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>residuals</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The difference between the data and the model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.bounds">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">bounds</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.clear_bounds">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">clear_bounds</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#clear_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.clear_bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.exprs">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">exprs</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#exprs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.exprs" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and returns
the the constraint expressions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parameters</strong> : lmfit.Parameters</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>exprs</strong> : list of str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.fitfunc">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">fitfunc</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#fitfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.fitfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that can be used to say if something is a fitfunc.</p>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.names">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">names</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.to_parameters">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">to_parameters</code><span class="sig-paren">(</span><em>p0</em>, <em>varies=None</em>, <em>bounds=None</em>, <em>names=None</em>, <em>expr=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#to_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.to_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function to convert sequences into a lmfit.Parameters instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p0</strong> : np.ndarray</p>
<blockquote>
<div><p>numpy array containing parameter values.</p>
</div></blockquote>
<p><strong>varies</strong> : bool sequence, optional</p>
<blockquote>
<div><p>Specifies whether a parameter is being held or varied.</p>
</div></blockquote>
<p><strong>bounds</strong> : sequence, optional</p>
<blockquote>
<div><p>Tuple of (min, max) pairs specifying the lower and upper bounds for
each parameter</p>
</div></blockquote>
<p><strong>name</strong> : str sequence, optional</p>
<blockquote>
<div><p>Name of each parameter</p>
</div></blockquote>
<p><strong>expr</strong> : str sequence, optional</p>
<blockquote>
<div><p>Constraints for each parameter</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>p</strong> : lmfit.Parameters instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.values">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">values</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.values" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and returns
the values</p>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.curvefitter.varys">
<code class="descclassname">refnx.analysis.curvefitter.</code><code class="descname">varys</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#varys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.curvefitter.varys" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and finds
out which ones vary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parameters</strong> : lmfit.Parameters</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>varys</strong> : bool, sequence</p>
<blockquote class="last">
<div><p>Which parameters are varying</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-refnx.analysis.reflect">
<span id="refnx-analysis-reflect-module"></span><h2>refnx.analysis.reflect module<a class="headerlink" href="#module-refnx.analysis.reflect" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction">
<em class="property">class </em><code class="descclassname">refnx.analysis.reflect.</code><code class="descname">ReflectivityFitFunction</code><span class="sig-paren">(</span><em>transform=None</em>, <em>dq=5.0</em>, <em>quad_order=17</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#refnx.analysis.curvefitter.FitFunction" title="refnx.analysis.curvefitter.FitFunction"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.curvefitter.FitFunction</span></code></a></p>
<p>A sub class of <cite>refnx.analysis.curvefitter.FitFunction</cite> suited for
calculation of reflectometry profiles.</p>
<p>If you wish to fit analytic or freeform SLD profiles you should
inherit this class, overriding the <cite>model</cite> method.  If you do this
you should also override the <cite>sld_profile</cite> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>transform</strong> : callable, optional</p>
<blockquote>
<div><p>If specified then this function is used to transform the data
returned by the model method. With the signature:
<code class="docutils literal"><span class="pre">transformed_y_vals</span> <span class="pre">=</span> <span class="pre">transform(x_vals,</span> <span class="pre">y_vals)</span></code>.</p>
</div></blockquote>
<p><strong>dq</strong> : float, optional</p>
<blockquote>
<div><p>Default dq/q resolution (as a percentage).</p>
</div></blockquote>
<p><strong>quad_order</strong> : int or str, optional</p>
<blockquote>
<div><p>The order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For
example 13 points may be fine for a thin layer, but will be
atrocious at describing a multilayer with Bragg peaks.</p>
</div></blockquote>
<p><strong>parallel: bool, optional</strong></p>
<blockquote class="last">
<div><p>Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction.callback">
<code class="descname">callback</code><span class="sig-paren">(</span><em>parameters</em>, <em>iteration</em>, <em>resid</em>, <em>*fcn_args</em>, <em>**fcn_kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction.callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>x</em>, <em>parameters</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the theoretical model, given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like</p>
<blockquote>
<div><p>Q values to evaluate the reflectivity at</p>
</div></blockquote>
<p><strong>parameters</strong> : lmfit.Parameters instance</p>
<blockquote>
<div><p>Contains the parameters that are required for reflectivity
calculation.</p>
</div></blockquote>
<p><strong>kwds[&#8216;dqvals&#8217;] - float or np.ndarray, optional</strong></p>
<blockquote>
<div><p>If dqvals is a float, then a constant dQ/Q resolution smearing is
employed.  For 5% resolution smearing supply 5.
If <cite>dqvals</cite> is the same shape as q, then the array contains the
FWHM of a Gaussian approximated resolution kernel. Point by point
resolution smearing is employed.  Use this option if dQ/Q varies
across your dataset.
If <cite>dqvals.ndim == q.ndim + 2</cite> and
<cite>q.shape == dqvals[..., -3].shape</cite> then an individual resolution
kernel is applied to each measurement point.  This resolution kernel
is a probability distribution function (PDF). <cite>dqvals</cite> will have the
shape (qvals.shape, M, 2).  There are <cite>M</cite> points in the kernel.
<cite>dqvals[..., 0]</cite> holds the q values for the kernel, <cite>dqvals[..., 1]</cite>
gives the corresponding probability.</p>
</div></blockquote>
<p><strong>kwds[&#8216;quad_order&#8217;] - int, optional</strong></p>
<blockquote>
<div><p>the order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For example,
13 points may be fine for a thin layer, but will be atrocious at
describing a multilayer with bragg peaks.</p>
</div></blockquote>
<p><strong>kwds[&#8216;parallel&#8217;]: bool, optional</strong></p>
<blockquote>
<div><p>Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>. The
default is <cite>True</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>yvals</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The theoretical model for the x, i.e.
reflectivity(x, parameters, <a href="#id1"><span class="problematic" id="id2">*</span></a>args, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwds)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction.parameter_names">
<em class="property">static </em><code class="descname">parameter_names</code><span class="sig-paren">(</span><em>nparams=8</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.parameter_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction.parameter_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter names for a default reflectivity calculation</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction.set_dq">
<code class="descname">set_dq</code><span class="sig-paren">(</span><em>dq</em>, <em>quad_order=17</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.set_dq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction.set_dq" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the resolution information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dq: None, float or np.ndarray</strong></p>
<blockquote>
<div><p>If <cite>None</cite> then there is no resolution smearing.
If a float, e.g. 5, then dq/q smearing of 5% is applied. If dq==0
then resolution smearing is removed.
If an np.ndarray the same length as y, it contains the FWHM of
the Gaussian approximated resolution kernel.</p>
</div></blockquote>
<p><strong>quad_order: int or &#8216;ultimate&#8217;</strong></p>
<blockquote class="last">
<div><p>The order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For
example 13 points may be fine for a thin layer, but will be
atrocious at describing a multilayer with Bragg peaks.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.reflect.ReflectivityFitFunction.sld_profile">
<code class="descname">sld_profile</code><span class="sig-paren">(</span><em>parameters</em>, <em>points=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.sld_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.ReflectivityFitFunction.sld_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the SLD profile corresponding to the model parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parameters</strong> : lmfit.parameters.Parameters instance</p>
<p><strong>points</strong> : array-like</p>
<blockquote>
<div><p>The points to evaluate the SLD profile at.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>(z, rho_z)</strong> : tuple of np.ndarrays</p>
<blockquote class="last">
<div><p>The distance from the top interface and the SLD at that point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.reflect.Transform">
<em class="property">class </em><code class="descclassname">refnx.analysis.reflect.</code><code class="descname">Transform</code><span class="sig-paren">(</span><em>form</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#Transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.Transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="refnx.analysis.reflect.Transform.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>xdata</em>, <em>ydata</em>, <em>edata=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#Transform.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.Transform.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>An irreversible transform from lin R vs Q, to some other form
form - specifies the transform</p>
<blockquote>
<div>form = None - no transform is made.
form = &#8216;logY&#8217; - log transform
form = &#8216;YX4&#8217; - YX**4 transform
form = &#8216;YX2&#8217; - YX**2 transform</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.abeles">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">abeles</code><span class="sig-paren">(</span><em>q</em>, <em>layers</em>, <em>scale=1</em>, <em>bkg=0.0</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#abeles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.abeles" title="Permalink to this definition">¶</a></dt>
<dd><p>Abeles matrix formalism for calculating reflectivity from a stratified
medium.
Parameters
&#8212;&#8212;&#8212;-
q: array_like</p>
<blockquote>
<div>the q values required for the calculation.
Q = 4 * Pi / lambda * sin(omega).
Units = Angstrom**-1</div></blockquote>
<dl class="docutils">
<dt>layers: np.ndarray</dt>
<dd><p class="first">coefficients required for the calculation, has shape (2 + N, 4),
where N is the number of layers</p>
<ul class="last simple">
<li>layers[0, 1] - SLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[0, 2] - iSLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 0] - thickness of layer N</li>
<li>layers[N, 1] - SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 2] - iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 3] - roughness between layer N-1/N</li>
<li>layers[-1, 1] - SLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 2] - iSLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 3] - roughness between backing and last layer</li>
</ul>
</dd>
<dt>scale: float</dt>
<dd>Multiply all reflectivities by this value.</dd>
<dt>bkg: float</dt>
<dd>Linear background to be added to all reflectivities</dd>
<dt>parallel: bool</dt>
<dd>Do you want to calculate in parallel? This option is only applicable if
you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is ignored if using
the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Reflectivity: np.ndarray</p>
<blockquote class="last">
<div><p>Calculated reflectivity values for each q value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.coefs_to_layer">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">coefs_to_layer</code><span class="sig-paren">(</span><em>coefs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#coefs_to_layer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.coefs_to_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts &#8216;coefs&#8217; format array to a &#8216;layer&#8217; format array .
The &#8216;layer&#8217; format is used by the <cite>abeles</cite> function, the &#8216;coefs&#8217; format
is used by the <cite>reflectivity</cite> function.
The &#8216;layer&#8217; format has N + 2 rows and 4 columns. Each row describes a
separate layer in the model. The 4 columns describe the thickness, SLD,
iSLD and roughness of each layer.
The &#8216;coefs&#8217; format is a vector description of the same information. A
vector form is required for fitting purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>coefs</strong> : np.ndarray</p>
<blockquote>
<div><ul class="simple">
<li>coefs[0] = number of layers, N</li>
<li>coefs[1] = scale factor</li>
<li>coefs[2] = SLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[3] = iSLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[4] = SLD of backing</li>
<li>coefs[5] = iSLD of backing</li>
<li>coefs[6] = background</li>
<li>coefs[7] = roughness between backing and layer N</li>
<li>coefs[4 * (N - 1) + 8] = thickness of layer N in Angstrom (layer 1 is</li>
<li>closest to fronting)</li>
<li>coefs[4 * (N - 1) + 9] = SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>coefs[4 * (N - 1) + 10] = iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>coefs[4 * (N - 1) + 11] = roughness between layer N and N-1.</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">layers: np.ndarray</p>
<blockquote class="last">
<div><p>Has shape (2 + N, 4), where N is the number of layers</p>
<ul class="simple">
<li>layers[0, 1] - SLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[0, 2] - iSLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 0] - thickness of layer N</li>
<li>layers[N, 1] - SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 2] - iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 3] - roughness between layer N-1/N</li>
<li>layers[-1, 1] - SLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 2] - iSLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 3] - roughness between backing and last layer</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.gauss_legendre">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">gauss_legendre</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#gauss_legendre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.gauss_legendre" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.is_proper_abeles_input">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">is_proper_abeles_input</code><span class="sig-paren">(</span><em>coefs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#is_proper_abeles_input"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.is_proper_abeles_input" title="Permalink to this definition">¶</a></dt>
<dd><p>Test to see if the coefs array is suitable input for the <cite>reflectivity</cite>
function</p>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.layer_to_coefs">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">layer_to_coefs</code><span class="sig-paren">(</span><em>layers</em>, <em>scale=1</em>, <em>bkg=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#layer_to_coefs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.layer_to_coefs" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts &#8216;layer&#8217; format array to a &#8216;coefs&#8217; format array .
The &#8216;layer&#8217; format is used by the <cite>abeles</cite> function, the &#8216;coefs&#8217; format
is used by the <cite>reflectivity</cite> function.
The &#8216;layer&#8217; format has N + 2 rows and 4 columns. Each row describes a
separate layer in the model. The 4 columns describe the thickness, SLD,
iSLD and roughness of each layer.
The &#8216;coefs&#8217; format is a vector description of the same information. A
vector form is required for fitting purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>layers: np.ndarray</strong></p>
<blockquote>
<div><p>Has shape (2 + N, 4), where N is the number of layers.</p>
<ul class="simple">
<li>layers[0, 1] - SLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[0, 2] - iSLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 0] - thickness of layer N</li>
<li>layers[N, 1] - SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 2] - iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 3] - roughness between layer N-1/N</li>
<li>layers[-1, 1] - SLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 2] - iSLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 3] - roughness between backing and last layer</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>coefs</strong> : np.ndarray</p>
<blockquote class="last">
<div><ul class="simple">
<li>coefs[0] = number of layers, N</li>
<li>coefs[1] = scale factor</li>
<li>coefs[2] = SLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[3] = iSLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[4] = SLD of backing</li>
<li>coefs[5] = iSLD of backing</li>
<li>coefs[6] = background</li>
<li>coefs[7] = roughness between backing and layer N</li>
<li>coefs[4 * (N - 1) + 8] = thickness of layer N in Angstrom (layer 1 is</li>
</ul>
<p>closest to fronting)
* coefs[4 * (N - 1) + 9] = SLD of layer N (/ 1e-6 Angstrom**-2)
* coefs[4 * (N - 1) + 10] = iSLD of layer N (/ 1e-6 Angstrom**-2)
* coefs[4 * (N - 1) + 11] = roughness between layer N and N-1.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.reflectivity">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">reflectivity</code><span class="sig-paren">(</span><em>q</em>, <em>coefs</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#reflectivity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.reflectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Abeles matrix formalism for calculating reflectivity from a stratified
medium.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q</strong> : np.ndarray</p>
<blockquote>
<div><p>The qvalues required for the calculation. Q=4*Pi/lambda * sin(omega).
Units = Angstrom**-1</p>
</div></blockquote>
<p><strong>coefs</strong> : np.ndarray</p>
<blockquote>
<div><ul class="simple">
<li>coefs[0] = number of layers, N</li>
<li>coefs[1] = scale factor</li>
<li>coefs[2] = SLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[3] = iSLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[4] = SLD of backing</li>
<li>coefs[5] = iSLD of backing</li>
<li>coefs[6] = background</li>
<li>coefs[7] = roughness between backing and layer N</li>
<li>coefs[4 * (N - 1) + 8] = thickness of layer N in Angstrom (layer 1 is</li>
</ul>
<p>closest to fronting)
* coefs[4 * (N - 1) + 9] = SLD of layer N (/ 1e-6 Angstrom**-2)
* coefs[4 * (N - 1) + 10] = iSLD of layer N (/ 1e-6 Angstrom**-2)
* coefs[4 * (N - 1) + 11] = roughness between layer N and N-1.</p>
</div></blockquote>
<p><strong>kwds</strong> : dict, optional</p>
<blockquote class="last">
<div><p>The following keys are used:</p>
<dl class="docutils">
<dt>&#8216;dqvals&#8217; - float or np.ndarray, optional</dt>
<dd><p class="first last">If dqvals is a float, then a constant dQ/Q resolution smearing is
employed.  For 5% resolution smearing supply 5.
If <cite>dqvals</cite> is the same shape as q, then the array contains the
FWHM of a Gaussian approximated resolution kernel. Point by point
resolution smearing is employed.  Use this option if dQ/Q varies
across your dataset.
If <cite>dqvals.ndim == q.ndim + 2</cite> and
<cite>q.shape == dqvals[..., -3].shape</cite> then an individual resolution
kernel is applied to each measurement point.  This resolution kernel
is a probability distribution function (PDF). <cite>dqvals</cite> will have the
shape (qvals.shape, M, 2).  There are <cite>M</cite> points in the kernel.
<cite>dqvals[..., 0]</cite> holds the q values for the kernel, <cite>dqvals[..., 1]</cite>
gives the corresponding probability.</p>
</dd>
<dt>&#8216;quad_order&#8217; - int, optional</dt>
<dd><p class="first last">the order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For example,
13 points may be fine for a thin layer, but will be atrocious at
describing a multilayer with bragg peaks.</p>
</dd>
<dt>&#8216;parallel&#8217;: bool, optional</dt>
<dd><p class="first last">Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>. The
default is <cite>True</cite>.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflect.sld_profile">
<code class="descclassname">refnx.analysis.reflect.</code><code class="descname">sld_profile</code><span class="sig-paren">(</span><em>z</em>, <em>coefs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#sld_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflect.sld_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates an SLD profile, as a function of distance through the
interface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z</strong> : float</p>
<blockquote>
<div><p>Interfacial distance (Angstrom) measured from interface between the
fronting medium and the first layer.</p>
</div></blockquote>
<p><strong>coefs</strong> : np.ndarray</p>
<blockquote>
<div><p>The reflectivity model parameters in &#8216;layer&#8217; form. (See
<cite>reflectivity</cite>)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sld</strong> : float</p>
<blockquote class="last">
<div><p>Scattering length density / 1e-6 $AA^-2$</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This can be called in vectorised fashion.</p>
</dd></dl>

</div>
<div class="section" id="module-refnx.analysis">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-refnx.analysis" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="refnx.analysis.CurveFitter">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">CurveFitter</code><span class="sig-paren">(</span><em>fitfunc</em>, <em>data</em>, <em>params</em>, <em>mask=None</em>, <em>fcn_args=()</em>, <em>fcn_kws=None</em>, <em>kws=None</em>, <em>callback=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.CurveFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">lmfit.minimizer.Minimizer</span></code></p>
<p>A curvefitting class that extends <cite>lmfit.Minimize</cite></p>
<dl class="docutils">
<dt>fitfunc <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd>Function calculating the generative model for the fit.  Should have
the signature: <code class="docutils literal"><span class="pre">fitfunc(x,</span> <span class="pre">params,</span> <span class="pre">*fcn_args,</span> <span class="pre">**fcn_kws)</span></code>. You
can also supply a <code class="docutils literal"><span class="pre">FitFunction</span></code> instance.</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">sequence, refnx.dataset.Data1D instance, str or file-like object</span></dt>
<dd><p class="first">A sequence containing the data to be analysed.
If <cite>data</cite> is a sequence then:</p>
<blockquote>
<div><ul>
<li><p class="first">data[0] - the independent variable (x-data)</p>
</li>
<li><p class="first">data[1] - the dependent (observed) variable (y-data)</p>
</li>
<li><dl class="first docutils">
<dt>data[2] - measured uncertainty in the dependent variable, expressed</dt>
<dd><p class="first last">as a standard deviation.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Only data[0] and data[1] are required, data[2] is optional. If data[2]
is not specified then the measured uncertainty is set to unity.</p>
<p class="last"><cite>data</cite> can also be a Data1D instance containing the data.
If <cite>data</cite> is a string, or file-like object then the string or file-like
object refers to a file containing the data. The data will be loaded
through the <cite>refnx.dataset.Data1D</cite> constructor.</p>
</dd>
<dt>params <span class="classifier-delimiter">:</span> <span class="classifier">lmfit.Parameters instance</span></dt>
<dd>Specifies the parameter set for the fit</dd>
<dt>mask <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, optional</span></dt>
<dd>A boolean array with the same shape as <cite>y</cite>.  If <cite>mask is True</cite>
then that point is excluded from the residuals calculation.</dd>
<dt>fcn_args <span class="classifier-delimiter">:</span> <span class="classifier">tuple, optional</span></dt>
<dd>Extra parameters required to fully specify fitfunc.</dd>
<dt>fcn_kws <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd>Extra keyword parameters needed to fully specify fitfunc.</dd>
<dt>minimizer_kwds <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd>Keywords passed to the minimizer.</dd>
<dt>callback <span class="classifier-delimiter">:</span> <span class="classifier">callable, optional</span></dt>
<dd>A function called at each minimization step. Has the signature:
<code class="docutils literal"><span class="pre">callback(params,</span> <span class="pre">iter,</span> <span class="pre">resid,</span> <span class="pre">*args,</span> <span class="pre">**kwds)</span></code></dd>
</dl>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="attribute">
<dt id="refnx.analysis.CurveFitter.data">
<code class="descname">data</code><a class="headerlink" href="#refnx.analysis.CurveFitter.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The unmasked data, and the mask</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>(x, y, e, mask)</strong> : data tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.CurveFitter.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>method='leastsq'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.CurveFitter.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fits the dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : str, optional</p>
<blockquote>
<div><p>Name of the fitting method to use.
One of:</p>
<ul class="simple">
<li>&#8216;leastsq&#8217;                -    Levenberg-Marquardt (default)</li>
<li>&#8216;nelder&#8217;                 -    Nelder-Mead</li>
<li>&#8216;lbfgsb&#8217;                 -    L-BFGS-B</li>
<li>&#8216;powell&#8217;                 -    Powell</li>
<li>&#8216;cg&#8217;                     -    Conjugate-Gradient</li>
<li>&#8216;newton&#8217;                 -    Newton-CG</li>
<li>&#8216;cobyla&#8217;                 -    Cobyla</li>
<li>&#8216;tnc&#8217;                    -    Truncate Newton</li>
<li>&#8216;trust-ncg&#8217;              -    Trust Newton-CGn</li>
<li>&#8216;dogleg&#8217;                 -    Dogleg</li>
<li>&#8216;slsqp&#8217;                  -    Sequential Linear Squares Programming</li>
<li>&#8216;differential_evolution&#8217; -    differential evolution</li>
</ul>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : lmfit.MinimizerResult</p>
<blockquote class="last">
<div><p>Result object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.CurveFitter.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.CurveFitter.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the model. This is a convenience method. Over-riding it will
not change a fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters instance</p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>model</strong> : array_like</p>
<blockquote class="last">
<div><p>The model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.CurveFitter.residuals">
<code class="descname">residuals</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#CurveFitter.residuals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.CurveFitter.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the difference between the data and the model. Also known as
the objective function. This is a convenience method. Over-riding it
will not change a fit.</p>
<p><span class="math">\(residuals = (fitfunc - y) / edata\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters instance</p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>residuals</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The difference between the data and the model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.Data1D">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">Data1D</code><span class="sig-paren">(</span><em>data=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/dataset/data1d.html#Data1D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Data1D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>A basic representation of a 1D dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : str, file-like or tuple of np.ndarray, optional</p>
<blockquote class="last">
<div><p><cite>data</cite> can be a string or file-like object referring to a File to load
the dataset from.</p>
<p>Alternatively it is a tuple containing the data from which the dataset
will be constructed. The tuple should have between 2 and 4 members.</p>
<blockquote>
<div><p>data[0] - x
data[1] - y
data[2] - standard deviation of y, y_sd
data[3] - standard deviation of x, x_sd</p>
</div></blockquote>
<p><cite>data</cite> must be at least two long, <cite>x</cite> and <cite>y</cite>.
If the tuple is at least 3 long then the third member is <cite>y_sd</cite>.
If the tuple is 4 long then the fourth member is <cite>x_sd</cite>.
All arrays must have the same shape.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="94%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>x</td>
<td>(np.ndarray) x data</td>
</tr>
<tr class="row-even"><td>y</td>
<td>(np.ndarray) y data</td>
</tr>
<tr class="row-odd"><td>y_sd</td>
<td>(np.ndarray) uncertainties (1 standard deviation) on the y data</td>
</tr>
<tr class="row-even"><td>x_sd</td>
<td>(np.ndarray) uncertainties on the x data</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="refnx.analysis.Data1D.add_data">
<code class="descname">add_data</code><span class="sig-paren">(</span><em>data_tuple</em>, <em>requires_splice=False</em>, <em>trim_trailing=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/dataset/data1d.html#Data1D.add_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Data1D.add_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds more data to the dataset</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data_tuple</strong> : tuple</p>
<blockquote>
<div><p>2 to 4 member tuple containing the (x, y, y_sd, x_sd) data to add
to the dataset. <cite>y_sd</cite> and <cite>x_sd</cite> are optional.</p>
</div></blockquote>
<p><strong>requires_splice</strong> : bool, optional</p>
<blockquote>
<div><p>When the new data is added to the dataset do you want to scale it
vertically so that it overlaps with the existing data? <cite>y</cite> and
<cite>y_sd</cite> in <cite>data_tuple</cite> are both multiplied by the scaling factor.</p>
</div></blockquote>
<p><strong>trim_trailing</strong> : bool, optional</p>
<blockquote class="last">
<div><p>When the new data is concatenated do you want to remove points from
the existing data that are in the overlap region? This might be
done because the datapoints in the <cite>data_tuple</cite> you are adding have
have lower <cite>y_sd</cite> than the preceding data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="refnx.analysis.Data1D.data">
<code class="descname">data</code><a class="headerlink" href="#refnx.analysis.Data1D.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The data contained within this object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>data_tuple</strong> : tuple</p>
<blockquote class="last">
<div><p>4-tuple containing the (x, y, y_sd, x_sd) data</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="refnx.analysis.Data1D.finite_data">
<code class="descname">finite_data</code><a class="headerlink" href="#refnx.analysis.Data1D.finite_data" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dataTuple</strong> : tuple</p>
<blockquote class="last">
<div><p>4-tuple containing the (x, y, y_sd, x_sd) datapoints that are
finite.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Data1D.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/dataset/data1d.html#Data1D.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Data1D.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a dataset from file. Must be 2 to 4 column ASCII.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f</strong> : file-handle or string</p>
<blockquote class="last">
<div><p>File to load the dataset from.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="refnx.analysis.Data1D.npoints">
<code class="descname">npoints</code><a class="headerlink" href="#refnx.analysis.Data1D.npoints" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of points in the dataset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>npoints</strong> : int</p>
<blockquote class="last">
<div><p>How many points in the dataset</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Data1D.refresh">
<code class="descname">refresh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/dataset/data1d.html#Data1D.refresh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Data1D.refresh" title="Permalink to this definition">¶</a></dt>
<dd><p>Refreshes a previously loaded dataset.</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Data1D.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/dataset/data1d.html#Data1D.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Data1D.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the data to file. Saves the data as 4 column ASCII.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f</strong> : file-handle or string</p>
<blockquote class="last">
<div><p>File to save the dataset to.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Data1D.save_fit">
<code class="descname">save_fit</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/dataset/data1d.html#Data1D.save_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Data1D.save_fit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="refnx.analysis.Data1D.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>scalefactor=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/dataset/data1d.html#Data1D.scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Data1D.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scales the y and y_sd data by dividing by <cite>scalefactor</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>scalefactor</strong> : float</p>
<blockquote class="last">
<div><p>The scalefactor to divide by.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Data1D.sort">
<code class="descname">sort</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/dataset/data1d.html#Data1D.sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Data1D.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the data in ascending order</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.FitFunction">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">FitFunction</code><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.FitFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>An abstract FitFunction class.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="refnx.analysis.FitFunction.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>x</em>, <em>params</em>, <em>*args</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.FitFunction.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the predictive model for the fit.
Override this method in your own fitfunction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like</p>
<blockquote>
<div><p>The independent variable for the fit</p>
</div></blockquote>
<p><strong>params</strong> : lmfit.Parameters</p>
<blockquote>
<div><p>The model parameters</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>predictive</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The predictive model for the fitfunction.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p><cite>args</cite> and <cite>kws</cite> can be used to fully specify the fit function.
Normally you would supply these via when the <strong>FitFunction</strong> object is
constructed.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="refnx.analysis.FitFunction.parameter_names">
<em class="property">static </em><code class="descname">parameter_names</code><span class="sig-paren">(</span><em>nparams=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#FitFunction.parameter_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.FitFunction.parameter_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a set of names for constructing an <cite>lmfit.Parameters</cite> instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nparams: int, optional</strong></p>
<blockquote>
<div><p>&gt;= 0 - provide a set of names with length <cite>nparams</cite></p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>&#8212;&#8212;-</strong></p>
<p><strong>names: list</strong></p>
<blockquote class="last">
<div><p>names for the lmfit.Parameters instance</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.GlobalFitter">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">GlobalFitter</code><span class="sig-paren">(</span><em>fitters</em>, <em>constraints=()</em>, <em>kws=None</em>, <em>callback=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.GlobalFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#refnx.analysis.curvefitter.CurveFitter" title="refnx.analysis.curvefitter.CurveFitter"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.curvefitter.CurveFitter</span></code></a></p>
<p>Simultaneous curvefitting of multiple datasets</p>
<dl class="docutils">
<dt>fitters: sequence of CurveFitter instances</dt>
<dd>Contains all the fitters and fitfunctions for the global fit.</dd>
<dt>constraints: str sequence, optional</dt>
<dd>Of the type &#8216;dN:param_name = constraint&#8217;. Sets a constraint
expression for the parameter <cite>param_name</cite> in dataset N. The
constraint &#8216;d2:scale = 2 * d0:back&#8217; constrains the <cite>scale</cite>
parameter in dataset 2 to be twice the <cite>back</cite> parameter in
dataset 0.
<strong>Important</strong> For a parameter (<cite>d2:scale</cite> in this example) to be
constrained by this mechanism it must not have any pre-existing
constraints within its individual fitter. If there are pre-existing
constraints then those are honoured, and constraints specified here are
ignored.</dd>
<dt>kws: dict, optional</dt>
<dd>Extra minimization keywords to be passed to the minimizer of choice.</dd>
<dt>callback: callable, optional</dt>
<dd>Function called at each step of the minimization. Has the signature
<code class="docutils literal"><span class="pre">callback(params,</span> <span class="pre">iter,</span> <span class="pre">resid)</span></code></dd>
</dl>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="refnx.analysis.GlobalFitter.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.GlobalFitter.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the model. This method is provided for convenience purposes
and is not used during a fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params: lmfit.Parameters</strong></p>
<blockquote>
<div><p>Specifies the entire parameter set, across all the datasets</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>model</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.GlobalFitter.residuals">
<code class="descname">residuals</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#GlobalFitter.residuals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.GlobalFitter.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the difference between the data and the model. Also known as
the objective function.  This is a convenience method. Over-riding it
does not change the fitting process.
residuals = (fitfunc - y) / edata</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params: lmfit.Parameters</strong></p>
<blockquote>
<div><p>Specifies the entire parameter set</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>residuals</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The difference between the data and the model.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.Minimizer">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">Minimizer</code><span class="sig-paren">(</span><em>userfcn</em>, <em>params</em>, <em>fcn_args=None</em>, <em>fcn_kws=None</em>, <em>iter_cb=None</em>, <em>scale_covar=True</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/minimizer.html#Minimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Minimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>A general minimizer for curve fitting</p>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="refnx.analysis.Minimizer.emcee">
<code class="descname">emcee</code><span class="sig-paren">(</span><em>params=None</em>, <em>steps=1000</em>, <em>nwalkers=100</em>, <em>burn=0</em>, <em>thin=1</em>, <em>ntemps=1</em>, <em>pos=None</em>, <em>reuse_sampler=False</em>, <em>workers=1</em>, <em>float_behavior='posterior'</em>, <em>is_weighted=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/minimizer.html#Minimizer.emcee"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Minimizer.emcee" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Bayesian sampling of the posterior distribution for the parameters
using the <cite>emcee</cite> Markov Chain Monte Carlo package. The method assumes
that the prior is Uniform. You need to have <cite>emcee</cite> installed to use
this method.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : lmfit.Parameters, optional</p>
<blockquote>
<div><blockquote>
<div><p>Parameters to use as starting point. If this is not specified
then the Parameters used to initialise the Minimizer object are
used.</p>
</div></blockquote>
<dl class="docutils">
<dt>steps <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">How many samples you would like to draw from the posterior
distribution for each of the walkers?</p>
</dd>
<dt>nwalkers <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Should be set so <span class="math">\(nwalkers &gt;&gt; nvarys\)</span>, where <cite>nvarys</cite> are
the number of parameters being varied during the fit.
&#8220;Walkers are the members of the ensemble. They are almost like
separate Metropolis-Hastings chains but, of course, the proposal
distribution for a given walker depends on the positions of all
the other walkers in the ensemble.&#8221; - from the <cite>emcee</cite> webpage.</p>
</dd>
<dt>burn <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Discard this many samples from the start of the sampling regime.</p>
</dd>
<dt>thin <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Only accept 1 in every <cite>thin</cite> samples.</p>
</dd>
<dt>ntemps <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">If <cite>ntemps &gt; 1</cite> perform a Parallel Tempering.</p>
</dd>
<dt>pos <span class="classifier-delimiter">:</span> <span class="classifier">np.ndarray, optional</span></dt>
<dd><p class="first last">Specify the initial positions for the sampler.  If <cite>ntemps == 1</cite>
then <cite>pos.shape</cite> should be <cite>(nwalkers, nvarys)</cite>. Otherwise,
<cite>(ntemps, nwalkers, nvarys)</cite>. You can also initialise using a
previous chain that had the same <cite>ntemps</cite>, <cite>nwalkers</cite> and
<cite>nvarys</cite>. Note that <cite>nvarys</cite> may be one larger than you expect it
to be if your <cite>userfcn</cite> returns an array and <cite>is_weighted is
False</cite>.</p>
</dd>
<dt>reuse_sampler <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">If you have already run <cite>emcee</cite> on a given <cite>Minimizer</cite> object then
it possesses an internal <code class="docutils literal"><span class="pre">sampler</span></code> attribute. You can continue to
draw from the same sampler (retaining the chain history) if you set
this option to <cite>True</cite>. Otherwise a new sampler is created. The
<cite>nwalkers</cite>, <cite>ntemps</cite>, <cite>pos</cite>, and <cite>params</cite> keywords are ignored with
this option.
<strong>Important</strong>: the Parameters used to create the sampler must not
change in-between calls to <cite>emcee</cite>. Alteration of Parameters
would include changed <code class="docutils literal"><span class="pre">min</span></code>, <code class="docutils literal"><span class="pre">max</span></code>, <code class="docutils literal"><span class="pre">vary</span></code> and <code class="docutils literal"><span class="pre">expr</span></code>
attributes. This may happen, for example, if you use an altered
Parameters object and call the <cite>minimize</cite> method in-between calls
to <cite>emcee</cite>.</p>
</dd>
<dt>workers <span class="classifier-delimiter">:</span> <span class="classifier">Pool-like or int, optional</span></dt>
<dd><p class="first last">For parallelization of sampling.  It can be any Pool-like object
with a map method that follows the same calling sequence as the
built-in <cite>map</cite> function. If int is given as the argument, then a
multiprocessing-based pool is spawned internally with the
corresponding number of parallel processes. &#8216;mpi4py&#8217;-based
parallelization and &#8216;joblib&#8217;-based parallelization pools can also
be used here. <strong>Note</strong>: because of multiprocessing overhead it may
only be worth parallelising if the objective function is expensive
to calculate, or if there are a large number of objective
evaluations per step (<cite>ntemps * nwalkers * nvarys</cite>).</p>
</dd>
<dt>float_behavior <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first">Specifies meaning of the objective function output if it returns a
float. One of:</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;posterior&#8217; - objective function returns a log-posterior</dt>
<dd><p class="first last">probability</p>
</dd>
</dl>
<p>&#8216;chi2&#8217; - objective function returns <span class="math">\(\chi^2\)</span>.</p>
</div></blockquote>
<p class="last">See Notes for further details.</p>
</dd>
<dt>is_weighted <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Has your objective function been weighted by measurement
uncertainties? If <cite>is_weighted is True</cite> then your objective
function is assumed to return residuals that have been divided by
the true measurement uncertainty <cite>(data - model) / sigma</cite>. If
<cite>is_weighted is False</cite> then the objective function is assumed to
return unweighted residuals, <cite>data - model</cite>. In this case <cite>emcee</cite>
will employ a positive measurement uncertainty during the sampling.
This measurement uncertainty will be present in the output params
and output chain with the name <cite>__lnsigma</cite>. A side effect of this
is that you cannot use this parameter name yourself.
<strong>Important</strong> this parameter only has any effect if your objective
function returns an array. If your objective function returns a
float, then this parameter is ignored. See Notes for more details.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : MinimizerResult</p>
<blockquote class="last">
<div><p>MinimizerResult object containing updated params, statistics,
etc. The <cite>MinimizerResult</cite> also contains the <code class="docutils literal"><span class="pre">chain</span></code>,
<code class="docutils literal"><span class="pre">flatchain</span></code> and <code class="docutils literal"><span class="pre">lnprob</span></code> attributes. The <code class="docutils literal"><span class="pre">chain</span></code>
and <code class="docutils literal"><span class="pre">flatchain</span></code> attributes contain the samples and have the shape
<cite>(nwalkers, (steps - burn) // thin, nvarys)</cite> or
<cite>(ntemps, nwalkers, (steps - burn) // thin, nvarys)</cite>,
depending on whether Parallel tempering was used or not.
<cite>nvarys</cite> is the number of parameters that are allowed to vary.
The <code class="docutils literal"><span class="pre">flatchain</span></code> attribute is a <cite>pandas.DataFrame</cite> of the
flattened chain, <cite>chain.reshape(-1, nvarys)</cite>. To access flattened
chain values for a particular parameter use
<cite>result.flatchain[parname]</cite>. The <code class="docutils literal"><span class="pre">lnprob</span></code> attribute contains the
log probability for each sample in <code class="docutils literal"><span class="pre">chain</span></code>. The sample with the
highest probability corresponds to the maximum likelihood estimate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>rac{1}{2}sum_n left[
rac{left(g_n(F_{true}) - D_n 
ight)^2}{s_n^2}+ln (2pi s_n^2)
ight]</p>
<blockquote>
<div><p>The first summand in the square brackets represents the residual for a
given datapoint (<span class="math">\(g\)</span> being the generative model) . This term
represents <span class="math">\(\chi^2\)</span> when summed over all datapoints.
Ideally the objective function used to create <cite>lmfit.Minimizer</cite> should
return the log-posterior probability, <span class="math">\(\ln p(F_{true} | D)\)</span>.
However, since the in-built log-prior term is zero, the objective
function can also just return the log-likelihood, unless you wish to
create a non-uniform prior.</p>
<p>If a float value is returned by the objective function then this value
is assumed by default to be the log-posterior probability, i.e.
<cite>float_behavior is &#8216;posterior&#8217;</cite>. If your objective function returns
<span class="math">\(\chi^2\)</span>, then you should use a value of <cite>&#8216;chi2&#8217;</cite> for
<cite>float_behavior</cite>. <cite>emcee</cite> will then multiply your <span class="math">\(\chi^2\)</span> value
by -0.5 to obtain the posterior probability.</p>
<p>However, the default behaviour of many objective functions is to return
a vector of (possibly weighted) residuals. Therefore, if your objective
function returns a vector, <cite>res</cite>, then the vector is assumed to contain
the residuals. If <cite>is_weighted is True</cite> then your residuals are assumed
to be correctly weighted by the standard deviation of the data points
(<cite>res = (data - model) / sigma</cite>) and the log-likelihood (and
log-posterior probability) is calculated as: <cite>-0.5 * np.sum(res **2)</cite>.
This ignores the second summand in the square brackets. Consequently,
in order to calculate a fully correct log-posterior probability value
your objective function should return a single value. If
<cite>is_weighted is False</cite> then the data uncertainty, <cite>s_n</cite>, will be
treated as a nuisance parameter and will be marginalised out. This is
achieved by employing a strictly positive uncertainty
(homoscedasticity) for each data point, <span class="math">\(s_n = exp(__lnsigma)\)</span>.
<cite>__lnsigma</cite> will be present in <cite>MinimizerResult.params</cite>, as well as
<cite>Minimizer.chain</cite>, <cite>nvarys</cite> will also be increased by one.</p>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="refnx.analysis.Minimizer.err_maxfev">
<code class="descname">err_maxfev</code><em class="property"> = &quot;Too many function calls (max set to %i)!  Use: minimize(func, params, ..., maxfev=NNN)or set leastsq_kws['maxfev']  to increase this maximum.&quot;</em><a class="headerlink" href="#refnx.analysis.Minimizer.err_maxfev" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="refnx.analysis.Minimizer.err_nonparam">
<code class="descname">err_nonparam</code><em class="property"> = 'params must be a minimizer.Parameters() instance or list of Parameters()'</em><a class="headerlink" href="#refnx.analysis.Minimizer.err_nonparam" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="refnx.analysis.Minimizer.fmin">
<code class="descname">fmin</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#refnx.analysis.Minimizer.fmin" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>fmin</cite> is deprecated!
Deprecated in lmfit 0.8.2, use scalar_minimize and method=&#8217;Nelder-Mead&#8217; instead</p>
<blockquote>
<div>Use Nelder-Mead (simplex) minimization</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kws</strong> : dict</p>
<blockquote class="last">
<div><p>Minimizer options to pass to the scipy.optimize.fmin minimizer.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Minimizer.lbfgsb">
<code class="descname">lbfgsb</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="headerlink" href="#refnx.analysis.Minimizer.lbfgsb" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>lbfgsb</cite> is deprecated!
Deprecated in lmfit 0.8.2, use scalar_minimize and method=&#8217;L-BFGS-B&#8217; instead</p>
<blockquote>
<div>Use l-bfgs-b minimization</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kws</strong> : dict</p>
<blockquote class="last">
<div><p>Minimizer options to pass to the
scipy.optimize.lbfgsb.fmin_l_bfgs_b function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Minimizer.leastsq">
<code class="descname">leastsq</code><span class="sig-paren">(</span><em>params=None</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/minimizer.html#Minimizer.leastsq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Minimizer.leastsq" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Levenberg-Marquardt minimization to perform a fit.
This assumes that ModelParameters have been stored, and a function to
minimize has been properly set up.</p>
<p>This wraps scipy.optimize.leastsq.</p>
<p>When possible, this calculates the estimated uncertainties and
variable correlations from the covariance matrix.</p>
<p>Writes outputs to many internal attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>params</strong> : Parameters, optional</p>
<blockquote>
<div><p>Parameters to use as starting points.</p>
</div></blockquote>
<p><strong>kws</strong> : dict, optional</p>
<blockquote>
<div><p>Minimizer options to pass to scipy.optimize.leastsq.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>success</strong> : bool</p>
<blockquote class="last">
<div><p>True if fit was successful, False if not.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Minimizer.minimize">
<code class="descname">minimize</code><span class="sig-paren">(</span><em>method='leastsq'</em>, <em>params=None</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/minimizer.html#Minimizer.minimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Minimizer.minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the minimization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : str, optional</p>
<blockquote>
<div><p>Name of the fitting method to use.
One of:
&#8216;leastsq&#8217;                -    Levenberg-Marquardt (default)
&#8216;nelder&#8217;                 -    Nelder-Mead
&#8216;lbfgsb&#8217;                 -    L-BFGS-B
&#8216;powell&#8217;                 -    Powell
&#8216;cg&#8217;                     -    Conjugate-Gradient
&#8216;newton&#8217;                 -    Newton-CG
&#8216;cobyla&#8217;                 -    Cobyla
&#8216;tnc&#8217;                    -    Truncate Newton
&#8216;trust-ncg&#8217;              -    Trust Newton-CGn
&#8216;dogleg&#8217;                 -    Dogleg
&#8216;slsqp&#8217;                  -    Sequential Linear Squares Programming
&#8216;differential_evolution&#8217; -    differential evolution</p>
</div></blockquote>
<p><strong>params</strong> : Parameters, optional</p>
<blockquote>
<div><p>parameters to use as starting values</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : MinimizerResult</p>
<blockquote class="last">
<div><p>MinimizerResult object contains updated params, fit statistics, etc.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Minimizer.penalty">
<code class="descname">penalty</code><span class="sig-paren">(</span><em>fvars</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/minimizer.html#Minimizer.penalty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Minimizer.penalty" title="Permalink to this definition">¶</a></dt>
<dd><p>Penalty function for scalar minimizers:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fvars</strong> : array of values for the variable parameters</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">r - float</p>
<blockquote class="last">
<div><p>The user evaluated user-supplied objective function. If the
objective function is an array, return the array sum-of-squares</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Minimizer.prepare_fit">
<code class="descname">prepare_fit</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/minimizer.html#Minimizer.prepare_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Minimizer.prepare_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares parameters for fitting,
return array of initial values</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Minimizer.scalar_minimize">
<code class="descname">scalar_minimize</code><span class="sig-paren">(</span><em>method='Nelder-Mead'</em>, <em>params=None</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/minimizer.html#Minimizer.scalar_minimize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Minimizer.scalar_minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Use one of the scalar minimization methods from
scipy.optimize.minimize.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : str, optional</p>
<blockquote>
<div><p>Name of the fitting method to use.
One of:</p>
<blockquote>
<div><p>&#8216;Nelder-Mead&#8217; (default)
&#8216;L-BFGS-B&#8217;
&#8216;Powell&#8217;
&#8216;CG&#8217;
&#8216;Newton-CG&#8217;
&#8216;COBYLA&#8217;
&#8216;TNC&#8217;
&#8216;trust-ncg&#8217;
&#8216;dogleg&#8217;
&#8216;SLSQP&#8217;
&#8216;differential_evolution&#8217;</p>
</div></blockquote>
</div></blockquote>
<p><strong>params</strong> : Parameters, optional</p>
<blockquote>
<div><p>Parameters to use as starting points.</p>
</div></blockquote>
<p><strong>kws</strong> : dict, optional</p>
<blockquote>
<div><p>Minimizer options pass to scipy.optimize.minimize.</p>
</div></blockquote>
<p><strong>If the objective function returns a numpy array instead</strong></p>
<p><strong>of the expected scalar, the sum of squares of the array</strong></p>
<p><strong>will be used.</strong></p>
<p><strong>Note that bounds and constraints can be set on Parameters</strong></p>
<p><strong>for any of these methods, so are not supported separately</strong></p>
<p><strong>for those designed to use bounds. However, if you use the</strong></p>
<p><strong>differential_evolution option you must specify finite</strong></p>
<p><strong>(min, max) for each Parameter.</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>success</strong> : bool</p>
<blockquote class="last">
<div><p>Whether the fit was successful.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Minimizer.unprepare_fit">
<code class="descname">unprepare_fit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/minimizer.html#Minimizer.unprepare_fit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Minimizer.unprepare_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Unprepares the fit, so that subsequent fits will be
forced to run prepare_fit.</p>
<p>removes ast compilations of constraint expressions</p>
</dd></dl>

<dl class="attribute">
<dt id="refnx.analysis.Minimizer.values">
<code class="descname">values</code><a class="headerlink" href="#refnx.analysis.Minimizer.values" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>param_values</strong> : dict</p>
<blockquote class="last">
<div><p>Parameter values in a simple dictionary.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.Parameters">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">Parameters</code><span class="sig-paren">(</span><em>asteval=None</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/parameter.html#Parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/collections.html#collections.OrderedDict" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">collections.OrderedDict</span></code></a></p>
<p>A dictionary of all the Parameters required to specify a fit model.</p>
<p>All keys must be strings, and valid Python symbol names, and all values
must be Parameters.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="refnx.analysis.Parameters.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>name</em>, <em>value=None</em>, <em>vary=True</em>, <em>min=None</em>, <em>max=None</em>, <em>expr=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/parameter.html#Parameters.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Parameters.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for adding a Parameter:</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Parameters.add_many">
<code class="descname">add_many</code><span class="sig-paren">(</span><em>*parlist</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/parameter.html#Parameters.add_many"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Parameters.add_many" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function for adding a list of Parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parlist</strong> : sequence</p>
<blockquote class="last">
<div><p>A sequence of tuples, or a sequence of <cite>Parameter</cite> instances. If it
is a sequence of tuples, then each tuple must contain at least the
name. The order in each tuple is the following:</p>
<blockquote>
<div><p>name, value, vary, min, max, expr</p>
</div></blockquote>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Parameters.dump">
<code class="descname">dump</code><span class="sig-paren">(</span><em>fp</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/parameter.html#Parameters.dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Parameters.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>write JSON representation of Parameters to a file
or file-like object (must have a <cite>write()</cite> method).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">return value from <cite>fp.write()</cite></td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#refnx.analysis.Parameters.dump" title="refnx.analysis.Parameters.dump"><code class="xref py py-obj docutils literal"><span class="pre">dump</span></code></a>, <a class="reference internal" href="#refnx.analysis.Parameters.load" title="refnx.analysis.Parameters.load"><code class="xref py py-obj docutils literal"><span class="pre">load</span></code></a>, <a class="reference external" href="https://docs.python.org/library/json.html#json.dump" title="(in Python v2.7)"><code class="xref py py-obj docutils literal"><span class="pre">json.dump</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Parameters.dumps">
<code class="descname">dumps</code><span class="sig-paren">(</span><em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/parameter.html#Parameters.dumps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Parameters.dumps" title="Permalink to this definition">¶</a></dt>
<dd><p>represent Parameters as a JSON string.</p>
<p>all keyword arguments are passed to <cite>json.dumps()</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">json string representation of Parameters</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#refnx.analysis.Parameters.dump" title="refnx.analysis.Parameters.dump"><code class="xref py py-obj docutils literal"><span class="pre">dump</span></code></a>, <a class="reference internal" href="#refnx.analysis.Parameters.loads" title="refnx.analysis.Parameters.loads"><code class="xref py py-obj docutils literal"><span class="pre">loads</span></code></a>, <a class="reference internal" href="#refnx.analysis.Parameters.load" title="refnx.analysis.Parameters.load"><code class="xref py py-obj docutils literal"><span class="pre">load</span></code></a>, <a class="reference external" href="https://docs.python.org/library/json.html#json.dumps" title="(in Python v2.7)"><code class="xref py py-obj docutils literal"><span class="pre">json.dumps</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Parameters.load">
<code class="descname">load</code><span class="sig-paren">(</span><em>fp</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/parameter.html#Parameters.load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Parameters.load" title="Permalink to this definition">¶</a></dt>
<dd><p>load JSON representation of Parameters from a file
or file-like object (must have a <cite>read()</cite> method).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None.   Parameters are updated as a side-effect</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#refnx.analysis.Parameters.dump" title="refnx.analysis.Parameters.dump"><code class="xref py py-obj docutils literal"><span class="pre">dump</span></code></a>, <a class="reference internal" href="#refnx.analysis.Parameters.loads" title="refnx.analysis.Parameters.loads"><code class="xref py py-obj docutils literal"><span class="pre">loads</span></code></a>, <a class="reference external" href="https://docs.python.org/library/json.html#json.load" title="(in Python v2.7)"><code class="xref py py-obj docutils literal"><span class="pre">json.load</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Parameters.loads">
<code class="descname">loads</code><span class="sig-paren">(</span><em>s</em>, <em>**kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/parameter.html#Parameters.loads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Parameters.loads" title="Permalink to this definition">¶</a></dt>
<dd><p>load Parameters from a JSON string.</p>
<p>current Parameters will be cleared before loading.</p>
<p>all keyword arguments are passed to <cite>json.loads()</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None.   Parameters are updated as a side-effect</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#refnx.analysis.Parameters.dump" title="refnx.analysis.Parameters.dump"><code class="xref py py-obj docutils literal"><span class="pre">dump</span></code></a>, <a class="reference internal" href="#refnx.analysis.Parameters.dumps" title="refnx.analysis.Parameters.dumps"><code class="xref py py-obj docutils literal"><span class="pre">dumps</span></code></a>, <a class="reference internal" href="#refnx.analysis.Parameters.load" title="refnx.analysis.Parameters.load"><code class="xref py py-obj docutils literal"><span class="pre">load</span></code></a>, <a class="reference external" href="https://docs.python.org/library/json.html#json.loads" title="(in Python v2.7)"><code class="xref py py-obj docutils literal"><span class="pre">json.loads</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Parameters.pretty_print">
<code class="descname">pretty_print</code><span class="sig-paren">(</span><em>oneline=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/parameter.html#Parameters.pretty_print"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Parameters.pretty_print" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="refnx.analysis.Parameters.pretty_repr">
<code class="descname">pretty_repr</code><span class="sig-paren">(</span><em>oneline=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/parameter.html#Parameters.pretty_repr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Parameters.pretty_repr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="refnx.analysis.Parameters.update_constraints">
<code class="descname">update_constraints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/parameter.html#Parameters.update_constraints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Parameters.update_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Update all constrained parameters, checking that dependencies are
evaluated as needed.</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.Parameters.valuesdict">
<code class="descname">valuesdict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lmfit/parameter.html#Parameters.valuesdict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Parameters.valuesdict" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An ordered dictionary of name:value pairs for each Parameter.</p>
<p>This is distinct from the Parameters itself, as it has values of</p>
<p class="last">the Parameter values, not the full Parameter object.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.ReflectivityFitFunction">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">ReflectivityFitFunction</code><span class="sig-paren">(</span><em>transform=None</em>, <em>dq=5.0</em>, <em>quad_order=17</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#refnx.analysis.curvefitter.FitFunction" title="refnx.analysis.curvefitter.FitFunction"><code class="xref py py-class docutils literal"><span class="pre">refnx.analysis.curvefitter.FitFunction</span></code></a></p>
<p>A sub class of <cite>refnx.analysis.curvefitter.FitFunction</cite> suited for
calculation of reflectometry profiles.</p>
<p>If you wish to fit analytic or freeform SLD profiles you should
inherit this class, overriding the <cite>model</cite> method.  If you do this
you should also override the <cite>sld_profile</cite> method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>transform</strong> : callable, optional</p>
<blockquote>
<div><p>If specified then this function is used to transform the data
returned by the model method. With the signature:
<code class="docutils literal"><span class="pre">transformed_y_vals</span> <span class="pre">=</span> <span class="pre">transform(x_vals,</span> <span class="pre">y_vals)</span></code>.</p>
</div></blockquote>
<p><strong>dq</strong> : float, optional</p>
<blockquote>
<div><p>Default dq/q resolution (as a percentage).</p>
</div></blockquote>
<p><strong>quad_order</strong> : int or str, optional</p>
<blockquote>
<div><p>The order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For
example 13 points may be fine for a thin layer, but will be
atrocious at describing a multilayer with Bragg peaks.</p>
</div></blockquote>
<p><strong>parallel: bool, optional</strong></p>
<blockquote class="last">
<div><p>Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="refnx.analysis.ReflectivityFitFunction.callback">
<code class="descname">callback</code><span class="sig-paren">(</span><em>parameters</em>, <em>iteration</em>, <em>resid</em>, <em>*fcn_args</em>, <em>**fcn_kws</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction.callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="refnx.analysis.ReflectivityFitFunction.model">
<code class="descname">model</code><span class="sig-paren">(</span><em>x</em>, <em>parameters</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the theoretical model, given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x</strong> : array-like</p>
<blockquote>
<div><p>Q values to evaluate the reflectivity at</p>
</div></blockquote>
<p><strong>parameters</strong> : lmfit.Parameters instance</p>
<blockquote>
<div><p>Contains the parameters that are required for reflectivity
calculation.</p>
</div></blockquote>
<p><strong>kwds[&#8216;dqvals&#8217;] - float or np.ndarray, optional</strong></p>
<blockquote>
<div><p>If dqvals is a float, then a constant dQ/Q resolution smearing is
employed.  For 5% resolution smearing supply 5.
If <cite>dqvals</cite> is the same shape as q, then the array contains the
FWHM of a Gaussian approximated resolution kernel. Point by point
resolution smearing is employed.  Use this option if dQ/Q varies
across your dataset.
If <cite>dqvals.ndim == q.ndim + 2</cite> and
<cite>q.shape == dqvals[..., -3].shape</cite> then an individual resolution
kernel is applied to each measurement point.  This resolution kernel
is a probability distribution function (PDF). <cite>dqvals</cite> will have the
shape (qvals.shape, M, 2).  There are <cite>M</cite> points in the kernel.
<cite>dqvals[..., 0]</cite> holds the q values for the kernel, <cite>dqvals[..., 1]</cite>
gives the corresponding probability.</p>
</div></blockquote>
<p><strong>kwds[&#8216;quad_order&#8217;] - int, optional</strong></p>
<blockquote>
<div><p>the order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For example,
13 points may be fine for a thin layer, but will be atrocious at
describing a multilayer with bragg peaks.</p>
</div></blockquote>
<p><strong>kwds[&#8216;parallel&#8217;]: bool, optional</strong></p>
<blockquote>
<div><p>Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>. The
default is <cite>True</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>yvals</strong> : np.ndarray</p>
<blockquote class="last">
<div><p>The theoretical model for the x, i.e.
reflectivity(x, parameters, <a href="#id5"><span class="problematic" id="id6">*</span></a>args, <a href="#id7"><span class="problematic" id="id8">**</span></a>kwds)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="refnx.analysis.ReflectivityFitFunction.parameter_names">
<em class="property">static </em><code class="descname">parameter_names</code><span class="sig-paren">(</span><em>nparams=8</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.parameter_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction.parameter_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameter names for a default reflectivity calculation</p>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.ReflectivityFitFunction.set_dq">
<code class="descname">set_dq</code><span class="sig-paren">(</span><em>dq</em>, <em>quad_order=17</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.set_dq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction.set_dq" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the resolution information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dq: None, float or np.ndarray</strong></p>
<blockquote>
<div><p>If <cite>None</cite> then there is no resolution smearing.
If a float, e.g. 5, then dq/q smearing of 5% is applied. If dq==0
then resolution smearing is removed.
If an np.ndarray the same length as y, it contains the FWHM of
the Gaussian approximated resolution kernel.</p>
</div></blockquote>
<p><strong>quad_order: int or &#8216;ultimate&#8217;</strong></p>
<blockquote class="last">
<div><p>The order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For
example 13 points may be fine for a thin layer, but will be
atrocious at describing a multilayer with Bragg peaks.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="refnx.analysis.ReflectivityFitFunction.sld_profile">
<code class="descname">sld_profile</code><span class="sig-paren">(</span><em>parameters</em>, <em>points=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#ReflectivityFitFunction.sld_profile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.ReflectivityFitFunction.sld_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the SLD profile corresponding to the model parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parameters</strong> : lmfit.parameters.Parameters instance</p>
<p><strong>points</strong> : array-like</p>
<blockquote>
<div><p>The points to evaluate the SLD profile at.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>(z, rho_z)</strong> : tuple of np.ndarrays</p>
<blockquote class="last">
<div><p>The distance from the top interface and the SLD at that point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="refnx.analysis.Transform">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">Transform</code><span class="sig-paren">(</span><em>form</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#Transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="refnx.analysis.Transform.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>xdata</em>, <em>ydata</em>, <em>edata=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#Transform.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.Transform.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>An irreversible transform from lin R vs Q, to some other form
form - specifies the transform</p>
<blockquote>
<div>form = None - no transform is made.
form = &#8216;logY&#8217; - log transform
form = &#8216;YX4&#8217; - YX**4 transform
form = &#8216;YX2&#8217; - YX**2 transform</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="refnx.analysis.abeles">
<code class="descclassname">refnx.analysis.</code><code class="descname">abeles</code><span class="sig-paren">(</span><em>q</em>, <em>layers</em>, <em>scale=1</em>, <em>bkg=0.0</em>, <em>parallel=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#abeles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.abeles" title="Permalink to this definition">¶</a></dt>
<dd><p>Abeles matrix formalism for calculating reflectivity from a stratified
medium.
Parameters
&#8212;&#8212;&#8212;-
q: array_like</p>
<blockquote>
<div>the q values required for the calculation.
Q = 4 * Pi / lambda * sin(omega).
Units = Angstrom**-1</div></blockquote>
<dl class="docutils">
<dt>layers: np.ndarray</dt>
<dd><p class="first">coefficients required for the calculation, has shape (2 + N, 4),
where N is the number of layers</p>
<ul class="last simple">
<li>layers[0, 1] - SLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[0, 2] - iSLD of fronting (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 0] - thickness of layer N</li>
<li>layers[N, 1] - SLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 2] - iSLD of layer N (/ 1e-6 Angstrom**-2)</li>
<li>layers[N, 3] - roughness between layer N-1/N</li>
<li>layers[-1, 1] - SLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 2] - iSLD of backing (/ 1e-6 Angstrom**-2)</li>
<li>layers[-1, 3] - roughness between backing and last layer</li>
</ul>
</dd>
<dt>scale: float</dt>
<dd>Multiply all reflectivities by this value.</dd>
<dt>bkg: float</dt>
<dd>Linear background to be added to all reflectivities</dd>
<dt>parallel: bool</dt>
<dd>Do you want to calculate in parallel? This option is only applicable if
you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is ignored if using
the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Reflectivity: np.ndarray</p>
<blockquote class="last">
<div><p>Calculated reflectivity values for each q value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.bounds">
<code class="descclassname">refnx.analysis.</code><code class="descname">bounds</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.clear_bounds">
<code class="descclassname">refnx.analysis.</code><code class="descname">clear_bounds</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#clear_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.clear_bounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="refnx.analysis.exprs">
<code class="descclassname">refnx.analysis.</code><code class="descname">exprs</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#exprs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.exprs" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and returns
the the constraint expressions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parameters</strong> : lmfit.Parameters</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>exprs</strong> : list of str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.fitfunc">
<code class="descclassname">refnx.analysis.</code><code class="descname">fitfunc</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#fitfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.fitfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that can be used to say if something is a fitfunc.</p>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.names">
<code class="descclassname">refnx.analysis.</code><code class="descname">names</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="refnx.analysis.partial">
<em class="property">class </em><code class="descclassname">refnx.analysis.</code><code class="descname">partial</code><a class="reference internal" href="_modules/functools.html#partial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.partial" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>partial(func, <a href="#id9"><span class="problematic" id="id10">*</span></a>args, <a href="#id11"><span class="problematic" id="id12">**</span></a>keywords) - new function with partial application
of the given arguments and keywords.</p>
<p class="rubric">Methods</p>
<dl class="attribute">
<dt id="refnx.analysis.partial.args">
<code class="descname">args</code><a class="headerlink" href="#refnx.analysis.partial.args" title="Permalink to this definition">¶</a></dt>
<dd><p>tuple of arguments to future partial calls</p>
</dd></dl>

<dl class="attribute">
<dt id="refnx.analysis.partial.func">
<code class="descname">func</code><a class="headerlink" href="#refnx.analysis.partial.func" title="Permalink to this definition">¶</a></dt>
<dd><p>function object to use in future partial calls</p>
</dd></dl>

<dl class="attribute">
<dt id="refnx.analysis.partial.keywords">
<code class="descname">keywords</code><a class="headerlink" href="#refnx.analysis.partial.keywords" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionary of keyword arguments to future partial calls</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="refnx.analysis.reflectivity">
<code class="descclassname">refnx.analysis.</code><code class="descname">reflectivity</code><span class="sig-paren">(</span><em>q</em>, <em>coefs</em>, <em>*args</em>, <em>**kwds</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/reflect.html#reflectivity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.reflectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Abeles matrix formalism for calculating reflectivity from a stratified
medium.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q</strong> : np.ndarray</p>
<blockquote>
<div><p>The qvalues required for the calculation. Q=4*Pi/lambda * sin(omega).
Units = Angstrom**-1</p>
</div></blockquote>
<p><strong>coefs</strong> : np.ndarray</p>
<blockquote>
<div><ul class="simple">
<li>coefs[0] = number of layers, N</li>
<li>coefs[1] = scale factor</li>
<li>coefs[2] = SLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[3] = iSLD of fronting (/1e-6 Angstrom**-2)</li>
<li>coefs[4] = SLD of backing</li>
<li>coefs[5] = iSLD of backing</li>
<li>coefs[6] = background</li>
<li>coefs[7] = roughness between backing and layer N</li>
<li>coefs[4 * (N - 1) + 8] = thickness of layer N in Angstrom (layer 1 is</li>
</ul>
<p>closest to fronting)
* coefs[4 * (N - 1) + 9] = SLD of layer N (/ 1e-6 Angstrom**-2)
* coefs[4 * (N - 1) + 10] = iSLD of layer N (/ 1e-6 Angstrom**-2)
* coefs[4 * (N - 1) + 11] = roughness between layer N and N-1.</p>
</div></blockquote>
<p><strong>kwds</strong> : dict, optional</p>
<blockquote class="last">
<div><p>The following keys are used:</p>
<dl class="docutils">
<dt>&#8216;dqvals&#8217; - float or np.ndarray, optional</dt>
<dd><p class="first last">If dqvals is a float, then a constant dQ/Q resolution smearing is
employed.  For 5% resolution smearing supply 5.
If <cite>dqvals</cite> is the same shape as q, then the array contains the
FWHM of a Gaussian approximated resolution kernel. Point by point
resolution smearing is employed.  Use this option if dQ/Q varies
across your dataset.
If <cite>dqvals.ndim == q.ndim + 2</cite> and
<cite>q.shape == dqvals[..., -3].shape</cite> then an individual resolution
kernel is applied to each measurement point.  This resolution kernel
is a probability distribution function (PDF). <cite>dqvals</cite> will have the
shape (qvals.shape, M, 2).  There are <cite>M</cite> points in the kernel.
<cite>dqvals[..., 0]</cite> holds the q values for the kernel, <cite>dqvals[..., 1]</cite>
gives the corresponding probability.</p>
</dd>
<dt>&#8216;quad_order&#8217; - int, optional</dt>
<dd><p class="first last">the order of the Gaussian quadrature polynomial for doing the
resolution smearing. default = 17. Don&#8217;t choose less than 13. If
quad_order == &#8216;ultimate&#8217; then adaptive quadrature is used. Adaptive
quadrature will always work, but takes a _long_ time (2 or 3 orders
of magnitude longer). Fixed quadrature will always take a lot less
time. BUT it won&#8217;t necessarily work across all samples. For example,
13 points may be fine for a thin layer, but will be atrocious at
describing a multilayer with bragg peaks.</p>
</dd>
<dt>&#8216;parallel&#8217;: bool, optional</dt>
<dd><p class="first last">Do you want to calculate in parallel? This option is only
applicable if you are using the <code class="docutils literal"><span class="pre">_creflect</span></code> module. The option is
ignored if using the pure python calculator, <code class="docutils literal"><span class="pre">_reflect</span></code>. The
default is <cite>True</cite>.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.to_parameters">
<code class="descclassname">refnx.analysis.</code><code class="descname">to_parameters</code><span class="sig-paren">(</span><em>p0</em>, <em>varies=None</em>, <em>bounds=None</em>, <em>names=None</em>, <em>expr=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#to_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.to_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility function to convert sequences into a lmfit.Parameters instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p0</strong> : np.ndarray</p>
<blockquote>
<div><p>numpy array containing parameter values.</p>
</div></blockquote>
<p><strong>varies</strong> : bool sequence, optional</p>
<blockquote>
<div><p>Specifies whether a parameter is being held or varied.</p>
</div></blockquote>
<p><strong>bounds</strong> : sequence, optional</p>
<blockquote>
<div><p>Tuple of (min, max) pairs specifying the lower and upper bounds for
each parameter</p>
</div></blockquote>
<p><strong>name</strong> : str sequence, optional</p>
<blockquote>
<div><p>Name of each parameter</p>
</div></blockquote>
<p><strong>expr</strong> : str sequence, optional</p>
<blockquote>
<div><p>Constraints for each parameter</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>p</strong> : lmfit.Parameters instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.values">
<code class="descclassname">refnx.analysis.</code><code class="descname">values</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.values" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and returns
the values</p>
</dd></dl>

<dl class="function">
<dt id="refnx.analysis.varys">
<code class="descclassname">refnx.analysis.</code><code class="descname">varys</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/refnx/analysis/curvefitter.html#varys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#refnx.analysis.varys" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that takes an lmfit.Parameters instance and finds
out which ones vary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>parameters</strong> : lmfit.Parameters</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>varys</strong> : bool, sequence</p>
<blockquote class="last">
<div><p>Which parameters are varying</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">refnx.analysis package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-refnx.analysis.curvefitter">refnx.analysis.curvefitter module</a></li>
<li><a class="reference internal" href="#module-refnx.analysis.reflect">refnx.analysis.reflect module</a></li>
<li><a class="reference internal" href="#module-refnx.analysis">Module contents</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/refnx.analysis.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Andrew Nelson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="_sources/refnx.analysis.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>