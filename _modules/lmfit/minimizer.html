<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lmfit.minimizer &mdash; refnx 0.0.3 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="refnx 0.0.3 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for lmfit.minimizer</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Simple minimizer is a wrapper around scipy.leastsq, allowing a</span>
<span class="sd">user to build a fitting model as a function of general purpose</span>
<span class="sd">Fit Parameters that can be fixed or floated, bounded, and written</span>
<span class="sd">as a simple expression of other Fit Parameters.</span>

<span class="sd">The user sets up a model in terms of instance of Parameters, writes a</span>
<span class="sd">function-to-be-minimized (residual function) in terms of these Parameters.</span>

<span class="sd">   Copyright (c) 2011 Matthew Newville, The University of Chicago</span>
<span class="sd">   &lt;newville@cars.uchicago.edu&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">dot</span><span class="p">,</span> <span class="n">eye</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ones_like</span><span class="p">,</span>
                   <span class="n">sqrt</span><span class="p">,</span> <span class="n">take</span><span class="p">,</span> <span class="n">transpose</span><span class="p">,</span> <span class="n">triu</span><span class="p">,</span> <span class="n">deprecate</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.dual</span> <span class="kn">import</span> <span class="n">inv</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">LinAlgError</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>

<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">leastsq</span> <span class="k">as</span> <span class="n">scipy_leastsq</span>

<span class="c"># differential_evolution is only present in scipy &gt;= 0.15</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">differential_evolution</span> <span class="k">as</span> <span class="n">scipy_diffev</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">._differentialevolution</span> <span class="kn">import</span> <span class="n">differential_evolution</span> <span class="k">as</span> <span class="n">scipy_diffev</span>

<span class="c"># check for EMCEE</span>
<span class="n">HAS_EMCEE</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">emcee</span> <span class="kn">as</span> <span class="nn">emcee</span>
    <span class="n">HAS_EMCEE</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c"># check for pandas</span>
<span class="n">HAS_PANDAS</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
    <span class="n">HAS_PANDAS</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c"># check for scipy.optimize.minimize</span>
<span class="n">HAS_SCALAR_MIN</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span> <span class="k">as</span> <span class="n">scipy_minimize</span>
    <span class="n">HAS_SCALAR_MIN</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="kn">from</span> <span class="nn">.parameter</span> <span class="kn">import</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">Parameters</span>

<span class="c"># use locally modified version of uncertainties package</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">uncertainties</span>


<span class="k">def</span> <span class="nf">asteval_with_uncertainties</span><span class="p">(</span><span class="o">*</span><span class="n">vals</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    given values for variables, calculate object value.</span>
<span class="sd">    This is used by the uncertainties package to calculate</span>
<span class="sd">    the uncertainty in an object even with a complicated</span>
<span class="sd">    expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_obj</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;_obj&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">_pars</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;_pars&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">_names</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;_names&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">_asteval</span> <span class="o">=</span> <span class="n">_pars</span><span class="o">.</span><span class="n">_asteval</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_obj</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">_pars</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">_names</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span>
        <span class="n">_asteval</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">_obj</span><span class="o">.</span><span class="n">_expr_ast</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">_names</span><span class="p">):</span>
        <span class="n">_asteval</span><span class="o">.</span><span class="n">symtable</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">_asteval</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">_obj</span><span class="o">.</span><span class="n">_expr_ast</span><span class="p">)</span>

<span class="n">wrap_ueval</span> <span class="o">=</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">asteval_with_uncertainties</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">eval_stderr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">uvars</span><span class="p">,</span> <span class="n">_names</span><span class="p">,</span> <span class="n">_pars</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;evaluate uncertainty and set .stderr for a parameter `obj`</span>
<span class="sd">    given the uncertain values `uvars` (a list of uncertainties.ufloats),</span>
<span class="sd">    a list of parameter names that matches uvars, and a dict of param</span>
<span class="sd">    objects, keyed by name.</span>

<span class="sd">    This uses the uncertainties package wrapped function to evaluate the</span>
<span class="sd">    uncertainty for an arbitrary expression (in obj._expr_ast) of parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;_expr_ast&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">uval</span> <span class="o">=</span> <span class="n">wrap_ueval</span><span class="p">(</span><span class="o">*</span><span class="n">uvars</span><span class="p">,</span> <span class="n">_obj</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span> <span class="n">_names</span><span class="o">=</span><span class="n">_names</span><span class="p">,</span> <span class="n">_pars</span><span class="o">=</span><span class="n">_pars</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">stderr</span> <span class="o">=</span> <span class="n">uval</span><span class="o">.</span><span class="n">std_dev</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">stderr</span> <span class="o">=</span> <span class="mi">0</span>


<span class="k">class</span> <span class="nc">MinimizerException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;General Purpose Exception&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="ne">Exception</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg</span>


<span class="k">def</span> <span class="nf">_differential_evolution</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper for differential_evolution that can be used with scipy.minimize</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">strategy</span><span class="o">=</span><span class="s">&#39;best1bin&#39;</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">popsize</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                  <span class="n">tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">mutation</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">recombination</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">callback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">polish</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                  <span class="n">init</span><span class="o">=</span><span class="s">&#39;latinhypercube&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">return</span> <span class="n">scipy_diffev</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">kwds</span><span class="p">[</span><span class="s">&#39;bounds&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="n">SCALAR_METHODS</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;nelder&#39;</span><span class="p">:</span> <span class="s">&#39;Nelder-Mead&#39;</span><span class="p">,</span>
                  <span class="s">&#39;powell&#39;</span><span class="p">:</span> <span class="s">&#39;Powell&#39;</span><span class="p">,</span>
                  <span class="s">&#39;cg&#39;</span><span class="p">:</span> <span class="s">&#39;CG&#39;</span><span class="p">,</span>
                  <span class="s">&#39;bfgs&#39;</span><span class="p">:</span> <span class="s">&#39;BFGS&#39;</span><span class="p">,</span>
                  <span class="s">&#39;newton&#39;</span><span class="p">:</span> <span class="s">&#39;Newton-CG&#39;</span><span class="p">,</span>
                  <span class="s">&#39;lbfgsb&#39;</span><span class="p">:</span> <span class="s">&#39;L-BFGS-B&#39;</span><span class="p">,</span>
                  <span class="s">&#39;l-bfgsb&#39;</span><span class="p">:</span> <span class="s">&#39;L-BFGS-B&#39;</span><span class="p">,</span>
                  <span class="s">&#39;tnc&#39;</span><span class="p">:</span> <span class="s">&#39;TNC&#39;</span><span class="p">,</span>
                  <span class="s">&#39;cobyla&#39;</span><span class="p">:</span> <span class="s">&#39;COBYLA&#39;</span><span class="p">,</span>
                  <span class="s">&#39;slsqp&#39;</span><span class="p">:</span> <span class="s">&#39;SLSQP&#39;</span><span class="p">,</span>
                  <span class="s">&#39;dogleg&#39;</span><span class="p">:</span> <span class="s">&#39;dogleg&#39;</span><span class="p">,</span>
                  <span class="s">&#39;trust-ncg&#39;</span><span class="p">:</span> <span class="s">&#39;trust-ncg&#39;</span><span class="p">,</span>
                  <span class="s">&#39;differential_evolution&#39;</span><span class="p">:</span> <span class="s">&#39;differential_evolution&#39;</span><span class="p">}</span>


<span class="k">class</span> <span class="nc">MinimizerResult</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; The result of a minimization.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    params : Parameters</span>
<span class="sd">        The best-fit parameters</span>
<span class="sd">    success : bool</span>
<span class="sd">        Whether the minimization was successful</span>
<span class="sd">    status : int</span>
<span class="sd">        Termination status of the optimizer. Its value depends on the</span>
<span class="sd">        underlying solver. Refer to `message` for details.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Additional attributes not listed above may be present, depending on the</span>
<span class="sd">    specific solver. Since this class is essentially a subclass of dict</span>
<span class="sd">    with attribute accessors, one can see which attributes are available</span>
<span class="sd">    using the `keys()` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kws</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flatchain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A flatchain view of the sampling chain from the `emcee` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;chain&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">HAS_PANDAS</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nvarys</span><span class="p">)),</span>
                                    <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Please install Pandas to see the &#39;</span>
                                          <span class="s">&#39;flattened chain&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>


<div class="viewcode-block" id="Minimizer"><a class="viewcode-back" href="../../refnx.analysis.html#refnx.analysis.Minimizer">[docs]</a><span class="k">class</span> <span class="nc">Minimizer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A general minimizer for curve fitting&quot;&quot;&quot;</span>
    <span class="n">err_nonparam</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;params must be a minimizer.Parameters() instance or list &quot;</span>
                    <span class="s">&quot;of Parameters()&quot;</span><span class="p">)</span>
    <span class="n">err_maxfev</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;Too many function calls (max set to </span><span class="si">%i</span><span class="s">)!  Use:&quot;</span>
                  <span class="s">&quot; minimize(func, params, ..., maxfev=NNN)&quot;</span>
                  <span class="s">&quot;or set leastsq_kws[&#39;maxfev&#39;]  to increase this maximum.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">userfcn</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">fcn_args</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fcn_kws</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">iter_cb</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">scale_covar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization of the Minimzer class</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        userfcn : callable</span>
<span class="sd">            objective function that returns the residual (difference between</span>
<span class="sd">            model and data) to be minimized in a least squares sense.  The</span>
<span class="sd">            function must have the signature:</span>
<span class="sd">            `userfcn(params, *fcn_args, **fcn_kws)`</span>
<span class="sd">        params : lmfit.parameter.Parameters object.</span>
<span class="sd">            contains the Parameters for the model.</span>
<span class="sd">        fcn_args : tuple, optional</span>
<span class="sd">            positional arguments to pass to userfcn.</span>
<span class="sd">        fcn_kws : dict, optional</span>
<span class="sd">            keyword arguments to pass to userfcn.</span>
<span class="sd">        iter_cb : callable, optional</span>
<span class="sd">            Function to be called at each fit iteration. This function should</span>
<span class="sd">            have the signature:</span>
<span class="sd">            `iter_cb(params, iter, resid, *fcn_args, **fcn_kws)`,</span>
<span class="sd">            where where `params` will have the current parameter values, `iter`</span>
<span class="sd">            the iteration, `resid` the current residual array, and `*fcn_args`</span>
<span class="sd">            and `**fcn_kws` as passed to the objective function.</span>
<span class="sd">        scale_covar : bool, optional</span>
<span class="sd">            Whether to automatically scale the covariance matrix (leastsq</span>
<span class="sd">            only).</span>
<span class="sd">        kws : dict, optional</span>
<span class="sd">            Options to pass to the minimizer being used.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The objective function should return the value to be minimized. For the</span>
<span class="sd">        Levenberg-Marquardt algorithm from leastsq(), this returned value must</span>
<span class="sd">        be an array, with a length greater than or equal to the number of</span>
<span class="sd">        fitting variables in the model. For the other methods, the return value</span>
<span class="sd">        can either be a scalar or an array. If an array is returned, the sum of</span>
<span class="sd">        squares of the array will be sent to the underlying fitting method,</span>
<span class="sd">        effectively doing a least-squares optimization of the return values.</span>

<span class="sd">        A common use for the fcn_args and fcn_kwds would be to pass in other</span>
<span class="sd">        data needed to calculate the residual, including such things as the</span>
<span class="sd">        data array, dependent variable, uncertainties in the data, and other</span>
<span class="sd">        data structures for the model calculation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">userfcn</span> <span class="o">=</span> <span class="n">userfcn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">userargs</span> <span class="o">=</span> <span class="n">fcn_args</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">userargs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">userargs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">userkws</span> <span class="o">=</span> <span class="n">fcn_kws</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">userkws</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">userkws</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kws</span> <span class="o">=</span> <span class="n">kws</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iter_cb</span> <span class="o">=</span> <span class="n">iter_cb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_covar</span> <span class="o">=</span> <span class="n">scale_covar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfev</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfree</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndata</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ier</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_abort</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">success</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorbars</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lmdif_message</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chisqr</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redchi</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jacfcn</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        param_values : dict</span>
<span class="sd">            Parameter values in a simple dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>

    <span class="k">def</span> <span class="nf">__residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fvars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Residual function used for least-squares fit.</span>
<span class="sd">        With the new, candidate values of fvars (the fitting variables), this</span>
<span class="sd">        evaluates all parameters, including setting bounds and evaluating</span>
<span class="sd">        constraints, and then passes those to the user-supplied function to</span>
<span class="sd">        calculate the residual.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># set parameter values</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abort</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">params</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">,</span> <span class="n">fvars</span><span class="p">):</span>
            <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">from_internal</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">params</span><span class="o">.</span><span class="n">update_constraints</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">userfcn</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">userargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">userkws</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_cb</span><span class="p">):</span>
            <span class="n">abort</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_cb</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">nfev</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span>
                                 <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">userargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">userkws</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_abort</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abort</span> <span class="ow">or</span> <span class="n">abort</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abort</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fvars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        analytical jacobian to be used with the Levenberg-Marquardt</span>

<span class="sd">        modified 02-01-2012 by Glenn Jones, Aberystwyth University</span>
<span class="sd">        modified 06-29-2015 M Newville to apply gradient scaling</span>
<span class="sd">               for bounded variables (thanks to JJ Helmus, N Mayorov)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">params</span>
        <span class="n">grad_scale</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">fvars</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ivar</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">fvars</span><span class="p">[</span><span class="n">ivar</span><span class="p">]</span>
            <span class="n">pars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">pars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">from_internal</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="n">grad_scale</span><span class="p">[</span><span class="n">ivar</span><span class="p">]</span> <span class="o">=</span> <span class="n">pars</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">scale_gradient</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">nfev</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">pars</span><span class="o">.</span><span class="n">update_constraints</span><span class="p">()</span>
        <span class="c"># compute the jacobian for &quot;internal&quot; unbounded variables,</span>
        <span class="c"># the rescale for bounded &quot;external&quot; variables.</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacfcn</span><span class="p">(</span><span class="n">pars</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">userargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">userkws</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">col_deriv</span><span class="p">:</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="p">(</span><span class="n">jac</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">*</span><span class="n">grad_scale</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jac</span> <span class="o">*=</span> <span class="n">grad_scale</span>
        <span class="k">return</span> <span class="n">jac</span>

<div class="viewcode-block" id="Minimizer.penalty"><a class="viewcode-back" href="../../refnx.analysis.html#refnx.analysis.Minimizer.penalty">[docs]</a>    <span class="k">def</span> <span class="nf">penalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fvars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Penalty function for scalar minimizers:</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fvars : array of values for the variable parameters</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        r - float</span>
<span class="sd">            The user evaluated user-supplied objective function. If the</span>
<span class="sd">            objective function is an array, return the array sum-of-squares</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__residual</span><span class="p">(</span><span class="n">fvars</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">r</span>
</div>
<div class="viewcode-block" id="Minimizer.prepare_fit"><a class="viewcode-back" href="../../refnx.analysis.html#refnx.analysis.Minimizer.prepare_fit">[docs]</a>    <span class="k">def</span> <span class="nf">prepare_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prepares parameters for fitting,</span>
<span class="sd">        return array of initial values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># determine which parameters are actually variables</span>
        <span class="c"># and which are defined expressions.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">MinimizerResult</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">Parameters</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">MinimizerException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_nonparam</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">par</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">par</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MinimizerException</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">err_nonparam</span><span class="p">)</span>

        <span class="c"># determine which parameters are actually variables</span>
        <span class="c"># and which are defined expressions.</span>

        <span class="n">result</span><span class="o">.</span><span class="n">var_names</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># note that this *does* belong to self...</span>
        <span class="n">result</span><span class="o">.</span><span class="n">init_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">update_constraints</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">nfev</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">result</span><span class="o">.</span><span class="n">errorbars</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">result</span><span class="o">.</span><span class="n">aborted</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">par</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">par</span><span class="o">.</span><span class="n">stderr</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">par</span><span class="o">.</span><span class="n">correl</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">par</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">par</span><span class="o">.</span><span class="n">vary</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">par</span><span class="o">.</span><span class="n">vary</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">init_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">setup_bounds</span><span class="p">())</span>

            <span class="n">par</span><span class="o">.</span><span class="n">init_value</span> <span class="o">=</span> <span class="n">par</span><span class="o">.</span><span class="n">value</span>
            <span class="k">if</span> <span class="n">par</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">par</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">result</span><span class="o">.</span><span class="n">nvarys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="Minimizer.unprepare_fit"><a class="viewcode-back" href="../../refnx.analysis.html#refnx.analysis.Minimizer.unprepare_fit">[docs]</a>    <span class="k">def</span> <span class="nf">unprepare_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unprepares the fit, so that subsequent fits will be</span>
<span class="sd">        forced to run prepare_fit.</span>

<span class="sd">        removes ast compilations of constraint expressions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</div>
    <span class="nd">@deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s">&#39;    Deprecated in lmfit 0.8.2, use scalar_minimize &#39;</span>
                       <span class="s">&#39;and method=</span><span class="se">\&#39;</span><span class="s">L-BFGS-B</span><span class="se">\&#39;</span><span class="s"> instead&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">lbfgsb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use l-bfgs-b minimization</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kws : dict</span>
<span class="sd">            Minimizer options to pass to the</span>
<span class="sd">            scipy.optimize.lbfgsb.fmin_l_bfgs_b function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;use scalar_minimize(method=&#39;L-BFGS-B&#39;)&quot;</span><span class="p">)</span>

    <span class="nd">@deprecate</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="s">&#39;    Deprecated in lmfit 0.8.2, use scalar_minimize &#39;</span>
                       <span class="s">&#39;and method=</span><span class="se">\&#39;</span><span class="s">Nelder-Mead</span><span class="se">\&#39;</span><span class="s"> instead&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use Nelder-Mead (simplex) minimization</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kws : dict</span>
<span class="sd">            Minimizer options to pass to the scipy.optimize.fmin minimizer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;use scalar_minimize(method=&#39;Nelder-Mead&#39;)&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Minimizer.scalar_minimize"><a class="viewcode-back" href="../../refnx.analysis.html#refnx.analysis.Minimizer.scalar_minimize">[docs]</a>    <span class="k">def</span> <span class="nf">scalar_minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;Nelder-Mead&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use one of the scalar minimization methods from</span>
<span class="sd">        scipy.optimize.minimize.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Name of the fitting method to use.</span>
<span class="sd">            One of:</span>
<span class="sd">                &#39;Nelder-Mead&#39; (default)</span>
<span class="sd">                &#39;L-BFGS-B&#39;</span>
<span class="sd">                &#39;Powell&#39;</span>
<span class="sd">                &#39;CG&#39;</span>
<span class="sd">                &#39;Newton-CG&#39;</span>
<span class="sd">                &#39;COBYLA&#39;</span>
<span class="sd">                &#39;TNC&#39;</span>
<span class="sd">                &#39;trust-ncg&#39;</span>
<span class="sd">                &#39;dogleg&#39;</span>
<span class="sd">                &#39;SLSQP&#39;</span>
<span class="sd">                &#39;differential_evolution&#39;</span>

<span class="sd">        params : Parameters, optional</span>
<span class="sd">           Parameters to use as starting points.</span>
<span class="sd">        kws : dict, optional</span>
<span class="sd">            Minimizer options pass to scipy.optimize.minimize.</span>

<span class="sd">        If the objective function returns a numpy array instead</span>
<span class="sd">        of the expected scalar, the sum of squares of the array</span>
<span class="sd">        will be used.</span>

<span class="sd">        Note that bounds and constraints can be set on Parameters</span>
<span class="sd">        for any of these methods, so are not supported separately</span>
<span class="sd">        for those designed to use bounds. However, if you use the</span>
<span class="sd">        differential_evolution option you must specify finite</span>
<span class="sd">        (min, max) for each Parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        success : bool</span>
<span class="sd">            Whether the fit was successful.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">HAS_SCALAR_MIN</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_fit</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">init_vals</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">params</span>

        <span class="n">fmin_kws</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                        <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">1000</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)})</span>
        <span class="n">fmin_kws</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kws</span><span class="p">)</span>
        <span class="n">fmin_kws</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kws</span><span class="p">)</span>

        <span class="c"># hess supported only in some methods</span>
        <span class="k">if</span> <span class="s">&#39;hess&#39;</span> <span class="ow">in</span> <span class="n">fmin_kws</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;Newton-CG&#39;</span><span class="p">,</span>
                                                 <span class="s">&#39;dogleg&#39;</span><span class="p">,</span> <span class="s">&#39;trust-ncg&#39;</span><span class="p">):</span>
            <span class="n">fmin_kws</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;hess&#39;</span><span class="p">)</span>

        <span class="c"># jac supported only in some methods (and Dfun could be used...)</span>
        <span class="k">if</span> <span class="s">&#39;jac&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fmin_kws</span> <span class="ow">and</span> <span class="n">fmin_kws</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;Dfun&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jacfcn</span> <span class="o">=</span> <span class="n">fmin_kws</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;jac&#39;</span><span class="p">)</span>
            <span class="n">fmin_kws</span><span class="p">[</span><span class="s">&#39;jac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__jacobian</span>

        <span class="k">if</span> <span class="s">&#39;jac&#39;</span> <span class="ow">in</span> <span class="n">fmin_kws</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;CG&#39;</span><span class="p">,</span> <span class="s">&#39;BFGS&#39;</span><span class="p">,</span> <span class="s">&#39;Newton-CG&#39;</span><span class="p">,</span>
                                                <span class="s">&#39;dogleg&#39;</span><span class="p">,</span> <span class="s">&#39;trust-ncg&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jacfcn</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">fmin_kws</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;jac&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&#39;differential_evolution&#39;</span><span class="p">:</span>
            <span class="n">fmin_kws</span><span class="p">[</span><span class="s">&#39;method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_differential_evolution</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="n">par</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">par</span><span class="o">.</span><span class="n">max</span><span class="p">)</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">bounds</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;With differential evolution finite bounds &#39;</span>
                                 <span class="s">&#39;are required for each parameter&#39;</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
            <span class="n">fmin_kws</span><span class="p">[</span><span class="s">&#39;bounds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span>

            <span class="c"># in scipy 0.14 this can be called directly from scipy_minimize</span>
            <span class="c"># When minimum scipy is 0.14 the following line and the else</span>
            <span class="c"># can be removed.</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">_differential_evolution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="o">**</span><span class="n">fmin_kws</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">scipy_minimize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">penalty</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="o">**</span><span class="n">fmin_kws</span><span class="p">)</span>

        <span class="n">result</span><span class="o">.</span><span class="n">aborted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abort</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_abort</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ret</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">ret</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;_&#39;</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

        <span class="n">result</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">chisqr</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__residual</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">nvarys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">ndata</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">result</span><span class="o">.</span><span class="n">nfree</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">residual</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">chisqr</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">chisqr</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">result</span><span class="o">.</span><span class="n">ndata</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">residual</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">nfree</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">ndata</span> <span class="o">-</span> <span class="n">result</span><span class="o">.</span><span class="n">nvarys</span>
        <span class="n">result</span><span class="o">.</span><span class="n">redchi</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">chisqr</span> <span class="o">/</span> <span class="n">result</span><span class="o">.</span><span class="n">nfree</span>
        <span class="n">_log_likelihood</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">ndata</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">redchi</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">aic</span> <span class="o">=</span> <span class="n">_log_likelihood</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">result</span><span class="o">.</span><span class="n">nvarys</span>
        <span class="n">result</span><span class="o">.</span><span class="n">bic</span> <span class="o">=</span> <span class="n">_log_likelihood</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">ndata</span><span class="p">)</span> <span class="o">*</span> <span class="n">result</span><span class="o">.</span><span class="n">nvarys</span>

        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="Minimizer.emcee"><a class="viewcode-back" href="../../refnx.analysis.html#refnx.analysis.Minimizer.emcee">[docs]</a>    <span class="k">def</span> <span class="nf">emcee</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">nwalkers</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">burn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
              <span class="n">ntemps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">reuse_sampler</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
              <span class="n">float_behavior</span><span class="o">=</span><span class="s">&#39;posterior&#39;</span><span class="p">,</span> <span class="n">is_weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bayesian sampling of the posterior distribution for the parameters</span>
<span class="sd">        using the `emcee` Markov Chain Monte Carlo package. The method assumes</span>
<span class="sd">        that the prior is Uniform. You need to have `emcee` installed to use</span>
<span class="sd">        this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : lmfit.Parameters, optional</span>
<span class="sd">            Parameters to use as starting point. If this is not specified</span>
<span class="sd">            then the Parameters used to initialise the Minimizer object are</span>
<span class="sd">            used.</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            How many samples you would like to draw from the posterior</span>
<span class="sd">            distribution for each of the walkers?</span>
<span class="sd">        nwalkers : int, optional</span>
<span class="sd">            Should be set so :math:`nwalkers &gt;&gt; nvarys`, where `nvarys` are</span>
<span class="sd">            the number of parameters being varied during the fit.</span>
<span class="sd">            &quot;Walkers are the members of the ensemble. They are almost like</span>
<span class="sd">            separate Metropolis-Hastings chains but, of course, the proposal</span>
<span class="sd">            distribution for a given walker depends on the positions of all</span>
<span class="sd">            the other walkers in the ensemble.&quot; - from the `emcee` webpage.</span>
<span class="sd">        burn : int, optional</span>
<span class="sd">            Discard this many samples from the start of the sampling regime.</span>
<span class="sd">        thin : int, optional</span>
<span class="sd">            Only accept 1 in every `thin` samples.</span>
<span class="sd">        ntemps : int, optional</span>
<span class="sd">            If `ntemps &gt; 1` perform a Parallel Tempering.</span>
<span class="sd">        pos : np.ndarray, optional</span>
<span class="sd">            Specify the initial positions for the sampler.  If `ntemps == 1`</span>
<span class="sd">            then `pos.shape` should be `(nwalkers, nvarys)`. Otherwise,</span>
<span class="sd">            `(ntemps, nwalkers, nvarys)`. You can also initialise using a</span>
<span class="sd">            previous chain that had the same `ntemps`, `nwalkers` and</span>
<span class="sd">            `nvarys`. Note that `nvarys` may be one larger than you expect it</span>
<span class="sd">            to be if your `userfcn` returns an array and `is_weighted is</span>
<span class="sd">            False`.</span>
<span class="sd">        reuse_sampler : bool, optional</span>
<span class="sd">            If you have already run `emcee` on a given `Minimizer` object then</span>
<span class="sd">            it possesses an internal ``sampler`` attribute. You can continue to</span>
<span class="sd">            draw from the same sampler (retaining the chain history) if you set</span>
<span class="sd">            this option to `True`. Otherwise a new sampler is created. The</span>
<span class="sd">            `nwalkers`, `ntemps`, `pos`, and `params` keywords are ignored with</span>
<span class="sd">            this option.</span>
<span class="sd">            **Important**: the Parameters used to create the sampler must not</span>
<span class="sd">            change in-between calls to `emcee`. Alteration of Parameters</span>
<span class="sd">            would include changed ``min``, ``max``, ``vary`` and ``expr``</span>
<span class="sd">            attributes. This may happen, for example, if you use an altered</span>
<span class="sd">            Parameters object and call the `minimize` method in-between calls</span>
<span class="sd">            to `emcee`.</span>
<span class="sd">        workers : Pool-like or int, optional</span>
<span class="sd">            For parallelization of sampling.  It can be any Pool-like object</span>
<span class="sd">            with a map method that follows the same calling sequence as the</span>
<span class="sd">            built-in `map` function. If int is given as the argument, then a</span>
<span class="sd">            multiprocessing-based pool is spawned internally with the</span>
<span class="sd">            corresponding number of parallel processes. &#39;mpi4py&#39;-based</span>
<span class="sd">            parallelization and &#39;joblib&#39;-based parallelization pools can also</span>
<span class="sd">            be used here. **Note**: because of multiprocessing overhead it may</span>
<span class="sd">            only be worth parallelising if the objective function is expensive</span>
<span class="sd">            to calculate, or if there are a large number of objective</span>
<span class="sd">            evaluations per step (`ntemps * nwalkers * nvarys`).</span>
<span class="sd">        float_behavior : str, optional</span>
<span class="sd">            Specifies meaning of the objective function output if it returns a</span>
<span class="sd">            float. One of:</span>

<span class="sd">                &#39;posterior&#39; - objective function returns a log-posterior</span>
<span class="sd">                               probability</span>
<span class="sd">                &#39;chi2&#39; - objective function returns :math:`\chi^2`.</span>

<span class="sd">            See Notes for further details.</span>
<span class="sd">        is_weighted : bool, optional</span>
<span class="sd">            Has your objective function been weighted by measurement</span>
<span class="sd">            uncertainties? If `is_weighted is True` then your objective</span>
<span class="sd">            function is assumed to return residuals that have been divided by</span>
<span class="sd">            the true measurement uncertainty `(data - model) / sigma`. If</span>
<span class="sd">            `is_weighted is False` then the objective function is assumed to</span>
<span class="sd">            return unweighted residuals, `data - model`. In this case `emcee`</span>
<span class="sd">            will employ a positive measurement uncertainty during the sampling.</span>
<span class="sd">            This measurement uncertainty will be present in the output params</span>
<span class="sd">            and output chain with the name `__lnsigma`. A side effect of this</span>
<span class="sd">            is that you cannot use this parameter name yourself.</span>
<span class="sd">            **Important** this parameter only has any effect if your objective</span>
<span class="sd">            function returns an array. If your objective function returns a</span>
<span class="sd">            float, then this parameter is ignored. See Notes for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : MinimizerResult</span>
<span class="sd">            MinimizerResult object containing updated params, statistics,</span>
<span class="sd">            etc. The `MinimizerResult` also contains the ``chain``,</span>
<span class="sd">            ``flatchain`` and ``lnprob`` attributes. The ``chain``</span>
<span class="sd">            and ``flatchain`` attributes contain the samples and have the shape</span>
<span class="sd">            `(nwalkers, (steps - burn) // thin, nvarys)` or</span>
<span class="sd">            `(ntemps, nwalkers, (steps - burn) // thin, nvarys)`,</span>
<span class="sd">            depending on whether Parallel tempering was used or not.</span>
<span class="sd">            `nvarys` is the number of parameters that are allowed to vary.</span>
<span class="sd">            The ``flatchain`` attribute is a `pandas.DataFrame` of the</span>
<span class="sd">            flattened chain, `chain.reshape(-1, nvarys)`. To access flattened</span>
<span class="sd">            chain values for a particular parameter use</span>
<span class="sd">            `result.flatchain[parname]`. The ``lnprob`` attribute contains the</span>
<span class="sd">            log probability for each sample in ``chain``. The sample with the</span>
<span class="sd">            highest probability corresponds to the maximum likelihood estimate.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method samples the posterior distribution of the parameters using</span>
<span class="sd">        Markov Chain Monte Carlo.  To do so it needs to calculate the</span>
<span class="sd">        log-posterior probability of the model parameters, `F`, given the data,</span>
<span class="sd">        `D`, :math:`\ln p(F_{true} | D)`. This &#39;posterior probability&#39; is</span>
<span class="sd">        calculated as:</span>

<span class="sd">        ..math::</span>

<span class="sd">        \ln p(F_{true} | D) \propto \ln p(D | F_{true}) + \ln p(F_{true})</span>

<span class="sd">        where :math:`\ln p(D | F_{true})` is the &#39;log-likelihood&#39; and</span>
<span class="sd">        :math:`\ln p(F_{true})` is the &#39;log-prior&#39;. The default log-prior</span>
<span class="sd">        encodes prior information already known about the model. This method</span>
<span class="sd">        assumes that the log-prior probability is `-np.inf` (impossible) if the</span>
<span class="sd">        one of the parameters is outside its limits. The log-prior probability</span>
<span class="sd">        term is zero if all the parameters are inside their bounds (known as a</span>
<span class="sd">        uniform prior). The log-likelihood function is given by [1]_:</span>

<span class="sd">        ..math::</span>

<span class="sd">        \ln p(D|F_{true}) = -\frac{1}{2}\sum_n \left[\frac{\left(g_n(F_{true}) - D_n \right)^2}{s_n^2}+\ln (2\pi s_n^2)\right]</span>

<span class="sd">        The first summand in the square brackets represents the residual for a</span>
<span class="sd">        given datapoint (:math:`g` being the generative model) . This term</span>
<span class="sd">        represents :math:`\chi^2` when summed over all datapoints.</span>
<span class="sd">        Ideally the objective function used to create `lmfit.Minimizer` should</span>
<span class="sd">        return the log-posterior probability, :math:`\ln p(F_{true} | D)`.</span>
<span class="sd">        However, since the in-built log-prior term is zero, the objective</span>
<span class="sd">        function can also just return the log-likelihood, unless you wish to</span>
<span class="sd">        create a non-uniform prior.</span>

<span class="sd">        If a float value is returned by the objective function then this value</span>
<span class="sd">        is assumed by default to be the log-posterior probability, i.e.</span>
<span class="sd">        `float_behavior is &#39;posterior&#39;`. If your objective function returns</span>
<span class="sd">        :math:`\chi^2`, then you should use a value of `&#39;chi2&#39;` for</span>
<span class="sd">        `float_behavior`. `emcee` will then multiply your :math:`\chi^2` value</span>
<span class="sd">        by -0.5 to obtain the posterior probability.</span>

<span class="sd">        However, the default behaviour of many objective functions is to return</span>
<span class="sd">        a vector of (possibly weighted) residuals. Therefore, if your objective</span>
<span class="sd">        function returns a vector, `res`, then the vector is assumed to contain</span>
<span class="sd">        the residuals. If `is_weighted is True` then your residuals are assumed</span>
<span class="sd">        to be correctly weighted by the standard deviation of the data points</span>
<span class="sd">        (`res = (data - model) / sigma`) and the log-likelihood (and</span>
<span class="sd">        log-posterior probability) is calculated as: `-0.5 * np.sum(res **2)`.</span>
<span class="sd">        This ignores the second summand in the square brackets. Consequently,</span>
<span class="sd">        in order to calculate a fully correct log-posterior probability value</span>
<span class="sd">        your objective function should return a single value. If</span>
<span class="sd">        `is_weighted is False` then the data uncertainty, `s_n`, will be</span>
<span class="sd">        treated as a nuisance parameter and will be marginalised out. This is</span>
<span class="sd">        achieved by employing a strictly positive uncertainty</span>
<span class="sd">        (homoscedasticity) for each data point, :math:`s_n = exp(__lnsigma)`.</span>
<span class="sd">        `__lnsigma` will be present in `MinimizerResult.params`, as well as</span>
<span class="sd">        `Minimizer.chain`, `nvarys` will also be increased by one.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] http://dan.iel.fm/emcee/current/user/line/</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">HAS_EMCEE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;You must have emcee to use&#39;</span>
                                      <span class="s">&#39; the emcee method&#39;</span><span class="p">)</span>
        <span class="n">tparams</span> <span class="o">=</span> <span class="n">params</span>
        <span class="c"># if you&#39;re reusing the sampler then ntemps, nwalkers have to be</span>
        <span class="c"># determined from the previous sampling</span>
        <span class="k">if</span> <span class="n">reuse_sampler</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;sampler&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_lastpos&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;You wanted to use an existing sampler, but&quot;</span>
                                 <span class="s">&quot;it hasn&#39;t been created yet&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lastpos</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">ntemps</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">nwalkers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lastpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lastpos</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">ntemps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lastpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">nwalkers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lastpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">tparams</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_fit</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">tparams</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">params</span>

        <span class="c"># check if the userfcn returns a vector of residuals</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">userfcn</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">userargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">userkws</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">is_weighted</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="c"># we need to marginalise over a constant data uncertainty</span>
            <span class="k">if</span> <span class="s">&#39;__lnsigma&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="c"># __lnsigma should already be in params if is_weighted was</span>
                <span class="c"># previously set to True.</span>
                <span class="n">params</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;__lnsigma&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">vary</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="c"># have to re-prepare the fit</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_fit</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">params</span>

        <span class="c"># Removing internal parameter scaling. We could possibly keep it,</span>
        <span class="c"># but I don&#39;t know how this affects the emcee sampling.</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">var_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">par</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">param</span><span class="o">.</span><span class="n">vary</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">vary</span><span class="p">:</span>
                <span class="n">var_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># don&#39;t want to append bounds if they&#39;re not being varied.</span>
                <span class="k">continue</span>

            <span class="n">param</span><span class="o">.</span><span class="n">from_internal</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">val</span>
            <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">max</span>
            <span class="k">if</span> <span class="n">lb</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">lb</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">:</span>
                <span class="n">lb</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">if</span> <span class="n">ub</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">ub</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">:</span>
                <span class="n">ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">bounds</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">))</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nvarys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>

        <span class="c"># set up multiprocessing options for the samplers</span>
        <span class="n">auto_pool</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">sampler_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">workers</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="ow">and</span> <span class="n">workers</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">auto_pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">workers</span><span class="p">)</span>
            <span class="n">sampler_kwargs</span><span class="p">[</span><span class="s">&#39;pool&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">auto_pool</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">workers</span><span class="p">,</span> <span class="s">&#39;map&#39;</span><span class="p">):</span>
            <span class="n">sampler_kwargs</span><span class="p">[</span><span class="s">&#39;pool&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">workers</span>

        <span class="c"># function arguments for the log-probability functions</span>
        <span class="c"># these values are sent to the log-probability functions by the sampler.</span>
        <span class="n">lnprob_args</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">userfcn</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">,</span> <span class="n">bounds</span><span class="p">)</span>
        <span class="n">lnprob_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;is_weighted&#39;</span><span class="p">:</span> <span class="n">is_weighted</span><span class="p">,</span>
                         <span class="s">&#39;float_behavior&#39;</span><span class="p">:</span> <span class="n">float_behavior</span><span class="p">,</span>
                         <span class="s">&#39;userargs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">userargs</span><span class="p">,</span>
                         <span class="s">&#39;userkws&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">userkws</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">ntemps</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># the prior and likelihood function args and kwargs are the same</span>
            <span class="n">sampler_kwargs</span><span class="p">[</span><span class="s">&#39;loglargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lnprob_args</span>
            <span class="n">sampler_kwargs</span><span class="p">[</span><span class="s">&#39;loglkwargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lnprob_kwargs</span>
            <span class="n">sampler_kwargs</span><span class="p">[</span><span class="s">&#39;logpargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sampler_kwargs</span><span class="p">[</span><span class="s">&#39;args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lnprob_args</span>
            <span class="n">sampler_kwargs</span><span class="p">[</span><span class="s">&#39;kwargs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lnprob_kwargs</span>

        <span class="c"># now initialise the samplers</span>
        <span class="k">if</span> <span class="n">reuse_sampler</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">auto_pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">auto_pool</span>

            <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lastpos</span>
            <span class="k">if</span> <span class="n">p0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nvarys</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;You cannot reuse the sampler if the number&quot;</span>
                                 <span class="s">&quot;of varying parameters has changed&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ntemps</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># Parallel Tempering</span>
            <span class="c"># jitter the starting position by scaled Gaussian noise</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">ntemps</span><span class="p">,</span> <span class="n">nwalkers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nvarys</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.e-4</span>
            <span class="n">p0</span> <span class="o">*=</span> <span class="n">var_arr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">PTSampler</span><span class="p">(</span><span class="n">ntemps</span><span class="p">,</span> <span class="n">nwalkers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nvarys</span><span class="p">,</span>
                                           <span class="n">_lnpost</span><span class="p">,</span> <span class="n">_lnprior</span><span class="p">,</span> <span class="o">**</span><span class="n">sampler_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nwalkers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nvarys</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.e-4</span>
            <span class="n">p0</span> <span class="o">*=</span> <span class="n">var_arr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="n">emcee</span><span class="o">.</span><span class="n">EnsembleSampler</span><span class="p">(</span><span class="n">nwalkers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nvarys</span><span class="p">,</span>
                                                 <span class="n">_lnpost</span><span class="p">,</span> <span class="o">**</span><span class="n">sampler_kwargs</span><span class="p">)</span>

        <span class="c"># user supplies an initialisation position for the chain</span>
        <span class="c"># If you try to run the sampler with p0 of a wrong size then you&#39;ll get</span>
        <span class="c"># a ValueError. Note, you can&#39;t initialise with a position if you are</span>
        <span class="c"># reusing the sampler.</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reuse_sampler</span><span class="p">:</span>
            <span class="n">tpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">p0</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">tpos</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="c"># trying to initialise with a previous chain</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">tpos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="n">nwalkers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nvarys</span><span class="p">)):</span>
                <span class="n">tpos</span> <span class="o">=</span> <span class="n">tpos</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c"># initialising with a PTsampler chain.</span>
            <span class="k">elif</span> <span class="n">ntemps</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">tpos</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">tpos_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tpos</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">tpos_shape</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tpos_shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">ntemps</span><span class="p">,</span> <span class="n">nwalkers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nvarys</span><span class="p">):</span>
                    <span class="n">tpos</span> <span class="o">=</span> <span class="n">tpos</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;pos should have shape (nwalkers, nvarys)&#39;</span>
                                 <span class="s">&#39;or (ntemps, nwalkers, nvarys) if ntemps &gt; 1&#39;</span><span class="p">)</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">tpos</span>

        <span class="c"># now do a production run, sampling all the time</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">run_mcmc</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lastpos</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># discard the burn samples and thin</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">chain</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">burn</span><span class="p">::</span><span class="n">thin</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">lnprobability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">lnprobability</span><span class="p">[:,</span> <span class="n">burn</span><span class="p">::</span><span class="n">thin</span><span class="p">]</span>

        <span class="n">flatchain</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nvarys</span><span class="p">))</span>

        <span class="n">quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">flatchain</span><span class="p">,</span> <span class="p">[</span><span class="mf">15.87</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">84.13</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
            <span class="n">std_l</span><span class="p">,</span> <span class="n">median</span><span class="p">,</span> <span class="n">std_u</span> <span class="o">=</span> <span class="n">quantiles</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">params</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">median</span>
            <span class="n">params</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">std_u</span> <span class="o">-</span> <span class="n">std_l</span><span class="p">)</span>
            <span class="n">params</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">correl</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">params</span><span class="o">.</span><span class="n">update_constraints</span><span class="p">()</span>

        <span class="c"># work out correlation coefficients</span>
        <span class="n">corrcoefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">flatchain</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">var_name2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">correl</span><span class="p">[</span><span class="n">var_name2</span><span class="p">]</span> <span class="o">=</span> <span class="n">corrcoefs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="n">result</span><span class="o">.</span><span class="n">chain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">lnprob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">lnprobability</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">errorbars</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">result</span><span class="o">.</span><span class="n">nvarys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">auto_pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">auto_pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="Minimizer.leastsq"><a class="viewcode-back" href="../../refnx.analysis.html#refnx.analysis.Minimizer.leastsq">[docs]</a>    <span class="k">def</span> <span class="nf">leastsq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use Levenberg-Marquardt minimization to perform a fit.</span>
<span class="sd">        This assumes that ModelParameters have been stored, and a function to</span>
<span class="sd">        minimize has been properly set up.</span>

<span class="sd">        This wraps scipy.optimize.leastsq.</span>

<span class="sd">        When possible, this calculates the estimated uncertainties and</span>
<span class="sd">        variable correlations from the covariance matrix.</span>

<span class="sd">        Writes outputs to many internal attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : Parameters, optional</span>
<span class="sd">           Parameters to use as starting points.</span>
<span class="sd">        kws : dict, optional</span>
<span class="sd">            Minimizer options to pass to scipy.optimize.leastsq.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        success : bool</span>
<span class="sd">            True if fit was successful, False if not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_fit</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">init_vals</span>
        <span class="n">nvars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
        <span class="n">lskws</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1.e-7</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1.e-7</span><span class="p">,</span> <span class="n">col_deriv</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                     <span class="n">gtol</span><span class="o">=</span><span class="mf">1.e-7</span><span class="p">,</span> <span class="n">maxfev</span><span class="o">=</span><span class="mi">2000</span><span class="o">*</span><span class="p">(</span><span class="n">nvars</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">Dfun</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

        <span class="n">lskws</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kws</span><span class="p">)</span>
        <span class="n">lskws</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kws</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">col_deriv</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">lskws</span><span class="p">[</span><span class="s">&#39;Dfun&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jacfcn</span> <span class="o">=</span> <span class="n">lskws</span><span class="p">[</span><span class="s">&#39;Dfun&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">col_deriv</span> <span class="o">=</span> <span class="n">lskws</span><span class="p">[</span><span class="s">&#39;col_deriv&#39;</span><span class="p">]</span>
            <span class="n">lskws</span><span class="p">[</span><span class="s">&#39;Dfun&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__jacobian</span>

        <span class="c"># suppress runtime warnings during fit and error analysis</span>
        <span class="n">orig_warn_settings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geterr</span><span class="p">()</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s">&#39;ignore&#39;</span><span class="p">)</span>

        <span class="n">lsout</span> <span class="o">=</span> <span class="n">scipy_leastsq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__residual</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="o">**</span><span class="n">lskws</span><span class="p">)</span>
        <span class="n">_best</span><span class="p">,</span> <span class="n">_cov</span><span class="p">,</span> <span class="n">infodict</span><span class="p">,</span> <span class="n">errmsg</span><span class="p">,</span> <span class="n">ier</span> <span class="o">=</span> <span class="n">lsout</span>
        <span class="n">result</span><span class="o">.</span><span class="n">aborted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abort</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_abort</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">result</span><span class="o">.</span><span class="n">residual</span> <span class="o">=</span> <span class="n">resid</span> <span class="o">=</span> <span class="n">infodict</span><span class="p">[</span><span class="s">&#39;fvec&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">ier</span> <span class="o">=</span> <span class="n">ier</span>
        <span class="n">result</span><span class="o">.</span><span class="n">lmdif_message</span> <span class="o">=</span> <span class="n">errmsg</span>
        <span class="n">result</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s">&#39;Fit succeeded.&#39;</span>
        <span class="n">result</span><span class="o">.</span><span class="n">success</span> <span class="o">=</span> <span class="n">ier</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">aborted</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s">&#39;Fit aborted by user callback.&#39;</span>
            <span class="n">result</span><span class="o">.</span><span class="n">success</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">ier</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s">&#39;Invalid Input Parameters.&#39;</span>
        <span class="k">elif</span> <span class="n">ier</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">err_maxfev</span> <span class="o">%</span> <span class="n">lskws</span><span class="p">[</span><span class="s">&#39;maxfev&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s">&#39;Tolerance seems to be too small.&#39;</span>

        <span class="n">result</span><span class="o">.</span><span class="n">ndata</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>

        <span class="n">result</span><span class="o">.</span><span class="n">chisqr</span> <span class="o">=</span> <span class="p">(</span><span class="n">resid</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">nfree</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">ndata</span> <span class="o">-</span> <span class="n">nvars</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">redchi</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">chisqr</span> <span class="o">/</span> <span class="n">result</span><span class="o">.</span><span class="n">nfree</span>
        <span class="n">_log_likelihood</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">ndata</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">redchi</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">aic</span> <span class="o">=</span> <span class="n">_log_likelihood</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nvars</span>
        <span class="n">result</span><span class="o">.</span><span class="n">bic</span> <span class="o">=</span> <span class="n">_log_likelihood</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">ndata</span><span class="p">)</span> <span class="o">*</span> <span class="n">nvars</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">params</span>

        <span class="c"># need to map _best values to params, then calculate the</span>
        <span class="c"># grad for the variable parameters</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">_best</span><span class="p">)</span>
        <span class="n">vbest</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">_best</span><span class="p">)</span>

        <span class="c"># ensure that _best, vbest, and grad are not</span>
        <span class="c"># broken 1-element ndarrays.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">_best</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_best</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">vbest</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vbest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vbest</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">grad</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">grad</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">ivar</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
            <span class="n">grad</span><span class="p">[</span><span class="n">ivar</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">scale_gradient</span><span class="p">(</span><span class="n">_best</span><span class="p">[</span><span class="n">ivar</span><span class="p">])</span>
            <span class="n">vbest</span><span class="p">[</span><span class="n">ivar</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>

        <span class="c"># modified from JJ Helmus&#39; leastsqbound.py</span>
        <span class="n">infodict</span><span class="p">[</span><span class="s">&#39;fjac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">infodict</span><span class="p">[</span><span class="s">&#39;fjac&#39;</span><span class="p">])</span> <span class="o">/</span>
                                     <span class="n">take</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="n">infodict</span><span class="p">[</span><span class="s">&#39;ipvt&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">rvec</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">triu</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">infodict</span><span class="p">[</span><span class="s">&#39;fjac&#39;</span><span class="p">])[:</span><span class="n">nvars</span><span class="p">,</span> <span class="p">:]),</span>
                   <span class="n">take</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">nvars</span><span class="p">),</span> <span class="n">infodict</span><span class="p">[</span><span class="s">&#39;ipvt&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">covar</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">rvec</span><span class="p">),</span> <span class="n">rvec</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">LinAlgError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">covar</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">has_expr</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">par</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="n">par</span><span class="o">.</span><span class="n">correl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span>
            <span class="n">has_expr</span> <span class="o">=</span> <span class="n">has_expr</span> <span class="ow">or</span> <span class="n">par</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

        <span class="c"># self.errorbars = error bars were successfully estimated</span>
        <span class="n">result</span><span class="o">.</span><span class="n">errorbars</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">covar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">aborted</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">errorbars</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">errorbars</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_covar</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">covar</span> <span class="o">*=</span> <span class="n">result</span><span class="o">.</span><span class="n">redchi</span>
            <span class="k">for</span> <span class="n">ivar</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
                <span class="n">par</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="n">par</span><span class="o">.</span><span class="n">stderr</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">covar</span><span class="p">[</span><span class="n">ivar</span><span class="p">,</span> <span class="n">ivar</span><span class="p">])</span>
                <span class="n">par</span><span class="o">.</span><span class="n">correl</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">errorbars</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">errorbars</span> <span class="ow">and</span> <span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">stderr</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">jvar</span><span class="p">,</span> <span class="n">varn2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">jvar</span> <span class="o">!=</span> <span class="n">ivar</span><span class="p">:</span>
                            <span class="n">par</span><span class="o">.</span><span class="n">correl</span><span class="p">[</span><span class="n">varn2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">covar</span><span class="p">[</span><span class="n">ivar</span><span class="p">,</span> <span class="n">jvar</span><span class="p">]</span> <span class="o">/</span>
                                 <span class="p">(</span><span class="n">par</span><span class="o">.</span><span class="n">stderr</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">covar</span><span class="p">[</span><span class="n">jvar</span><span class="p">,</span> <span class="n">jvar</span><span class="p">])))</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">errorbars</span> <span class="o">=</span> <span class="bp">False</span>

            <span class="k">if</span> <span class="n">has_expr</span><span class="p">:</span>
                <span class="c"># uncertainties on constrained parameters:</span>
                <span class="c">#   get values with uncertainties (including correlations),</span>
                <span class="c">#   temporarily set Parameter values to these,</span>
                <span class="c">#   re-evaluate contrained parameters to extract stderr</span>
                <span class="c">#   and then set Parameters back to best-fit value</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">uvars</span> <span class="o">=</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">correlated_values</span><span class="p">(</span><span class="n">vbest</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">covar</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="n">LinAlgError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                    <span class="n">uvars</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="n">uvars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="n">eval_stderr</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="n">uvars</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                    <span class="c"># restore nominal values</span>
                    <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">nam</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">uvars</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
                        <span class="n">params</span><span class="p">[</span><span class="n">nam</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">nominal_value</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">errorbars</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">. Could not estimate error-bars&#39;</span> <span class="o">%</span> <span class="n">result</span><span class="o">.</span><span class="n">message</span>

        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">orig_warn_settings</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="Minimizer.minimize"><a class="viewcode-back" href="../../refnx.analysis.html#refnx.analysis.Minimizer.minimize">[docs]</a>    <span class="k">def</span> <span class="nf">minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;leastsq&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the minimization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Name of the fitting method to use.</span>
<span class="sd">            One of:</span>
<span class="sd">            &#39;leastsq&#39;                -    Levenberg-Marquardt (default)</span>
<span class="sd">            &#39;nelder&#39;                 -    Nelder-Mead</span>
<span class="sd">            &#39;lbfgsb&#39;                 -    L-BFGS-B</span>
<span class="sd">            &#39;powell&#39;                 -    Powell</span>
<span class="sd">            &#39;cg&#39;                     -    Conjugate-Gradient</span>
<span class="sd">            &#39;newton&#39;                 -    Newton-CG</span>
<span class="sd">            &#39;cobyla&#39;                 -    Cobyla</span>
<span class="sd">            &#39;tnc&#39;                    -    Truncate Newton</span>
<span class="sd">            &#39;trust-ncg&#39;              -    Trust Newton-CGn</span>
<span class="sd">            &#39;dogleg&#39;                 -    Dogleg</span>
<span class="sd">            &#39;slsqp&#39;                  -    Sequential Linear Squares Programming</span>
<span class="sd">            &#39;differential_evolution&#39; -    differential evolution</span>

<span class="sd">        params : Parameters, optional</span>
<span class="sd">            parameters to use as starting values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : MinimizerResult</span>

<span class="sd">            MinimizerResult object contains updated params, fit statistics, etc.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leastsq</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;params&#39;</span><span class="p">:</span> <span class="n">params</span><span class="p">}</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kws</span><span class="p">)</span>

        <span class="n">user_method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">user_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;least&#39;</span><span class="p">):</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leastsq</span>
        <span class="k">elif</span> <span class="n">HAS_SCALAR_MIN</span><span class="p">:</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalar_minimize</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">SCALAR_METHODS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">user_method</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">user_method</span><span class="p">)):</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">user_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;nelder&#39;</span><span class="p">)</span> <span class="ow">or</span>
              <span class="n">user_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;fmin&#39;</span><span class="p">)):</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmin</span>
        <span class="k">elif</span> <span class="n">user_method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;lbfgsb&#39;</span><span class="p">):</span>
            <span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lbfgsb</span>
        <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

</div></div>
<span class="k">def</span> <span class="nf">_lnprior</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates an improper uniform log-prior probability</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : sequence</span>
<span class="sd">        float parameter values (only those being varied)</span>
<span class="sd">    bounds : np.ndarray</span>
<span class="sd">        Lower and upper bounds of parameters that are varying.</span>
<span class="sd">        Has shape (nvarys, 2).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lnprob : float</span>
<span class="sd">        Log prior probability</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">theta</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">theta</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">_lnpost</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">userfcn</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">var_names</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">userargs</span><span class="o">=</span><span class="p">(),</span>
            <span class="n">userkws</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">float_behavior</span><span class="o">=</span><span class="s">&#39;posterior&#39;</span><span class="p">,</span> <span class="n">is_weighted</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the log-posterior probability. See the `Minimizer.emcee` method</span>
<span class="sd">    for more details</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    theta : sequence</span>
<span class="sd">        float parameter values (only those being varied)</span>
<span class="sd">    userfcn : callable</span>
<span class="sd">        User objective function</span>
<span class="sd">    params : lmfit.Parameters</span>
<span class="sd">        The entire set of Parameters</span>
<span class="sd">    var_names : list</span>
<span class="sd">        The names of the parameters that are varying</span>
<span class="sd">    bounds : np.ndarray</span>
<span class="sd">        Lower and upper bounds of parameters. Has shape (nvarys, 2).</span>
<span class="sd">    userargs : tuple, optional</span>
<span class="sd">        Extra positional arguments required for user objective function</span>
<span class="sd">    userkws : dict, optional</span>
<span class="sd">        Extra keyword arguments required for user objective function</span>
<span class="sd">    float_behavior : str, optional</span>
<span class="sd">        Specifies meaning of objective when it returns a float. One of:</span>

<span class="sd">        &#39;posterior&#39; - objective function returnins a log-posterior</span>
<span class="sd">                      probability.</span>
<span class="sd">        &#39;chi2&#39; - objective function returns a chi2 value.</span>

<span class="sd">    is_weighted : bool</span>
<span class="sd">        If `userfcn` returns a vector of residuals then `is_weighted`</span>
<span class="sd">        specifies if the residuals have been weighted by data uncertainties.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lnprob : float</span>
<span class="sd">        Log posterior probability</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># the comparison has to be done on theta and bounds. DO NOT inject theta</span>
    <span class="c"># values into Parameters, then compare Parameters values to the bounds.</span>
    <span class="c"># Parameters values are clipped to stay within bounds.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">theta</span> <span class="o">&gt;</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">theta</span> <span class="o">&lt;</span> <span class="n">bounds</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span>

    <span class="n">userkwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">userkws</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">userkwargs</span> <span class="o">=</span> <span class="n">userkws</span>

    <span class="c"># update the constraints</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update_constraints</span><span class="p">()</span>

    <span class="c"># now calculate the log-likelihood</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">userfcn</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">userargs</span><span class="p">,</span> <span class="o">**</span><span class="n">userkwargs</span><span class="p">)</span>
    <span class="n">lnprob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">lnprob</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c"># objective function returns a vector of residuals</span>
        <span class="k">if</span> <span class="s">&#39;__lnsigma&#39;</span> <span class="ow">in</span> <span class="n">params</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_weighted</span><span class="p">:</span>
            <span class="c"># marginalise over a constant data uncertainty</span>
            <span class="n">__lnsigma</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">&#39;__lnsigma&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">__lnsigma</span>
            <span class="n">lnprob</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">lnprob</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">__lnsigma</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lnprob</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">lnprob</span> <span class="o">*</span> <span class="n">lnprob</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># objective function returns a single value.</span>
        <span class="c"># use float_behaviour to figure out if the value is posterior or chi2</span>
        <span class="k">if</span> <span class="n">float_behavior</span> <span class="o">==</span> <span class="s">&#39;posterior&#39;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">float_behavior</span> <span class="o">==</span> <span class="s">&#39;chi2&#39;</span><span class="p">:</span>
            <span class="n">lnprob</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">0.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;float_behaviour must be either &#39;posterior&#39; or&quot;</span>
                             <span class="s">&quot; &#39;chi2&#39; &quot;</span> <span class="o">+</span> <span class="n">float_behavior</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">lnprob</span>


<span class="k">def</span> <span class="nf">minimize</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;leastsq&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">kws</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">scale_covar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">iter_cb</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kws</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A general purpose curvefitting function</span>
<span class="sd">    The minimize function takes a objective function to be minimized, a</span>
<span class="sd">    dictionary (lmfit.parameter.Parameters) containing the model parameters,</span>
<span class="sd">    and several optional arguments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fcn : callable</span>
<span class="sd">        objective function that returns the residual (difference between</span>
<span class="sd">        model and data) to be minimized in a least squares sense.  The</span>
<span class="sd">        function must have the signature:</span>
<span class="sd">        `fcn(params, *args, **kws)`</span>
<span class="sd">    params : lmfit.parameter.Parameters object.</span>
<span class="sd">        contains the Parameters for the model.</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Name of the fitting method to use.</span>
<span class="sd">        One of:</span>
<span class="sd">            &#39;leastsq&#39;                -    Levenberg-Marquardt (default)</span>
<span class="sd">            &#39;nelder&#39;                 -    Nelder-Mead</span>
<span class="sd">            &#39;lbfgsb&#39;                 -    L-BFGS-B</span>
<span class="sd">            &#39;powell&#39;                 -    Powell</span>
<span class="sd">            &#39;cg&#39;                     -    Conjugate-Gradient</span>
<span class="sd">            &#39;newton&#39;                 -    Newton-CG</span>
<span class="sd">            &#39;cobyla&#39;                 -    Cobyla</span>
<span class="sd">            &#39;tnc&#39;                    -    Truncate Newton</span>
<span class="sd">            &#39;trust-ncg&#39;              -    Trust Newton-CGn</span>
<span class="sd">            &#39;dogleg&#39;                 -    Dogleg</span>
<span class="sd">            &#39;slsqp&#39;                  -    Sequential Linear Squares Programming</span>
<span class="sd">            &#39;differential_evolution&#39; -    differential evolution</span>

<span class="sd">    args : tuple, optional</span>
<span class="sd">        Positional arguments to pass to fcn.</span>
<span class="sd">    kws : dict, optional</span>
<span class="sd">        keyword arguments to pass to fcn.</span>
<span class="sd">    iter_cb : callable, optional</span>
<span class="sd">        Function to be called at each fit iteration. This function should</span>
<span class="sd">        have the signature `iter_cb(params, iter, resid, *args, **kws)`,</span>
<span class="sd">        where where `params` will have the current parameter values, `iter`</span>
<span class="sd">        the iteration, `resid` the current residual array, and `*args`</span>
<span class="sd">        and `**kws` as passed to the objective function.</span>
<span class="sd">    scale_covar : bool, optional</span>
<span class="sd">        Whether to automatically scale the covariance matrix (leastsq</span>
<span class="sd">        only).</span>
<span class="sd">    fit_kws : dict, optional</span>
<span class="sd">        Options to pass to the minimizer being used.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The objective function should return the value to be minimized. For the</span>
<span class="sd">    Levenberg-Marquardt algorithm from leastsq(), this returned value must</span>
<span class="sd">    be an array, with a length greater than or equal to the number of</span>
<span class="sd">    fitting variables in the model. For the other methods, the return value</span>
<span class="sd">    can either be a scalar or an array. If an array is returned, the sum of</span>
<span class="sd">    squares of the array will be sent to the underlying fitting method,</span>
<span class="sd">    effectively doing a least-squares optimization of the return values.</span>

<span class="sd">    A common use for `args` and `kwds` would be to pass in other</span>
<span class="sd">    data needed to calculate the residual, including such things as the</span>
<span class="sd">    data array, dependent variable, uncertainties in the data, and other</span>
<span class="sd">    data structures for the model calculation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fitter</span> <span class="o">=</span> <span class="n">Minimizer</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">fcn_args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">fcn_kws</span><span class="o">=</span><span class="n">kws</span><span class="p">,</span>
                       <span class="n">iter_cb</span><span class="o">=</span><span class="n">iter_cb</span><span class="p">,</span> <span class="n">scale_covar</span><span class="o">=</span><span class="n">scale_covar</span><span class="p">,</span> <span class="o">**</span><span class="n">fit_kws</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fitter</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Andrew Nelson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
    </div>

    

    
  </body>
</html>