
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>refnx.reflect.reflect_model &#8212; refnx 0.0.13.dev0+8d6438f documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.0.13.dev0+8d6438f',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for refnx.reflect.reflect_model</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">InterpolatedUnivariateSpline</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">refnx.reflect</span> <span class="k">import</span> <span class="n">_creflect</span> <span class="k">as</span> <span class="n">refcalc</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING, Using slow reflectivity calculation&#39;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">refnx.reflect</span> <span class="k">import</span> <span class="n">_reflect</span> <span class="k">as</span> <span class="n">refcalc</span>
<span class="kn">from</span> <span class="nn">refnx.analysis</span> <span class="k">import</span> <span class="p">(</span><span class="n">Parameters</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">possibly_create_parameter</span><span class="p">)</span>


<span class="c1"># some definitions for resolution smearing</span>
<span class="n">_FWHM</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">))</span>
<span class="n">_INTLIMIT</span> <span class="o">=</span> <span class="mf">3.5</span>


<div class="viewcode-block" id="ReflectModel"><a class="viewcode-back" href="../../../refnx.reflect.html#refnx.reflect.reflect_model.ReflectModel">[docs]</a><span class="k">class</span> <span class="nc">ReflectModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    structure : refnx.reflect.Structure</span>
<span class="sd">        The interfacial structure.</span>
<span class="sd">    scale : float or refnx.analysis.Parameter, optional</span>
<span class="sd">        scale factor. All model values are multiplied by this value before</span>
<span class="sd">        the background is added. This is turned into a Parameter during the</span>
<span class="sd">        construction of this object.</span>
<span class="sd">    bkg : float or refnx.analysis.Parameter, optional</span>
<span class="sd">        linear background added to all model values. This is turned into</span>
<span class="sd">        a Parameter during the construction of this object.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        Name of the Model</span>
<span class="sd">    dq : float or refnx.analysis.Parameter, optional</span>

<span class="sd">        - `dq == 0` then no resolution smearing is employed.</span>
<span class="sd">        - `dq` is a float or refnx.analysis.Parameter</span>
<span class="sd">           a constant dQ/Q resolution smearing is employed.  For 5% resolution</span>
<span class="sd">           smearing supply 5.</span>

<span class="sd">        However, if `x_err` is supplied to the `model` method, then that</span>
<span class="sd">        overrides any setting given here. This value is turned into</span>
<span class="sd">        a Parameter during the construction of this object.</span>
<span class="sd">    threads: int, optional</span>
<span class="sd">        Specifies the number of threads for parallel calculation. This</span>
<span class="sd">        option is only applicable if you are using the ``_creflect``</span>
<span class="sd">        module. The option is ignored if using the pure python calculator,</span>
<span class="sd">        ``_reflect``. If `threads == 0` then all available processors are</span>
<span class="sd">        used.</span>
<span class="sd">    quad_order: int, optional</span>
<span class="sd">        the order of the Gaussian quadrature polynomial for doing the</span>
<span class="sd">        resolution smearing. default = 17. Don&#39;t choose less than 13. If</span>
<span class="sd">        quad_order == &#39;ultimate&#39; then adaptive quadrature is used. Adaptive</span>
<span class="sd">        quadrature will always work, but takes a _long_ time (2 or 3 orders</span>
<span class="sd">        of magnitude longer). Fixed quadrature will always take a lot less</span>
<span class="sd">        time. BUT it won&#39;t necessarily work across all samples. For</span>
<span class="sd">        example, 13 points may be fine for a thin layer, but will be</span>
<span class="sd">        atrocious at describing a multilayer with bragg peaks.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bkg</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dq</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span>
                 <span class="n">threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">quad_order</span><span class="o">=</span><span class="mi">17</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">=</span> <span class="n">threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad_order</span> <span class="o">=</span> <span class="n">quad_order</span>

        <span class="c1"># all reflectometry models need a scale factor and background</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span> <span class="o">=</span> <span class="n">possibly_create_parameter</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;scale&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bkg</span> <span class="o">=</span> <span class="n">possibly_create_parameter</span><span class="p">(</span><span class="n">bkg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;bkg&#39;</span><span class="p">)</span>

        <span class="c1"># we can optimize the resolution (but this is always overridden by</span>
        <span class="c1"># x_err if supplied. There is therefore possibly no dependence on it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dq</span> <span class="o">=</span> <span class="n">possibly_create_parameter</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;dq - resolution&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">=</span> <span class="n">structure</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_err</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">x_err</span><span class="o">=</span><span class="n">x_err</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameter`</span>

<span class="sd">            - `dq.value == 0`</span>
<span class="sd">               no resolution smearing is employed.</span>
<span class="sd">            - `dq.value &gt; 0`</span>
<span class="sd">               a constant dQ/Q resolution smearing is employed.  For 5%</span>
<span class="sd">               resolution smearing supply 5. However, if `x_err` is supplied to</span>
<span class="sd">               the `model` method, then that overrides any setting reported</span>
<span class="sd">               here.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dq</span>

    <span class="nd">@dq</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dq</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameter` - all model values are multiplied by</span>
<span class="sd">        this value before the background is added.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span>

    <span class="nd">@scale</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bkg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameter` - linear background added to all</span>
<span class="sd">        model values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bkg</span>

    <span class="nd">@bkg</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bkg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bkg</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="ReflectModel.model"><a class="viewcode-back" href="../../../refnx.reflect.html#refnx.reflect.reflect_model.ReflectModel.model">[docs]</a>    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_err</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the reflectivity of this model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float or np.ndarray</span>
<span class="sd">            q values for the calculation.</span>
<span class="sd">        p : refnx.analysis.Parameter, optional</span>
<span class="sd">            parameters required to calculate the model</span>
<span class="sd">        x_err : np.ndarray</span>
<span class="sd">            dq resolution smearing values for the dataset being considered.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reflectivity : np.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">pvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># fallback to what this object was constructed with</span>
            <span class="n">x_err</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dq</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">reflectivity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">slabs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">],</span>
                            <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                            <span class="n">bkg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bkg</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                            <span class="n">dq</span><span class="o">=</span><span class="n">x_err</span><span class="p">,</span>
                            <span class="n">threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="p">,</span>
                            <span class="n">quad_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_order</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReflectModel.lnprob"><a class="viewcode-back" href="../../../refnx.reflect.html#refnx.reflect.reflect_model.ReflectModel.lnprob">[docs]</a>    <span class="k">def</span> <span class="nf">lnprob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Additional log-probability terms for the reflectivity model. Do not</span>
<span class="sd">        include log-probability terms for model parameters, these are</span>
<span class="sd">        automatically calculated elsewhere.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lnprob : float</span>
<span class="sd">            log-probability of structure.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="o">.</span><span class="n">lnprob</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.reflect.Structure` - object describing the interface of</span>
<span class="sd">        a reflectometry sample.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>

    <span class="nd">@structure</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structure</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span> <span class="o">=</span> <span class="n">structure</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;instrument parameters&#39;</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bkg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dq</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">parameters</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameters` - parameters associated with this</span>
<span class="sd">        model.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structure</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span></div>


<div class="viewcode-block" id="reflectivity"><a class="viewcode-back" href="../../../refnx.reflect.html#refnx.reflect.reflect_model.reflectivity">[docs]</a><span class="k">def</span> <span class="nf">reflectivity</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">slabs</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">bkg</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">dq</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">quad_order</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span>
                 <span class="n">threads</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abeles matrix formalism for calculating reflectivity from a stratified</span>
<span class="sd">    medium.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : np.ndarray</span>
<span class="sd">        The qvalues required for the calculation.</span>
<span class="sd">        :math:`Q=\frac{4Pi}{\lambda}\sin(\Omega)`.</span>
<span class="sd">        Units = Angstrom**-1</span>
<span class="sd">    slabs : np.ndarray</span>
<span class="sd">        coefficients required for the calculation, has shape (2 + N, 4),</span>
<span class="sd">        where N is the number of layers</span>

<span class="sd">        - slabs[0, 0]</span>
<span class="sd">           ignored</span>
<span class="sd">        - slabs[N, 0]</span>
<span class="sd">           thickness of layer N</span>
<span class="sd">        - slabs[N+1, 0]</span>
<span class="sd">           ignored</span>

<span class="sd">        - slabs[0, 1]</span>
<span class="sd">           SLD_real of fronting (/1e-6 Angstrom**-2)</span>
<span class="sd">        - slabs[N, 1]</span>
<span class="sd">           SLD_real of layer N (/1e-6 Angstrom**-2)</span>
<span class="sd">        - slabs[-1, 1]</span>
<span class="sd">           SLD_real of backing (/1e-6 Angstrom**-2)</span>

<span class="sd">        - slabs[0, 2]</span>
<span class="sd">           SLD_imag of fronting (/1e-6 Angstrom**-2)</span>
<span class="sd">        - slabs[N, 2]</span>
<span class="sd">           iSLD_imag of layer N (/1e-6 Angstrom**-2)</span>
<span class="sd">        - slabs[-1, 2]</span>
<span class="sd">           iSLD_imag of backing (/1e-6 Angstrom**-2)</span>

<span class="sd">        - slabs[0, 3]</span>
<span class="sd">           ignored</span>
<span class="sd">        - slabs[N, 3]</span>
<span class="sd">           roughness between layer N-1/N</span>
<span class="sd">        - slabs[-1, 3]</span>
<span class="sd">           roughness between backing and layer N</span>

<span class="sd">    scale : float</span>
<span class="sd">        scale factor. All model values are multiplied by this value before</span>
<span class="sd">        the background is added</span>
<span class="sd">    bkg : float</span>
<span class="sd">        linear background added to all model values.</span>
<span class="sd">    dq : float or np.ndarray, optional</span>
<span class="sd">        - `dq == 0`</span>
<span class="sd">           no resolution smearing is employed.</span>
<span class="sd">        - `dq` is a float</span>
<span class="sd">           a constant dQ/Q resolution smearing is employed.  For 5% resolution</span>
<span class="sd">           smearing supply 5.</span>
<span class="sd">        - `dq` is the same shape as q</span>
<span class="sd">           the array contains the FWHM of a Gaussian approximated resolution</span>
<span class="sd">           kernel. Point by point resolution smearing is employed.  Use this</span>
<span class="sd">           option if dQ/Q varies across your dataset.</span>
<span class="sd">        - `dq.ndim == q.ndim + 2` and `q.shape == dq[..., -3].shape`</span>
<span class="sd">           an individual resolution kernel is applied to each measurement</span>
<span class="sd">           point. This resolution kernel is a probability distribution function</span>
<span class="sd">           (PDF). `dqvals` will have the shape (qvals.shape, M, 2).  There are</span>
<span class="sd">           `M` points in the kernel. `dq[..., 0]` holds the q values for the</span>
<span class="sd">           kernel, `dq[..., 1]` gives the corresponding probability.</span>
<span class="sd">    quad_order: int, optional</span>
<span class="sd">        the order of the Gaussian quadrature polynomial for doing the</span>
<span class="sd">        resolution smearing. default = 17. Don&#39;t choose less than 13. If</span>
<span class="sd">        quad_order == &#39;ultimate&#39; then adaptive quadrature is used. Adaptive</span>
<span class="sd">        quadrature will always work, but takes a _long_ time (2 or 3 orders</span>
<span class="sd">        of magnitude longer). Fixed quadrature will always take a lot less</span>
<span class="sd">        time. BUT it won&#39;t necessarily work across all samples. For</span>
<span class="sd">        example, 13 points may be fine for a thin layer, but will be</span>
<span class="sd">        atrocious at describing a multilayer with bragg peaks.</span>
<span class="sd">    threads: int, optional</span>
<span class="sd">        Specifies the number of threads for parallel calculation. This</span>
<span class="sd">        option is only applicable if you are using the ``_creflect``</span>
<span class="sd">        module. The option is ignored if using the pure python calculator,</span>
<span class="sd">        ``_reflect``. If `threads == 0` then all available processors are</span>
<span class="sd">        used.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># constant dq/q smearing</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">float</span><span class="p">(</span><span class="n">dq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">refcalc</span><span class="o">.</span><span class="n">abeles</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">slabs</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">bkg</span><span class="o">=</span><span class="n">bkg</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Real</span><span class="p">):</span>
        <span class="n">dq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dq</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span>
                <span class="n">_smeared_abeles_constant</span><span class="p">(</span><span class="n">q</span><span class="p">,</span>
                                         <span class="n">slabs</span><span class="p">,</span>
                                         <span class="n">dq</span><span class="p">,</span>
                                         <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">))</span> <span class="o">+</span> <span class="n">bkg</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dq</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">q</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">dqvals_flat</span> <span class="o">=</span> <span class="n">dq</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">qvals_flat</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># adaptive quadrature</span>
        <span class="k">if</span> <span class="n">quad_order</span> <span class="o">==</span> <span class="s1">&#39;ultimate&#39;</span><span class="p">:</span>
            <span class="n">smeared_rvals</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span>
                             <span class="n">_smeared_abeles_adaptive</span><span class="p">(</span><span class="n">qvals_flat</span><span class="p">,</span>
                                                      <span class="n">slabs</span><span class="p">,</span>
                                                      <span class="n">dqvals_flat</span><span class="p">,</span>
                                                      <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">)</span> <span class="o">+</span>
                             <span class="n">bkg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">smeared_rvals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># fixed order quadrature</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">smeared_rvals</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span>
                             <span class="n">_smeared_abeles_fixed</span><span class="p">(</span><span class="n">qvals_flat</span><span class="p">,</span>
                                                   <span class="n">slabs</span><span class="p">,</span>
                                                   <span class="n">dqvals_flat</span><span class="p">,</span>
                                                   <span class="n">quad_order</span><span class="o">=</span><span class="n">quad_order</span><span class="p">,</span>
                                                   <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">)</span> <span class="o">+</span>
                             <span class="n">bkg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">smeared_rvals</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># resolution kernel smearing</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span>
          <span class="n">dq</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">2</span> <span class="ow">and</span>
          <span class="n">dq</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span><span class="p">]</span> <span class="o">==</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>

        <span class="c1"># TODO may not work yet.</span>
        <span class="n">qvals_for_res</span> <span class="o">=</span> <span class="n">dq</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># work out the reflectivity at the kernel evaluation points</span>
        <span class="n">smeared_rvals</span> <span class="o">=</span> <span class="n">refcalc</span><span class="o">.</span><span class="n">abeles</span><span class="p">(</span><span class="n">qvals_for_res</span><span class="p">,</span>
                                       <span class="n">slabs</span><span class="p">,</span>
                                       <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
                                       <span class="n">bkg</span><span class="o">=</span><span class="n">bkg</span><span class="p">,</span>
                                       <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">)</span>

        <span class="c1"># multiply by probability</span>
        <span class="n">smeared_rvals</span> <span class="o">*=</span> <span class="n">dq</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># now do simpson integration</span>
        <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">simps</span><span class="p">(</span><span class="n">smeared_rvals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">dq</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="kc">None</span></div>


<span class="k">def</span> <span class="nf">_memoize_gl</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cache the gaussian quadrature abscissae, so they don&#39;t have to be</span>
<span class="sd">    calculated all the time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">inner</span>


<div class="viewcode-block" id="gauss_legendre"><a class="viewcode-back" href="../../../refnx.reflect.html#refnx.reflect.reflect_model.gauss_legendre">[docs]</a><span class="nd">@_memoize_gl</span>
<span class="k">def</span> <span class="nf">gauss_legendre</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate gaussian quadrature abscissae and weights</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        Gaussian quadrature order.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (x, w) : tuple</span>
<span class="sd">        The abscissae and weights for Gauss Legendre integration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">p_roots</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_smearkernel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dq</span><span class="p">,</span> <span class="n">threads</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Kernel for adaptive Gaussian quadrature integration</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float</span>
<span class="sd">        Independent variable for integration.</span>
<span class="sd">    w : array-like</span>
<span class="sd">        The uniform slab model parameters in &#39;layer&#39; form.</span>
<span class="sd">    q : float</span>
<span class="sd">        Nominal mean Q of normal distribution</span>
<span class="sd">    dq : float</span>
<span class="sd">        FWHM of a normal distribution.</span>
<span class="sd">    threads : int</span>
<span class="sd">        number of threads for parallel calculation</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reflectivity : float</span>
<span class="sd">        Model reflectivity multiplied by the probability density function</span>
<span class="sd">        evaluated at a given distance, x, away from the mean Q value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prefactor</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">gauss</span> <span class="o">=</span> <span class="n">prefactor</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">localq</span> <span class="o">=</span> <span class="n">q</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">dq</span> <span class="o">/</span> <span class="n">_FWHM</span>
    <span class="k">return</span> <span class="n">refcalc</span><span class="o">.</span><span class="n">abeles</span><span class="p">(</span><span class="n">localq</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">)</span> <span class="o">*</span> <span class="n">gauss</span>


<span class="k">def</span> <span class="nf">_smeared_abeles_adaptive</span><span class="p">(</span><span class="n">qvals</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dqvals</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resolution smearing that uses adaptive Gaussian quadrature integration</span>
<span class="sd">    for the convolution.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qvals : array-like</span>
<span class="sd">        The Q values for evaluation</span>
<span class="sd">    w : array-like</span>
<span class="sd">        The uniform slab model parameters in &#39;layer&#39; form.</span>
<span class="sd">    dqvals : array-like</span>
<span class="sd">        dQ values corresponding to each value in `qvals`. Each dqval is the</span>
<span class="sd">        FWHM of a Gaussian approximation to the resolution kernel.</span>
<span class="sd">    threads : int, optional</span>
<span class="sd">        Do you want to calculate in parallel? This option is only applicable if</span>
<span class="sd">        you are using the ``_creflect`` module. The option is ignored if using</span>
<span class="sd">        the pure python calculator, ``_reflect``.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reflectivity : np.ndarray</span>
<span class="sd">        The smeared reflectivity</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The integration is adaptive meaning it keeps going until it reaches an</span>
<span class="sd">    absolute tolerance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">smeared_rvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">qvals</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="ne">Warning</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qvals</span><span class="p">):</span>
        <span class="n">smeared_rvals</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">err</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quadrature</span><span class="p">(</span>
            <span class="n">_smearkernel</span><span class="p">,</span>
            <span class="o">-</span><span class="n">_INTLIMIT</span><span class="p">,</span>
            <span class="n">_INTLIMIT</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
            <span class="n">rtol</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">qvals</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">dqvals</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">threads</span><span class="p">))</span>

    <span class="n">warnings</span><span class="o">.</span><span class="n">resetwarnings</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">smeared_rvals</span>


<span class="k">def</span> <span class="nf">_smeared_abeles_fixed</span><span class="p">(</span><span class="n">qvals</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dqvals</span><span class="p">,</span> <span class="n">quad_order</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resolution smearing that uses fixed order Gaussian quadrature integration</span>
<span class="sd">    for the convolution.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qvals : array-like</span>
<span class="sd">        The Q values for evaluation</span>
<span class="sd">    w : array-like</span>
<span class="sd">        The uniform slab model parameters in &#39;layer&#39; form.</span>
<span class="sd">    dqvals : array-like</span>
<span class="sd">        dQ values corresponding to each value in `qvals`. Each dqval is the</span>
<span class="sd">        FWHM of a Gaussian approximation to the resolution kernel.</span>
<span class="sd">    quad-order : int, optional</span>
<span class="sd">        Specify the order of the Gaussian quadrature integration for the</span>
<span class="sd">        convolution.</span>
<span class="sd">    threads: int, optional</span>
<span class="sd">        Specifies the number of threads for parallel calculation. This</span>
<span class="sd">        option is only applicable if you are using the ``_creflect``</span>
<span class="sd">        module. The option is ignored if using the pure python calculator,</span>
<span class="sd">        ``_reflect``. If `threads == 0` then all available processors are</span>
<span class="sd">        used.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reflectivity : np.ndarray</span>
<span class="sd">        The smeared reflectivity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the gauss-legendre weights and abscissae</span>
    <span class="n">abscissa</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">gauss_legendre</span><span class="p">(</span><span class="n">quad_order</span><span class="p">)</span>

    <span class="c1"># get the normal distribution at that point</span>
    <span class="n">prefactor</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">gauss</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

    <span class="n">gaussvals</span> <span class="o">=</span> <span class="n">prefactor</span> <span class="o">*</span> <span class="n">gauss</span><span class="p">(</span><span class="n">abscissa</span> <span class="o">*</span> <span class="n">_INTLIMIT</span><span class="p">)</span>

    <span class="c1"># integration between -3.5 and 3.5 sigma</span>
    <span class="n">va</span> <span class="o">=</span> <span class="n">qvals</span> <span class="o">-</span> <span class="n">_INTLIMIT</span> <span class="o">*</span> <span class="n">dqvals</span> <span class="o">/</span> <span class="n">_FWHM</span>
    <span class="n">vb</span> <span class="o">=</span> <span class="n">qvals</span> <span class="o">+</span> <span class="n">_INTLIMIT</span> <span class="o">*</span> <span class="n">dqvals</span> <span class="o">/</span> <span class="n">_FWHM</span>

    <span class="n">va</span> <span class="o">=</span> <span class="n">va</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">vb</span> <span class="o">=</span> <span class="n">vb</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="n">qvals_for_res</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">abscissa</span><span class="p">)</span> <span class="o">*</span>
                     <span class="p">(</span><span class="n">vb</span> <span class="o">-</span> <span class="n">va</span><span class="p">)</span> <span class="o">+</span> <span class="n">vb</span> <span class="o">+</span> <span class="n">va</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
    <span class="n">smeared_rvals</span> <span class="o">=</span> <span class="n">refcalc</span><span class="o">.</span><span class="n">abeles</span><span class="p">(</span><span class="n">qvals_for_res</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                   <span class="n">w</span><span class="p">,</span>
                                   <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">)</span>

    <span class="n">smeared_rvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">smeared_rvals</span><span class="p">,</span>
                               <span class="p">(</span><span class="n">qvals</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">abscissa</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>

    <span class="n">smeared_rvals</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">gaussvals</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">smeared_rvals</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_INTLIMIT</span>


<span class="k">def</span> <span class="nf">_smeared_abeles_constant</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A kernel for fast and constant dQ/Q smearing</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q: np.ndarray</span>
<span class="sd">        Q values to evaluate the reflectivity at</span>
<span class="sd">    w: np.ndarray</span>
<span class="sd">        Parameters for the reflectivity model</span>
<span class="sd">    resolution: float</span>
<span class="sd">        Percentage dq/q resolution. dq specified as FWHM of a resolution</span>
<span class="sd">        kernel.</span>
<span class="sd">    threads: int, optional</span>
<span class="sd">        Do you want to calculate in parallel? This option is only applicable if</span>
<span class="sd">        you are using the ``_creflect`` module. The option is ignored if using</span>
<span class="sd">        the pure python calculator, ``_reflect``.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    reflectivity: np.ndarray</span>
<span class="sd">        The resolution smeared reflectivity</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">resolution</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">refcalc</span><span class="o">.</span><span class="n">abeles</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">)</span>

    <span class="n">resolution</span> <span class="o">/=</span> <span class="mi">100</span>
    <span class="n">gaussnum</span> <span class="o">=</span> <span class="mi">51</span>
    <span class="n">gaussgpoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">gaussnum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">gauss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">s</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">s</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span>

    <span class="n">lowq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">highq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lowq</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">lowq</span> <span class="o">=</span> <span class="mf">1e-6</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lowq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">_FWHM</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">highq</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">6</span> <span class="o">*</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">_FWHM</span><span class="p">))</span>
    <span class="n">interpnum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">finish</span><span class="p">))</span> <span class="o">/</span>
                         <span class="p">(</span><span class="mf">1.7</span> <span class="o">*</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">_FWHM</span> <span class="o">/</span> <span class="n">gaussgpoint</span><span class="p">)))</span>
    <span class="n">xtemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">finish</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">interpnum</span><span class="p">))</span>
    <span class="n">xlin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">xtemp</span><span class="p">)</span>

    <span class="c1"># resolution smear over [-4 sigma, 4 sigma]</span>
    <span class="n">gauss_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.7</span> <span class="o">*</span> <span class="n">resolution</span><span class="p">,</span> <span class="mf">1.7</span> <span class="o">*</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">gaussnum</span><span class="p">)</span>
    <span class="n">gauss_y</span> <span class="o">=</span> <span class="n">gauss</span><span class="p">(</span><span class="n">gauss_x</span><span class="p">,</span> <span class="n">resolution</span> <span class="o">/</span> <span class="n">_FWHM</span><span class="p">)</span>

    <span class="n">rvals</span> <span class="o">=</span> <span class="n">refcalc</span><span class="o">.</span><span class="n">abeles</span><span class="p">(</span><span class="n">xlin</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="n">threads</span><span class="p">)</span>
    <span class="n">smeared_rvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">rvals</span><span class="p">,</span> <span class="n">gauss_y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
    <span class="n">interpolator</span> <span class="o">=</span> <span class="n">InterpolatedUnivariateSpline</span><span class="p">(</span><span class="n">xlin</span><span class="p">,</span> <span class="n">smeared_rvals</span><span class="p">)</span>

    <span class="n">smeared_output</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="c1"># smeared_output *= np.sum(gauss_y)</span>
    <span class="n">smeared_output</span> <span class="o">*=</span> <span class="n">gauss_x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">gauss_x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">smeared_output</span>


<div class="viewcode-block" id="MixedReflectModel"><a class="viewcode-back" href="../../../refnx.reflect.html#refnx.reflect.reflect_model.MixedReflectModel">[docs]</a><span class="k">class</span> <span class="nc">MixedReflectModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates an incoherent average of reflectivities from a sequence of</span>
<span class="sd">    structures. Such a situation may occur if a sample is not uniform over its</span>
<span class="sd">    illuminated area.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    structures : sequence of refnx.reflect.Structure</span>
<span class="sd">        The interfacial structures to incoherently average</span>
<span class="sd">    scales : None, sequence of float or refnx.analysis.Parameter, optional</span>
<span class="sd">        scale factors. The reflectivities calculated from each of the</span>
<span class="sd">        structures are multiplied by their respective scale factor during</span>
<span class="sd">        overall summation. These values are turned into Parameters during the</span>
<span class="sd">        construction of this object.</span>
<span class="sd">        You must supply a scale factor for each of the structures. If `scales`</span>
<span class="sd">        is `None`, then default scale factors are used:</span>
<span class="sd">        `[1 / len(structures)] * len(structures)`. It is a good idea to set the</span>
<span class="sd">        lower bound of each scale factor to zero (not done by default).</span>
<span class="sd">    bkg : float or refnx.analysis.Parameter, optional</span>
<span class="sd">        linear background added to the overall reflectivity. This is turned</span>
<span class="sd">        into a Parameter during the construction of this object.</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        Name of the mixed Model</span>
<span class="sd">    dq : float or refnx.analysis.Parameter, optional</span>

<span class="sd">        - `dq == 0` then no resolution smearing is employed.</span>
<span class="sd">        - `dq` is a float or refnx.analysis.Parameter</span>
<span class="sd">           a constant dQ/Q resolution smearing is employed.  For 5% resolution</span>
<span class="sd">           smearing supply 5.</span>

<span class="sd">        However, if `x_err` is supplied to the `model` method, then that</span>
<span class="sd">        overrides any setting given here. This value is turned into</span>
<span class="sd">        a Parameter during the construction of this object.</span>
<span class="sd">    threads: int, optional</span>
<span class="sd">        Specifies the number of threads for parallel calculation. This</span>
<span class="sd">        option is only applicable if you are using the ``_creflect``</span>
<span class="sd">        module. The option is ignored if using the pure python calculator,</span>
<span class="sd">        ``_reflect``. If `threads == 0` then all available processors are</span>
<span class="sd">        used.</span>
<span class="sd">    quad_order: int, optional</span>
<span class="sd">        the order of the Gaussian quadrature polynomial for doing the</span>
<span class="sd">        resolution smearing. default = 17. Don&#39;t choose less than 13. If</span>
<span class="sd">        quad_order == &#39;ultimate&#39; then adaptive quadrature is used. Adaptive</span>
<span class="sd">        quadrature will always work, but takes a _long_ time (2 or 3 orders</span>
<span class="sd">        of magnitude longer). Fixed quadrature will always take a lot less</span>
<span class="sd">        time. BUT it won&#39;t necessarily work across all samples. For</span>
<span class="sd">        example, 13 points may be fine for a thin layer, but will be</span>
<span class="sd">        atrocious at describing a multilayer with bragg peaks.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structures</span><span class="p">,</span> <span class="n">scales</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bkg</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dq</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span>
                 <span class="n">threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">quad_order</span><span class="o">=</span><span class="mi">17</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threads</span> <span class="o">=</span> <span class="n">threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quad_order</span> <span class="o">=</span> <span class="n">quad_order</span>

        <span class="c1"># all reflectometry models need a scale factor and background. Set</span>
        <span class="c1"># them all to 1 by default.</span>
        <span class="n">pscales</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="s1">&#39;scale factors&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scales</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">scales</span><span class="p">):</span>
            <span class="n">tscales</span> <span class="o">=</span> <span class="n">scales</span>
        <span class="k">elif</span> <span class="n">scales</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scales</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to supply scale factor for each&quot;</span>
                             <span class="s2">&quot; structure&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tscales</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">structures</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="n">tscales</span><span class="p">:</span>
            <span class="n">pscales</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">possibly_create_parameter</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;scale&#39;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_scales</span> <span class="o">=</span> <span class="n">pscales</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bkg</span> <span class="o">=</span> <span class="n">possibly_create_parameter</span><span class="p">(</span><span class="n">bkg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;bkg&#39;</span><span class="p">)</span>

        <span class="c1"># we can optimize the resolution (but this is always overridden by</span>
        <span class="c1"># x_err if supplied. There is therefore possibly no dependence on it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dq</span> <span class="o">=</span> <span class="n">possibly_create_parameter</span><span class="p">(</span><span class="n">dq</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;dq - resolution&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_structures</span> <span class="o">=</span> <span class="n">structures</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_err</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">x_err</span><span class="o">=</span><span class="n">x_err</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameter`</span>

<span class="sd">            - `dq.value == 0`</span>
<span class="sd">               no resolution smearing is employed.</span>
<span class="sd">            - `dq.value &gt; 0`</span>
<span class="sd">               a constant dQ/Q resolution smearing is employed.  For 5%</span>
<span class="sd">               resolution smearing supply 5. However, if `x_err` is supplied to</span>
<span class="sd">               the `model` method, then that overrides any setting reported</span>
<span class="sd">               here.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dq</span>

    <span class="nd">@dq</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dq</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scales</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameter` - all model values are multiplied by</span>
<span class="sd">        this value before the background is added.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scales</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bkg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameter` - linear background added to all</span>
<span class="sd">        model values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bkg</span>

    <span class="nd">@bkg</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bkg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bkg</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="MixedReflectModel.model"><a class="viewcode-back" href="../../../refnx.reflect.html#refnx.reflect.reflect_model.MixedReflectModel.model">[docs]</a>    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_err</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the reflectivity of this model</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float or np.ndarray</span>
<span class="sd">            q values for the calculation.</span>
<span class="sd">        p : refnx.analysis.Parameter, optional</span>
<span class="sd">            parameters required to calculate the model</span>
<span class="sd">        x_err : np.ndarray</span>
<span class="sd">            dq resolution smearing values for the dataset being considered.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reflectivity : np.ndarray</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">pvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_err</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># fallback to what this object was constructed with</span>
            <span class="n">x_err</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dq</span><span class="p">)</span>

        <span class="n">scales</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">scale</span><span class="p">,</span> <span class="n">structure</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">scales</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">reflectivity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                              <span class="n">structure</span><span class="o">.</span><span class="n">slabs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">],</span>
                              <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
                              <span class="n">dq</span><span class="o">=</span><span class="n">x_err</span><span class="p">,</span>
                              <span class="n">threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threads</span><span class="p">,</span>
                              <span class="n">quad_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_order</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bkg</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="MixedReflectModel.lnprob"><a class="viewcode-back" href="../../../refnx.reflect.html#refnx.reflect.reflect_model.MixedReflectModel.lnprob">[docs]</a>    <span class="k">def</span> <span class="nf">lnprob</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Additional log-probability terms for the reflectivity model. Do not</span>
<span class="sd">        include log-probability terms for model parameters, these are</span>
<span class="sd">        automatically calculated elsewhere.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lnprob : float</span>
<span class="sd">            log-probability of structure.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lnprob</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">structure</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structures</span><span class="p">:</span>
            <span class="n">lnprob</span> <span class="o">+=</span> <span class="n">structure</span><span class="o">.</span><span class="n">lnprob</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">lnprob</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.reflect.Structure` - object describing the interface of</span>
<span class="sd">        a reflectometry sample.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structures</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :class:`refnx.analysis.Parameters` - parameters associated with this</span>
<span class="sd">        model.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;instrument parameters&#39;</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bkg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dq</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">p</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">structure</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_structures</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015-2017, Andrew Nelson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>