<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>refnx.analysis.curvefitter &mdash; refnx 0.0.5.dev0+ad01c85 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.0.5.dev0+ad01c85',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="refnx 0.0.5.dev0+ad01c85 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for refnx.analysis.curvefitter</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Sun Dec 21 15:37:29 2014</span>

<span class="sd">@author: Andrew Nelson</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">lmfit</span> <span class="kn">import</span> <span class="n">Minimizer</span><span class="p">,</span> <span class="n">Parameters</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="kn">as</span> <span class="nn">ma</span>
<span class="kn">from</span> <span class="nn">refnx.dataset</span> <span class="kn">import</span> <span class="n">Data1D</span>

<span class="c1"># check for EMCEE</span>
<span class="n">HAS_EMCEE</span> <span class="o">=</span> <span class="bp">False</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">emcee</span> <span class="kn">as</span> <span class="nn">emcee</span>
    <span class="n">HAS_EMCEE</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="n">_MACHEPS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>


<div class="viewcode-block" id="to_parameters"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.to_parameters">[docs]</a><span class="k">def</span> <span class="nf">to_parameters</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">varies</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function to convert sequences into a :class:`lmfit.parameter.Parameters` instance</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p0 : np.ndarray</span>
<span class="sd">        numpy array containing parameter values.</span>
<span class="sd">    varies : bool sequence, optional</span>
<span class="sd">        Specifies whether a parameter is being held or varied.</span>
<span class="sd">    bounds : sequence, optional</span>
<span class="sd">        Tuple of (min, max) pairs specifying the lower and upper bounds for</span>
<span class="sd">        each parameter</span>
<span class="sd">    name : str sequence, optional</span>
<span class="sd">        Name of each parameter</span>
<span class="sd">    expr : str sequence, optional</span>
<span class="sd">        Constraints for each parameter</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    p : lmfit.Parameters instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">varies</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">_varies</span> <span class="o">=</span> <span class="p">[</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">p0</span><span class="o">.</span><span class="n">size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_varies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">varies</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p0</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">lowlim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hilim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">:</span>
            <span class="n">lowlim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">hilim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lowlim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">p0</span><span class="o">.</span><span class="n">size</span>
        <span class="n">hilim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">p0</span><span class="o">.</span><span class="n">size</span>

    <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">p0</span><span class="o">.</span><span class="n">size</span>

    <span class="n">_p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">()</span>
    <span class="c1"># go through and add the parameters</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p0</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="c1"># if the limits are finite and equal, then you shouldn&#39;t be fitting</span>
        <span class="c1"># the parameter. So fix the parameter and set the upper limit to be</span>
        <span class="c1"># slightly larger (otherwise you&#39;ll get an error when setting the</span>
        <span class="c1"># Parameter up)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">lowlim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
            <span class="ow">and</span> <span class="n">hilim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">lowlim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">hilim</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="ow">and</span> <span class="n">lowlim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">hilim</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>

            <span class="n">hilim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">_p0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lowlim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">_varies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="n">_p0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">min</span><span class="o">=</span><span class="n">lowlim</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">max</span><span class="o">=</span><span class="n">hilim</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
              <span class="n">vary</span><span class="o">=</span><span class="n">_varies</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">expr</span><span class="o">=</span><span class="n">expr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">p</span></div>


<div class="viewcode-block" id="varys"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.varys">[docs]</a><span class="k">def</span> <span class="nf">varys</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A convenience function that takes an lmfit.Parameters instance and finds</span>
<span class="sd">    out which ones vary</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parameters : lmfit.Parameters</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    varys: bool, sequence</span>
<span class="sd">        Which parameters are varying</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="o">.</span><span class="n">vary</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span></div>


<div class="viewcode-block" id="exprs"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.exprs">[docs]</a><span class="k">def</span> <span class="nf">exprs</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A convenience function that takes an lmfit.Parameters instance and returns</span>
<span class="sd">    the the constraint expressions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parameters : lmfit.Parameters</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    exprs : list of str</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">expr</span></div>


<div class="viewcode-block" id="values"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.values">[docs]</a><span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A convenience function that takes an lmfit.Parameters instance and returns</span>
<span class="sd">    the values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">param</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>


<div class="viewcode-block" id="names"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.names">[docs]</a><span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="bounds"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.bounds">[docs]</a><span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[(</span><span class="n">params</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">)</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span></div>


<div class="viewcode-block" id="clear_bounds"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.clear_bounds">[docs]</a><span class="k">def</span> <span class="nf">clear_bounds</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="n">params</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">params</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span></div>


<div class="viewcode-block" id="fitfunc"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.fitfunc">[docs]</a><span class="k">def</span> <span class="nf">fitfunc</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A decorator that can be used to say if something is a fitfunc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="o">.</span><span class="n">fitfuncwraps</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="FitFunction"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.FitFunction">[docs]</a><span class="k">class</span> <span class="nc">FitFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract FitFunction class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the FitFunction</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>

    <span class="nd">@abc.abstractmethod</span>
<div class="viewcode-block" id="FitFunction.model"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.FitFunction.model">[docs]</a>    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the predictive model for the fit.</span>
<span class="sd">        Override this method in your own fitfunction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array-like</span>
<span class="sd">            The independent variable for the fit</span>
<span class="sd">        params : lmfit.Parameters</span>
<span class="sd">            The model parameters</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        predictive : np.ndarray</span>
<span class="sd">            The predictive model for the fitfunction.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        `args` and `kws` can be used to fully specify the fit function.</span>
<span class="sd">        Normally you would supply these via when the **FitFunction** object is</span>
<span class="sd">        constructed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;You can&#39;t use the abstract base FitFunction in a&quot;</span>
                           <span class="s2">&quot; real fit&quot;</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="FitFunction.parameter_names"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.FitFunction.parameter_names">[docs]</a>    <span class="k">def</span> <span class="nf">parameter_names</span><span class="p">(</span><span class="n">nparams</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides a set of names for constructing an :class:`lmfit.parameter.Parameters` instance</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nparams: int, optional</span>
<span class="sd">            &gt;= 0 - provide a set of names with length `nparams`</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        names: list</span>
<span class="sd">            names for the lmfit.Parameters instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nparams</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;p</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nparams</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">name</span></div></div>


<div class="viewcode-block" id="CurveFitter"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.CurveFitter">[docs]</a><span class="k">class</span> <span class="nc">CurveFitter</span><span class="p">(</span><span class="n">Minimizer</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    A curvefitting class that extends :class:`lmfit:Minimizer.Minimizer`</span>

<span class="sd">Parameters</span>
<span class="sd">----------</span>

<span class="sd">fitfunc : callable</span>
<span class="sd">    Function calculating the generative model for the fit.  Should have</span>
<span class="sd">    the signature: ``fitfunc(x, params, *fcn_args, **fcn_kws)``. You</span>
<span class="sd">    can also supply a :class:`FitFunction` instance.</span>
<span class="sd">data : sequence, :class:`refnx.dataset.Data1D` instance, str or file-like object</span>
<span class="sd">    A sequence containing the data to be analysed.</span>
<span class="sd">    If `data` is a sequence then:</span>

<span class="sd">        * data[0] - the independent variable (x-data)</span>

<span class="sd">        * data[1] - the dependent (observed) variable (y-data)</span>

<span class="sd">        * data[2] - measured uncertainty in the dependent variable,</span>
<span class="sd">            expressed as a standard deviation.</span>

<span class="sd">    Only data[0] and data[1] are required, data[2] is optional. If data[2]</span>
<span class="sd">    is not specified then the measured uncertainty is set to unity.</span>

<span class="sd">    `data` can also be a :class:`refnx.dataset.Data1D` instance containing the data.</span>
<span class="sd">    If `data` is a string, or file-like object then the string or file-like</span>
<span class="sd">    object refers to a file containing the data. The data will be loaded</span>
<span class="sd">    through the :class:`refnx.dataset.Data1D` constructor.</span>
<span class="sd">params : :class:`lmfit.parameter.Parameters` instance</span>
<span class="sd">    Specifies the parameter set for the fit</span>
<span class="sd">mask : np.ndarray, optional</span>
<span class="sd">    A boolean array with the same shape as `y`.  If `mask is True`</span>
<span class="sd">    then that point is excluded from the residuals calculation.</span>
<span class="sd">fcn_args : tuple, optional</span>
<span class="sd">    Extra parameters required to fully specify fitfunc.</span>
<span class="sd">fcn_kws : dict, optional</span>
<span class="sd">    Extra keyword parameters needed to fully specify fitfunc.</span>
<span class="sd">kws : dict, optional</span>
<span class="sd">    Keywords passed to the minimizer.</span>
<span class="sd">callback : callable, optional</span>
<span class="sd">    A function called at each minimization step. Has the signature:</span>
<span class="sd">    ``callback(params, iter, resid, *args, **kwds)``</span>
<span class="sd">costfun : callable, optional</span>
<span class="sd">    specifies your own cost function to minimize. Has the signature:</span>
<span class="sd">    ``costfun(pars, generative, y, e, *fcn_args, **fcn_kws)`` where `pars`</span>
<span class="sd">    is a `lmfit.Parameters` instance, `generative` is an array returned by</span>
<span class="sd">    `fitfunc`, and `y` and `e` correspond to the `data[1]` and</span>
<span class="sd">    `data[2]` arrays. `costfun` should return a single value. See Notes for</span>
<span class="sd">    further details.</span>
<span class="sd">lnpost : callable, optional</span>
<span class="sd">    specifies your own log-posterior probablility function. This is only</span>
<span class="sd">    relevant applies to the `emcee` method. Has the signature:</span>
<span class="sd">    ``lnpost(pars, generative, y, e, *fcn_args, **fcn_kws)`` where `pars`</span>
<span class="sd">    is a `lmfit.Parameters` instance, `generative` is an array returned by</span>
<span class="sd">    `fitfunc`, and `y` and `e` correspond to the `data[1]` and</span>
<span class="sd">    `data[2]` arrays. `lnpost` should return a single float value. See</span>
<span class="sd">    :meth:`CurveFitter.emcee` for further details.</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">The default cost function for CurveFitter is:</span>

<span class="sd">.. math::</span>
<span class="sd">    \chi^2=\sum \left(\frac{\mathrm{data[1]} - \mathrm{fitfunc}}{\mathrm{data[2]}}\right)^2</span>

<span class="sd">This user defined cost function can be used to specify other cost</span>
<span class="sd">functions for `differential_evolution`, `leastsq`, `least_squares`.</span>

<span class="sd">.. _lmfit.Minimizer: http://lmfit.github.io/lmfit-py/fitting.html#module-Minimizer</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitfunc</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">fcn_args</span><span class="o">=</span><span class="p">(),</span> <span class="n">fcn_kws</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">kws</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">costfun</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">lnpost</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitfunc</span> <span class="o">=</span> <span class="n">fitfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">costfun</span> <span class="o">=</span> <span class="n">costfun</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lnpost</span> <span class="o">=</span> <span class="n">lnpost</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cf_userargs</span> <span class="o">=</span> <span class="n">fcn_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cf_userkws</span> <span class="o">=</span> <span class="n">fcn_kws</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Data1D</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">data</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;str&#39;</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;seek&#39;</span><span class="p">):</span>
            <span class="n">tdata</span> <span class="o">=</span> <span class="n">Data1D</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">tdata</span><span class="o">.</span><span class="n">data</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydata</span> <span class="o">=</span> <span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t decipher what kind of data&quot;</span>
                             <span class="s2">&quot; you were providing.&quot;</span><span class="p">)</span>

        <span class="c1"># have uncertainties have been supplied for each of the data points?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_covar</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ydata</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_covar</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydata</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mask shape should be same as data&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">min_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">kws</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">min_kwds</span> <span class="o">=</span> <span class="n">kws</span>

        <span class="c1"># setup the residual calculator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_resid</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CurveFitter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_resid</span><span class="p">,</span>
                                          <span class="n">params</span><span class="p">,</span>
                                          <span class="n">iter_cb</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                          <span class="n">scale_covar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_covar</span><span class="p">,</span>
                                          <span class="o">**</span><span class="n">min_kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_resid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the _resid attribute, which is a function that</span>
<span class="sd">        evaluates the residuals and model for the system. This</span>
<span class="sd">        method exists because people could update the data after</span>
<span class="sd">        creation of the CurveFitter object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resid</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_parallel_residuals_calculator</span><span class="p">,</span>
                              <span class="n">fitfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fitfunc</span><span class="p">,</span>
                              <span class="n">data_tuple</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">ydata</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">),</span>
                              <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                              <span class="n">fcn_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cf_userargs</span><span class="p">,</span>
                              <span class="n">fcn_kws</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cf_userkws</span><span class="p">,</span>
                              <span class="n">costfun</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">costfun</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">userfcn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The unmasked data, and the mask</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (x, y, e, mask) : data tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ydata</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>

    <span class="nd">@data.setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ydata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_covar</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ydata</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_covar</span> <span class="o">=</span> <span class="bp">True</span>

<div class="viewcode-block" id="CurveFitter.residuals"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.CurveFitter.residuals">[docs]</a>    <span class="k">def</span> <span class="nf">residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the difference between the data and the model. Also known as</span>
<span class="sd">        the objective function. This is a convenience method. Over-riding it</span>
<span class="sd">        will not change a fit.</span>

<span class="sd">        :math:`residuals = (fitfunc - y) / edata`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : lmfit.Parameters instance</span>
<span class="sd">            Specifies the entire parameter set</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        residuals : np.ndarray</span>
<span class="sd">            The difference between the data and the model.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This method should only return the points that are not masked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>

        <span class="n">params</span><span class="o">.</span><span class="n">update_constraints</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_resid</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resid</span><span class="p">(</span><span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="CurveFitter.model"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.CurveFitter.model">[docs]</a>    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the model. This is a convenience method. Over-riding it will</span>
<span class="sd">        not change a fit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : lmfit.Parameters instance</span>
<span class="sd">            Specifies the entire parameter set</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model : array_like</span>
<span class="sd">            The model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>

        <span class="n">params</span><span class="o">.</span><span class="n">update_constraints</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_resid</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resid</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="CurveFitter.fit"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.CurveFitter.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;leastsq&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fits the dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            Name of the fitting method to use.</span>
<span class="sd">            One of:</span>

<span class="sd">            - &#39;leastsq&#39;                -    Levenberg-Marquardt (default)</span>
<span class="sd">            - &#39;nelder&#39;                 -    Nelder-Mead</span>
<span class="sd">            - &#39;lbfgsb&#39;                 -    L-BFGS-B</span>
<span class="sd">            - &#39;powell&#39;                 -    Powell</span>
<span class="sd">            - &#39;cg&#39;                     -    Conjugate-Gradient</span>
<span class="sd">            - &#39;newton&#39;                 -    Newton-CG</span>
<span class="sd">            - &#39;cobyla&#39;                 -    Cobyla</span>
<span class="sd">            - &#39;tnc&#39;                    -    Truncate Newton</span>
<span class="sd">            - &#39;trust-ncg&#39;              -    Trust Newton-CGn</span>
<span class="sd">            - &#39;dogleg&#39;                 -    Dogleg</span>
<span class="sd">            - &#39;slsqp&#39;                  -    Sequential Linear Squares Programming</span>
<span class="sd">            - &#39;differential_evolution&#39; -    differential evolution</span>

<span class="sd">        params : Parameters, optional</span>
<span class="sd">            parameters to use as starting values</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        result : lmfit.MinimizerResult</span>
<span class="sd">            Result object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_resid</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">params</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="CurveFitter.emcee"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.CurveFitter.emcee">[docs]</a>    <span class="k">def</span> <span class="nf">emcee</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">nwalkers</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">burn</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">thin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
              <span class="n">ntemps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">reuse_sampler</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Bayesian sampling of the posterior distribution for the parameters</span>
<span class="sd">        using the `emcee` Markov Chain Monte Carlo package. By default the</span>
<span class="sd">        method assumes that the prior is Uniform. To implement non-uniform</span>
<span class="sd">        priors use the `lnpost` kwd when constructing the CurveFitter. You</span>
<span class="sd">        need to have `emcee` installed to use this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        params : lmfit.Parameters, optional</span>
<span class="sd">            Parameters to use as starting point. If this is not specified</span>
<span class="sd">            then the Parameters used to initialise the CurveFitter object are</span>
<span class="sd">            used.</span>
<span class="sd">        steps : int, optional</span>
<span class="sd">            How many samples you would like to draw from the posterior</span>
<span class="sd">            distribution for each of the walkers?</span>
<span class="sd">        nwalkers : int, optional</span>
<span class="sd">            Should be set so :math:`nwalkers &gt;&gt; nvarys`, where `nvarys` are</span>
<span class="sd">            the number of parameters being varied during the fit.</span>
<span class="sd">            &quot;Walkers are the members of the ensemble. They are almost like</span>
<span class="sd">            separate Metropolis-Hastings chains but, of course, the proposal</span>
<span class="sd">            distribution for a given walker depends on the positions of all</span>
<span class="sd">            the other walkers in the ensemble.&quot; - from the `emcee` webpage.</span>
<span class="sd">        burn : int, optional</span>
<span class="sd">            Discard this many samples from the start of the sampling regime.</span>
<span class="sd">        thin : int, optional</span>
<span class="sd">            Only accept 1 in every `thin` samples.</span>
<span class="sd">        ntemps : int, optional</span>
<span class="sd">            If `ntemps &gt; 1` perform a Parallel Tempering.</span>
<span class="sd">        pos : np.ndarray, optional</span>
<span class="sd">            Specify the initial positions for the sampler.  If `ntemps == 1`</span>
<span class="sd">            then `pos.shape` should be `(nwalkers, nvarys)`. Otherwise,</span>
<span class="sd">            `(ntemps, nwalkers, nvarys)`. You can also initialise using a</span>
<span class="sd">            previous chain that had the same `ntemps`, `nwalkers` and</span>
<span class="sd">            `nvarys`. Note that `nvarys` may be one larger than you expect it</span>
<span class="sd">            to be if your `userfcn` returns an array and `is_weighted is</span>
<span class="sd">            False`.</span>
<span class="sd">        reuse_sampler : bool, optional</span>
<span class="sd">            If you have already run `emcee` on a given `Minimizer` object then</span>
<span class="sd">            it possesses an internal ``sampler`` attribute. You can continue to</span>
<span class="sd">            draw from the same sampler (retaining the chain history) if you set</span>
<span class="sd">            this option to `True`. Otherwise a new sampler is created. The</span>
<span class="sd">            `nwalkers`, `ntemps`, `pos`, and `params` keywords are ignored with</span>
<span class="sd">            this option.</span>
<span class="sd">            **Important**: the Parameters used to create the sampler must not</span>
<span class="sd">            change in-between calls to `emcee`. Alteration of Parameters</span>
<span class="sd">            would include changed ``min``, ``max``, ``vary`` and ``expr``</span>
<span class="sd">            attributes. This may happen, for example, if you use an altered</span>
<span class="sd">            Parameters object and call the `minimize` method in-between calls</span>
<span class="sd">            to `emcee`.</span>
<span class="sd">        workers : Pool-like or int, optional</span>
<span class="sd">            For parallelization of sampling.  It can be any Pool-like object</span>
<span class="sd">            with a map method that follows the same calling sequence as the</span>
<span class="sd">            built-in `map` function. If int is given as the argument, then a</span>
<span class="sd">            multiprocessing-based pool is spawned internally with the</span>
<span class="sd">            corresponding number of parallel processes. &#39;mpi4py&#39;-based</span>
<span class="sd">            parallelization and &#39;joblib&#39;-based parallelization pools can also</span>
<span class="sd">            be used here. **Note**: because of multiprocessing overhead it may</span>
<span class="sd">            only be worth parallelising if the objective function is expensive</span>
<span class="sd">            to calculate, or if there are a large number of objective</span>
<span class="sd">            evaluations per step (`ntemps * nwalkers * nvarys`).</span>
<span class="sd">        seed : int or `np.random.RandomState`, optional</span>
<span class="sd">            If `seed` is an int, a new `np.random.RandomState` instance is used,</span>
<span class="sd">            seeded with `seed`.</span>
<span class="sd">            If `seed` is already a `np.random.RandomState` instance, then that</span>
<span class="sd">            `np.random.RandomState` instance is used.</span>
<span class="sd">            Specify `seed` for repeatable minimizations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result: MinimizerResult</span>
<span class="sd">            MinimizerResult object containing updated params, statistics,</span>
<span class="sd">            etc. The `MinimizerResult` also contains the ``chain``,</span>
<span class="sd">            ``flatchain`` and ``lnprob`` attributes. The ``chain``</span>
<span class="sd">            and ``flatchain`` attributes contain the samples and have the shape</span>
<span class="sd">            `(nwalkers, (steps - burn) // thin, nvarys)` or</span>
<span class="sd">            `(ntemps, nwalkers, (steps - burn) // thin, nvarys)`,</span>
<span class="sd">            depending on whether Parallel tempering was used or not.</span>
<span class="sd">            `nvarys` is the number of parameters that are allowed to vary.</span>
<span class="sd">            The ``flatchain`` attribute is a `pandas.DataFrame` of the</span>
<span class="sd">            flattened chain, `chain.reshape(-1, nvarys)`. To access flattened</span>
<span class="sd">            chain values for a particular parameter use</span>
<span class="sd">            `result.flatchain[parname]`. The ``lnprob`` attribute contains the</span>
<span class="sd">            log probability for each sample in ``chain``. The sample with the</span>
<span class="sd">            highest probability corresponds to the maximum likelihood estimate.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This method samples the posterior distribution of the parameters using</span>
<span class="sd">        Markov Chain Monte Carlo.  To do so it needs to calculate the</span>
<span class="sd">        log-posterior probability of the model parameters, `F`, given the data,</span>
<span class="sd">        `D`, :math:`\ln p(F_{true} | D)`. This &#39;posterior probability&#39; is</span>
<span class="sd">        calculated as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \ln p(F_{true} | D) \propto \ln p(D | F_{true}) + \ln p(F_{true})</span>

<span class="sd">        where :math:`\ln p(D | F_{true})` is the &#39;log-likelihood&#39; and</span>
<span class="sd">        :math:`\ln p(F_{true})` is the &#39;log-prior&#39;. The default log-prior</span>
<span class="sd">        encodes prior information already known about the model. This method</span>
<span class="sd">        assumes that the log-prior probability is `-np.inf` (impossible) if the</span>
<span class="sd">        one of the parameters is outside its limits. The log-prior probability</span>
<span class="sd">        term is zero if all the parameters are inside their bounds (known as a</span>
<span class="sd">        uniform prior). The default log-likelihood function is given by [1]_:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \ln p(D|F_{true}) = -\frac{1}{2}\sum_n \left[\frac{\left(g_n(F_{true}) - D_n \right)^2}{s_n^2}+\ln (2\pi s_n^2)\right]</span>

<span class="sd">        The first summand in the square brackets represents the residual for a</span>
<span class="sd">        given datapoint (:math:`g` being the generative model) . This term</span>
<span class="sd">        represents :math:`\chi^2` when summed over all datapoints.</span>

<span class="sd">        It is also possible to calculate your own log-posterior probability, by</span>
<span class="sd">        constructing the CurveFitter object with a `lnpost` function. This</span>
<span class="sd">        will allow you to use non-uniform priors, etc. The `lnpost` function</span>
<span class="sd">        has the signature:</span>
<span class="sd">        ``lnpost(pars, generative, y, e, *fcn_args, **fcn_kws)``. You should</span>
<span class="sd">        return a single float from this `lnpost` function</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] http://dan.iel.fm/emcee/current/user/line/</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_resid</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_weighted</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">lnpost</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># get the proper log-likelihood if you have</span>
                <span class="c1"># uncertainties</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_resid</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_parallel_likelihood_calculator</span><span class="p">,</span>
                                      <span class="n">fitfunc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fitfunc</span><span class="p">,</span>
                                      <span class="n">data_tuple</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">ydata</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">edata</span><span class="p">),</span>
                                      <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span>
                                      <span class="n">fcn_args</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cf_userargs</span><span class="p">,</span>
                                      <span class="n">fcn_kws</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cf_userkws</span><span class="p">,</span>
                                      <span class="n">lnpost</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lnpost</span>
                                      <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">userfcn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>

            <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CurveFitter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">emcee</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">steps</span><span class="p">,</span>
                                                    <span class="n">nwalkers</span><span class="o">=</span><span class="n">nwalkers</span><span class="p">,</span>
                                                    <span class="n">burn</span><span class="o">=</span><span class="n">burn</span><span class="p">,</span>
                                                    <span class="n">thin</span><span class="o">=</span><span class="n">thin</span><span class="p">,</span> <span class="n">ntemps</span><span class="o">=</span><span class="n">ntemps</span><span class="p">,</span>
                                                    <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
                                                    <span class="n">reuse_sampler</span><span class="o">=</span><span class="n">reuse_sampler</span><span class="p">,</span>
                                                    <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span>
                                                    <span class="n">float_behavior</span><span class="o">=</span><span class="s1">&#39;posterior&#39;</span><span class="p">,</span>
                                                    <span class="n">is_weighted</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_weighted</span><span class="p">,</span>
                                                    <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_resid</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">params</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the truth that the fit is weighted by measurement uncertainties</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_covar</span>

    <span class="k">def</span> <span class="nf">_resampleMC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;differential_evolution&#39;</span><span class="p">,</span>
                    <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Monte Carlo Resampling. Refits synthesised data `samples` times. Each</span>
<span class="sd">        synthesised dataset is created from the original dataset by adding</span>
<span class="sd">        Gaussian based on the size of the datapoint:</span>
<span class="sd">        ``synth = y + e * np.random.randn(y.size)``</span>
<span class="sd">        The parameters from each of these fits should be distributed in a way</span>
<span class="sd">        that is related to their statistical uncertainty.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples : int</span>
<span class="sd">            Number of synthesis/refit cycles.</span>
<span class="sd">        method : str</span>
<span class="sd">            Minimisation method. See the `fit` method for other options.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : lmfit.MinimizerResult</span>
<span class="sd">            Result object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is currently semi-private and may disappear in future</span>
<span class="sd">        releases. The uncertainties are estimated as half of the 15.87, 84.13</span>
<span class="sd">        percentiles. The parameter value is estimated as the 50 th percentile.</span>
<span class="sd">        The `result` instance also contains the `mc` attribute which is an</span>
<span class="sd">        array the contains the result of each sample. This array has shape</span>
<span class="sd">        `(samples, len(result.var_names))` (i.e. only the varying parameters</span>
<span class="sd">        are given).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># data does</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_covar</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;To MC resample the data has to have errorbars&quot;</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

        <span class="n">tparams</span> <span class="o">=</span> <span class="n">params</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prepare_fit</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">tparams</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">params</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">mc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">samples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">var_names</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
                <span class="c1"># synthesize a dataset</span>
                <span class="n">ne</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">e</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ydata</span> <span class="o">=</span> <span class="n">ne</span>

                <span class="c1"># update the _resid attribute</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_resid</span><span class="p">()</span>

                <span class="c1"># do a fit</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>

                <span class="c1"># append values from fit</span>
                <span class="k">for</span> <span class="n">idx2</span><span class="p">,</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
                    <span class="n">mc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ydata</span> <span class="o">=</span> <span class="n">y</span>

        <span class="n">quantiles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="p">[</span><span class="mf">15.87</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">84.13</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
            <span class="n">std_l</span><span class="p">,</span> <span class="n">median</span><span class="p">,</span> <span class="n">std_u</span> <span class="o">=</span> <span class="n">quantiles</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">params</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">median</span>
            <span class="n">params</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">std_u</span> <span class="o">-</span> <span class="n">std_l</span><span class="p">)</span>
            <span class="n">params</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">correl</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">params</span><span class="o">.</span><span class="n">update_constraints</span><span class="p">()</span>

        <span class="c1"># work out correlation coefficients</span>
        <span class="n">corrcoefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">mc</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">var_name2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">var_names</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span><span class="o">.</span><span class="n">correl</span><span class="p">[</span><span class="n">var_name2</span><span class="p">]</span> <span class="o">=</span> <span class="n">corrcoefs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="n">output</span><span class="o">.</span><span class="n">mc</span> <span class="o">=</span> <span class="n">mc</span>
        <span class="n">output</span><span class="o">.</span><span class="n">errorbars</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">output</span><span class="o">.</span><span class="n">nvarys</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="GlobalFitter"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.GlobalFitter">[docs]</a><span class="k">class</span> <span class="nc">GlobalFitter</span><span class="p">(</span><span class="n">CurveFitter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simultaneous curvefitting of multiple datasets</span>

<span class="sd">    fitters : sequence of :class:`refnx.analysis.curvefitter.CurveFitter` instances</span>
<span class="sd">        Contains all the fitters and fitfunctions for the global fit.</span>
<span class="sd">    constraints : str sequence, optional</span>
<span class="sd">        Of the type &#39;dN:param_name = constraint&#39;. Sets a constraint</span>
<span class="sd">        expression for the parameter `param_name` in dataset N. The</span>
<span class="sd">        constraint &#39;d2:scale = 2 * d0:back&#39; constrains the `scale`</span>
<span class="sd">        parameter in dataset 2 to be twice the `back` parameter in</span>
<span class="sd">        dataset 0.</span>
<span class="sd">        **Important** For a parameter (`d2:scale` in this example) to be</span>
<span class="sd">        constrained by this mechanism it must not have any pre-existing</span>
<span class="sd">        constraints within its individual fitter. If there are pre-existing</span>
<span class="sd">        constraints then those are honoured, and constraints specified here are</span>
<span class="sd">        ignored.</span>
<span class="sd">    kws : dict, optional</span>
<span class="sd">        Extra minimization keywords to be passed to the minimizer of choice.</span>
<span class="sd">    callback : callable, optional</span>
<span class="sd">        Function called at each step of the minimization. Has the signature</span>
<span class="sd">        ``callback(params, iter, resid)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fitters</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="p">(),</span> <span class="n">kws</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">callback</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="n">min_kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">kws</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">min_kwds</span> <span class="o">=</span> <span class="n">kws</span>

        <span class="k">for</span> <span class="n">fitter</span> <span class="ow">in</span> <span class="n">fitters</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fitter</span><span class="p">,</span> <span class="n">CurveFitter</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All items in curve_fitter_list must be &#39;</span>
                                 <span class="s1">&#39;instances of CurveFitter&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitters</span> <span class="o">=</span> <span class="n">fitters</span>

        <span class="c1"># new_param_reference.keys() will be the parameter names for the</span>
        <span class="c1"># composite fitting problem. new_param_reference.values() are the</span>
        <span class="c1"># (i, original_name) of the individual Parameter(s) from the individual</span>
        <span class="c1"># fitting problem, where i is the index of the fitter it&#39;s in.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">new_param_reference</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fitter</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fitters</span><span class="p">):</span>
            <span class="c1"># add all the parameters for a given dataset</span>
            <span class="c1"># the parameters are all given new names:</span>
            <span class="c1"># abc -&gt; abc_d0</span>
            <span class="c1"># parameter `abc` in dataset 0 becomes abc_d0</span>
            <span class="n">new_names</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">old_name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">fitter</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="n">old_name</span> <span class="o">+</span> <span class="s1">&#39;_d</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span>
                <span class="n">new_names</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_name</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">new_param_reference</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

                <span class="n">p</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_name</span><span class="p">,</span>
                      <span class="n">value</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                      <span class="n">vary</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">vary</span><span class="p">,</span>
                      <span class="nb">min</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
                      <span class="nb">max</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                      <span class="n">expr</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

            <span class="c1"># if there are any expressions they have to be updated</span>
            <span class="c1"># iterate through all the parameters in the dataset</span>
            <span class="n">old_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">new_names</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">fitter</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">expr</span>
                <span class="n">new_name</span> <span class="o">=</span> <span class="n">old_names</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="c1"># if it&#39;s got an expression you&#39;ll have to update it</span>
                <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c1"># see if any of the old names are in there.</span>
                    <span class="k">for</span> <span class="n">old_name</span> <span class="ow">in</span> <span class="n">old_names</span><span class="p">:</span>
                        <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">old_name</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">regex</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
                            <span class="n">new_expr_name</span> <span class="o">=</span> <span class="n">old_names</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>
                            <span class="n">new_expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">new_expr_name</span><span class="p">)</span>
                            <span class="n">p</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">new_expr</span>

        <span class="c1"># now set constraints/linkages up. They&#39;re specified as</span>
        <span class="c1"># dN:param_name = constraint</span>
        <span class="n">dp_string</span> <span class="o">=</span> <span class="s1">&#39;d([0-9]+):([0-9a-zA-Z_]+)&#39;</span>
        <span class="n">parameter_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dp_string</span> <span class="o">+</span> <span class="s1">&#39;\s*=\s*(.*)&#39;</span><span class="p">)</span>
        <span class="n">constraint_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">dp_string</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">parameter_regex</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">constraint</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
                <span class="n">dataset_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">param_name</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">const</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

                <span class="c1"># see if this parameter is in the list of parameters</span>
                <span class="n">par_to_be_constrained</span> <span class="o">=</span> <span class="n">param_name</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;_d</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">dataset_num</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">par_to_be_constrained</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># if it already has a constraint / expr don&#39;t override it</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">par_to_be_constrained</span><span class="p">]</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">warning_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> already has a constraint within its&quot;</span>
                                   <span class="s2">&quot; individual fitter. The </span><span class="si">%s</span><span class="s2"> constraint&quot;</span>
                                   <span class="s2">&quot;is ignored.&quot;</span>
                                   <span class="o">%</span> <span class="p">(</span><span class="n">par_to_be_constrained</span><span class="p">,</span> <span class="n">constraint</span><span class="p">))</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warning_msg</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># now search for fitters mentioned in constraint</span>
                <span class="n">d_mentioned</span> <span class="o">=</span> <span class="n">constraint_regex</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">d_mentioned</span><span class="p">:</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;_d</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                    <span class="c1"># see if the dataset mentioned is actually a parameter</span>
                    <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_param_reference</span><span class="p">:</span>
                        <span class="c1"># if it is, then rename it.</span>
                        <span class="n">const</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;d&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                              <span class="n">new_name</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">const</span> <span class="o">=</span> <span class="bp">None</span>
                        <span class="k">break</span>

                <span class="n">p</span><span class="p">[</span><span class="n">par_to_be_constrained</span><span class="p">]</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">const</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="p">[</span><span class="n">fitter</span><span class="o">.</span><span class="n">xdata</span> <span class="k">for</span> <span class="n">fitter</span> <span class="ow">in</span> <span class="n">fitters</span><span class="p">]</span>
        <span class="n">ydata</span> <span class="o">=</span> <span class="p">[</span><span class="n">fitter</span><span class="o">.</span><span class="n">ydata</span> <span class="k">for</span> <span class="n">fitter</span> <span class="ow">in</span> <span class="n">fitters</span><span class="p">]</span>
        <span class="n">edata</span> <span class="o">=</span> <span class="p">[</span><span class="n">fitter</span><span class="o">.</span><span class="n">edata</span> <span class="k">for</span> <span class="n">fitter</span> <span class="ow">in</span> <span class="n">fitters</span><span class="p">]</span>

        <span class="n">original_params</span> <span class="o">=</span> <span class="p">[</span><span class="n">fitter</span><span class="o">.</span><span class="n">params</span> <span class="k">for</span> <span class="n">fitter</span> <span class="ow">in</span> <span class="n">fitters</span><span class="p">]</span>
        <span class="n">original_userargs</span> <span class="o">=</span> <span class="p">[</span><span class="n">fitter</span><span class="o">.</span><span class="n">userargs</span> <span class="k">for</span> <span class="n">fitter</span> <span class="ow">in</span> <span class="n">fitters</span><span class="p">]</span>
        <span class="n">original_kws</span> <span class="o">=</span> <span class="p">[</span><span class="n">fitter</span><span class="o">.</span><span class="n">userkws</span> <span class="k">for</span> <span class="n">fitter</span> <span class="ow">in</span> <span class="n">fitters</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fitfunc</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_parallel_global_fitfunc</span><span class="p">,</span>
                <span class="n">fitfuncs</span><span class="o">=</span><span class="p">[</span><span class="n">fitter</span><span class="o">.</span><span class="n">fitfunc</span> <span class="k">for</span> <span class="n">fitter</span> <span class="ow">in</span> <span class="n">fitters</span><span class="p">],</span>
                <span class="n">new_param_reference</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">new_param_reference</span><span class="p">,</span>
                <span class="n">original_params</span><span class="o">=</span><span class="n">original_params</span><span class="p">,</span>
                <span class="n">original_userargs</span><span class="o">=</span><span class="n">original_userargs</span><span class="p">,</span>
                <span class="n">original_kws</span><span class="o">=</span><span class="n">original_kws</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">GlobalFitter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fitfunc</span><span class="p">,</span>
                                           <span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">ydata</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">edata</span><span class="p">)),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                                           <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
                                           <span class="n">kws</span><span class="o">=</span><span class="n">min_kwds</span><span class="p">)</span>

<div class="viewcode-block" id="GlobalFitter.model"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.GlobalFitter.model">[docs]</a>    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the model. This method is provided for convenience purposes</span>
<span class="sd">        and is not used during a fit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params: lmfit.Parameters</span>
<span class="sd">            Specifies the entire parameter set, across all the datasets</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model : np.ndarray</span>
<span class="sd">            The model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>

        <span class="n">params</span><span class="o">.</span><span class="n">update_constraints</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fitfunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalFitter.residuals"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.GlobalFitter.residuals">[docs]</a>    <span class="k">def</span> <span class="nf">residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the difference between the data and the model. Also known as</span>
<span class="sd">        the objective function.  This is a convenience method. Over-riding it</span>
<span class="sd">        does not change the fitting process.</span>
<span class="sd">        residuals = (fitfunc - y) / edata</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params: lmfit.Parameters</span>
<span class="sd">            Specifies the entire parameter set</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        residuals : np.ndarray</span>
<span class="sd">            The difference between the data and the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>

        <span class="n">params</span><span class="o">.</span><span class="n">update_constraints</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">GlobalFitter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">residuals</span><span class="p">(</span><span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="GlobalFitter.distribute_params"><a class="viewcode-back" href="../../../refnx.analysis.html#refnx.analysis.curvefitter.GlobalFitter.distribute_params">[docs]</a>    <span class="k">def</span> <span class="nf">distribute_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience function for re-distributing global parameter values</span>
<span class="sd">        back into each of the original `CurveFitter.params` attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">fitter_i</span><span class="p">,</span> <span class="n">original_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_param_reference</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">original_params</span><span class="p">[</span><span class="n">fitter_i</span><span class="p">][</span><span class="n">original_name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">_getval</span><span class="p">()</span></div></div>


<span class="k">def</span> <span class="nf">_parallel_residuals_calculator</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">fitfunc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">data_tuple</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                   <span class="n">mask</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fcn_args</span><span class="o">=</span><span class="p">(),</span> <span class="n">fcn_kws</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                   <span class="n">model</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">costfun</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Objective function calculating the residuals for a curvefit. This is a</span>
<span class="sd">    separate function and not a method in CurveFitter to allow for</span>
<span class="sd">    multiprocessing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kws</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">fcn_kws</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">kws</span> <span class="o">=</span> <span class="n">fcn_kws</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">data_tuple</span>

    <span class="n">resid</span> <span class="o">=</span> <span class="n">fitfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">fcn_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">model</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">resid</span>

    <span class="k">if</span> <span class="n">costfun</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">costfun</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">fcn_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>

    <span class="n">resid</span> <span class="o">-=</span> <span class="n">y</span>
    <span class="n">resid</span> <span class="o">/=</span> <span class="n">e</span>

    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">resid_ma</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resid_ma</span><span class="p">[</span><span class="o">~</span><span class="n">resid_ma</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">resid</span>


<span class="k">def</span> <span class="nf">_parallel_likelihood_calculator</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">fitfunc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">data_tuple</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                    <span class="n">mask</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fcn_args</span><span class="o">=</span><span class="p">(),</span> <span class="n">fcn_kws</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                    <span class="n">lnpost</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function calculating the log-likelihood for a curvefit. This is a</span>
<span class="sd">    separate function and not a method in CurveFitter to allow for</span>
<span class="sd">    multiprocessing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kws</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">fcn_kws</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">kws</span> <span class="o">=</span> <span class="n">fcn_kws</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">data_tuple</span>

    <span class="n">resid</span> <span class="o">=</span> <span class="n">fitfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">fcn_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lnpost</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lnpost</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="o">*</span><span class="n">fcn_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resid</span> <span class="o">-=</span> <span class="n">y</span>
        <span class="n">resid</span> <span class="o">/=</span> <span class="n">e</span>
        <span class="n">resid</span> <span class="o">*=</span> <span class="n">resid</span>

        <span class="n">resid</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">e</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">resid_ma</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">resid</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">resid_ma</span><span class="p">[</span><span class="o">~</span><span class="n">resid_ma</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">resid</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_parallel_global_fitfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">fitfuncs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                             <span class="n">new_param_reference</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_params</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                             <span class="n">original_userargs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">original_kws</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit function calculating a predictive model for a curvefit. This is a</span>
<span class="sd">    separate function and not a method in CurveFitter to allow for</span>
<span class="sd">    multiprocessing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># distribute params</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">fitter_i</span><span class="p">,</span> <span class="n">original_name</span> <span class="o">=</span> <span class="n">new_param_reference</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">original_params</span><span class="p">[</span><span class="n">fitter_i</span><span class="p">][</span><span class="n">original_name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">_getval</span><span class="p">()</span>

    <span class="n">model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fitfunc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fitfuncs</span><span class="p">):</span>
        <span class="n">model_i</span> <span class="o">=</span> <span class="n">fitfuncs</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                              <span class="n">original_params</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                              <span class="o">*</span><span class="n">original_userargs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                              <span class="o">**</span><span class="n">original_kws</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">model</span><span class="p">,</span>
                          <span class="n">model_i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">lmfit</span> <span class="kn">import</span> <span class="n">fit_report</span>

    <span class="k">def</span> <span class="nf">gauss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates a Gaussian model&quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">valuesdict</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">xdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)]</span>

    <span class="n">temp_pars</span> <span class="o">=</span> <span class="n">to_parameters</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
    <span class="n">pars</span> <span class="o">=</span> <span class="n">to_parameters</span><span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>

    <span class="n">ydata</span> <span class="o">=</span> <span class="n">gauss</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">temp_pars</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">xdata</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">CurveFitter</span><span class="p">(</span><span class="n">gauss</span><span class="p">,</span> <span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">),</span> <span class="n">pars</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="n">fit_report</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">params</span><span class="p">))</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Andrew Nelson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>