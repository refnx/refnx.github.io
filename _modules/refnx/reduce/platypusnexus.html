
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>refnx.reduce.platypusnexus &#8212; refnx 0.0.13.dev0+8d6438f documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.0.13.dev0+8d6438f',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for refnx.reduce.platypusnexus</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">gmtime</span><span class="p">,</span> <span class="n">strftime</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="k">import</span> <span class="n">contextmanager</span>

<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">leastsq</span><span class="p">,</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">t</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">h5py</span>

<span class="kn">from</span> <span class="nn">refnx.reduce.peak_utils</span> <span class="k">import</span> <span class="n">peak_finder</span><span class="p">,</span> <span class="n">centroid</span>
<span class="kn">import</span> <span class="nn">refnx.util.general</span> <span class="k">as</span> <span class="nn">general</span>
<span class="kn">from</span> <span class="nn">refnx.util.general</span> <span class="k">import</span> <span class="n">resolution_double_chopper</span><span class="p">,</span> <span class="n">_dict_compare</span>
<span class="kn">import</span> <span class="nn">refnx.util.ErrorProp</span> <span class="k">as</span> <span class="nn">EP</span>
<span class="kn">from</span> <span class="nn">refnx.reduce.parabolic_motion</span> <span class="k">import</span> <span class="n">find_trajectory</span><span class="p">,</span> <span class="n">y_deflection</span>
<span class="kn">from</span> <span class="nn">refnx.reduce.event</span> <span class="k">import</span> <span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">process_event_stream</span><span class="p">,</span>
                                <span class="n">framebins_to_frames</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">refnx.reduce.rebin</span> <span class="k">import</span> <span class="n">rebin</span><span class="p">,</span> <span class="n">rebin_along_axis</span>


<span class="c1"># detector y pixel spacing in mm per pixel</span>
<span class="n">Y_PIXEL_SPACING</span> <span class="o">=</span> <span class="mf">1.177</span>

<span class="n">disc_openings</span> <span class="o">=</span> <span class="p">(</span><span class="mf">60.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">25.</span><span class="p">,</span> <span class="mf">60.</span><span class="p">)</span>
<span class="n">O_C1d</span><span class="p">,</span> <span class="n">O_C2d</span><span class="p">,</span> <span class="n">O_C3d</span><span class="p">,</span> <span class="n">O_C4d</span> <span class="o">=</span> <span class="n">disc_openings</span>
<span class="n">O_C1</span><span class="p">,</span> <span class="n">O_C2</span><span class="p">,</span> <span class="n">O_C3</span><span class="p">,</span> <span class="n">O_C4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">disc_openings</span><span class="p">)</span>

<span class="n">DISCRADIUS</span> <span class="o">=</span> <span class="mf">350.</span>
<span class="n">EXTENT_MULT</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">PIXEL_OFFSET</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">spectrum_template</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;</span>
<span class="s2">&lt;REFroot xmlns=&quot;&quot;&gt;</span>
<span class="s2">&lt;REFentry time=&quot;$time&quot;&gt;</span>
<span class="s2">&lt;Title&gt;$title&lt;/Title&gt;</span>
<span class="s2">&lt;REFdata axes=&quot;lambda&quot; rank=&quot;1&quot; type=&quot;POINT&quot;</span><span class="se">\</span>
<span class="s2"> spin=&quot;UNPOLARISED&quot; dim=&quot;$n_spectra&quot;&gt;</span>
<span class="s2">&lt;Run filename=&quot;$runnumber&quot;/&gt;</span>
<span class="s2">&lt;R uncertainty=&quot;dR&quot;&gt;$r&lt;/R&gt;</span>
<span class="s2">&lt;lambda uncertainty=&quot;dlambda&quot; units=&quot;1/A&quot;&gt;$lmda&lt;/lambda&gt;</span>
<span class="s2">&lt;dR type=&quot;SD&quot;&gt;$dr&lt;/dR&gt;</span>
<span class="s2">&lt;dlambda type=&quot;_FWHM&quot; units=&quot;1/A&quot;&gt;$dlmda&lt;/dlambda&gt;</span>
<span class="s2">&lt;/REFdata&gt;</span>
<span class="s2">&lt;/REFentry&gt;</span>
<span class="s2">&lt;/REFroot&gt;&quot;&quot;&quot;</span>


<div class="viewcode-block" id="catalogue"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.catalogue">[docs]</a><span class="k">def</span> <span class="nf">catalogue</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract interesting information from Platypus NeXUS files.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    start : int</span>
<span class="sd">        start cataloguing from this run number.</span>
<span class="sd">    stop : int</span>
<span class="sd">        stop cataloguing at this run number</span>
<span class="sd">    path : str, optional</span>
<span class="sd">        path specifying location of NeXUS files</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    catalog : pd.DataFrame</span>
<span class="sd">        Dataframe containing interesting parameters from Platypus Nexus files</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">info</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">,</span> <span class="s1">&#39;end_time&#39;</span><span class="p">,</span> <span class="s1">&#39;sample_name&#39;</span><span class="p">,</span> <span class="s1">&#39;ss1vg&#39;</span><span class="p">,</span> <span class="s1">&#39;ss2vg&#39;</span><span class="p">,</span> <span class="s1">&#39;ss3vg&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ss4vg&#39;</span><span class="p">,</span> <span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="s1">&#39;twotheta&#39;</span><span class="p">,</span> <span class="s1">&#39;bm1_counts&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;daq_dirname&#39;</span><span class="p">,</span>
            <span class="s1">&#39;start_time&#39;</span><span class="p">]</span>
    <span class="n">run_number</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">info</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">pn</span> <span class="o">=</span> <span class="n">PlatypusNexus</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">number_datafile</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">cat</span> <span class="o">=</span> <span class="n">pn</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">cat</span>
        <span class="n">run_number</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">cat</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bytes</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

            <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">run_number</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="Catalogue"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.Catalogue">[docs]</a><span class="k">class</span> <span class="nc">Catalogue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract relevant parts of a NeXus file for reflectometry reduction</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract relevant parts of a NeXus file for reflectometry reduction</span>
<span class="sd">        Access information via dict access, e.g. cat[&#39;detector&#39;].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5d - HDF5 file handle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">h5d</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="o">.</span><span class="n">filename</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;end_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/end_time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/detector/start_time&#39;</span><span class="p">][:])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># start times don&#39;t exist in this file</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;sample_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/sample/name&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ss1vg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/slits/first/vertical/gap&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ss2vg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/slits/second/vertical/gap&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ss3vg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/slits/third/vertical/gap&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ss4vg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/slits/fourth/vertical/gap&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ss1hg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/slits/first/horizontal/gap&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ss2hg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/slits/second/horizontal/gap&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ss3hg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/slits/third/horizontal/gap&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;ss4hg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/slits/fourth/horizontal/gap&#39;</span><span class="p">][:]</span>

        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/parameters/omega&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;twotheta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/parameters/twotheta&#39;</span><span class="p">][:]</span>

        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;detector&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/data/hmm&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;sth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/sample/sth&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;bm1_counts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/monitor/bm1_counts&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;total_counts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/detector/total_counts&#39;</span><span class="p">][:]</span>

        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/detector/time&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/parameters/mode&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">event_directory_name</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
                <span class="s1">&#39;entry1/instrument/detector/daq_dirname&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;daq_dirname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_directory_name</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># daq_dirname doesn&#39;t exist in this file</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;daq_dirname&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;t_bins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/data/time_of_flight&#39;</span><span class="p">][:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;x_bins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/data/x_bin&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;y_bins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/data/y_bin&#39;</span><span class="p">][:]</span>

        <span class="n">master</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chopper_values</span><span class="p">(</span><span class="n">h5d</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;master&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">master</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;slave&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">slave</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;frequency&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">frequency</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;chopper2_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/chopper2_distance&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;chopper3_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/chopper3_distance&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;chopper4_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/chopper4_distance&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;chopper1_phase_offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/chopper1_phase_offset&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;chopper2_phase_offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/chopper2_phase_offset&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;chopper3_phase_offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/chopper3_phase_offset&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;chopper4_phase_offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/chopper4_phase_offset&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;guide1_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/guide1_distance&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;guide2_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/guide2_distance&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;sample_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/sample_distance&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;slit2_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/slit2_distance&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;slit3_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/parameters/slit3_distance&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;collimation_distance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;slit3_distance&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;slit2_distance&#39;</span><span class="p">]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/detector/longitudinal_translation&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span>
            <span class="s1">&#39;entry1/instrument/detector/vertical_translation&#39;</span><span class="p">][:]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;original_file_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/experiment/file_name&#39;</span><span class="p">]</span>

        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;scan_axis_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/data/hmm&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;axes&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;scan_axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5d</span><span class="p">[</span><span class="s1">&#39;entry1/data/</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;scan_axis_name&#39;</span><span class="p">]][:]</span>

        <span class="c1"># TODO put HDF file y pixel spacing in here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cat</span> <span class="o">=</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">datafile_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">datafile_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_chopper_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Obtains chopper settings from NeXUS file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5data : HDF5 NeXUS file</span>
<span class="sd">            datafile,</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        master, slave, frequency, phase : float, float, float, float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chopper1_speed</span> <span class="o">=</span> <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/disk_chopper/ch1speed&#39;</span><span class="p">]</span>
        <span class="n">chopper2_speed</span> <span class="o">=</span> <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/disk_chopper/ch2speed&#39;</span><span class="p">]</span>
        <span class="n">chopper3_speed</span> <span class="o">=</span> <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/disk_chopper/ch3speed&#39;</span><span class="p">]</span>
        <span class="n">chopper4_speed</span> <span class="o">=</span> <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/disk_chopper/ch4speed&#39;</span><span class="p">]</span>
        <span class="n">ch2phase</span> <span class="o">=</span> <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/disk_chopper/ch2phase&#39;</span><span class="p">]</span>
        <span class="n">ch3phase</span> <span class="o">=</span> <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/disk_chopper/ch3phase&#39;</span><span class="p">]</span>
        <span class="n">ch4phase</span> <span class="o">=</span> <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/disk_chopper/ch4phase&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;entry1/instrument/parameters/slave&#39;</span> <span class="ow">in</span> <span class="n">h5data</span> <span class="ow">and</span>
                <span class="s1">&#39;entry1/instrument/parameters/master&#39;</span> <span class="ow">in</span> <span class="n">h5data</span><span class="p">):</span>
            <span class="n">master</span> <span class="o">=</span> <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/parameters/master&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">slave</span> <span class="o">=</span> <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/parameters/slave&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">master</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">chopper2_speed</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">slave</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">chopper3_speed</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">slave</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slave</span> <span class="o">=</span> <span class="mi">4</span>

        <span class="n">speeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">chopper1_speed</span><span class="p">,</span>
                           <span class="n">chopper2_speed</span><span class="p">,</span>
                           <span class="n">chopper3_speed</span><span class="p">,</span>
                           <span class="n">chopper4_speed</span><span class="p">])</span>

        <span class="n">phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ch2phase</span><span class="p">),</span>
                           <span class="n">ch2phase</span><span class="p">,</span>
                           <span class="n">ch3phase</span><span class="p">,</span>
                           <span class="n">ch4phase</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">master</span><span class="p">,</span> <span class="n">slave</span><span class="p">,</span> <span class="n">speeds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">60.</span><span class="p">,</span> <span class="n">phases</span><span class="p">[</span><span class="n">slave</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="basename_datafile"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.basename_datafile">[docs]</a><span class="k">def</span> <span class="nf">basename_datafile</span><span class="p">(</span><span class="n">pth</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a NeXUS path return the basename minus the file extension.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pth : str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    basename : str</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; basename_datafile(&#39;a/b/c.nx.hdf&#39;)</span>
<span class="sd">    &#39;c&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">basename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">pth</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">basename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.nx.hdf&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="number_datafile"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.number_datafile">[docs]</a><span class="k">def</span> <span class="nf">number_datafile</span><span class="p">(</span><span class="n">run_number</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a run number figure out what the file name is.</span>
<span class="sd">    Given a file name, return the filename with the .nx.hdf extension</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    run_number : int or str</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    file_name : str</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; number_datafile(708)</span>
<span class="sd">    &#39;PLP0000708.nx.hdf</span>
<span class="sd">    &gt;&gt;&gt; number_datafile(&#39;PLP0000708.nx.hdf&#39;)</span>
<span class="sd">    &#39;PLP0000708.nx.hdf&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">run_number</span><span class="p">))</span>
        <span class="c1"># you got given a run number</span>
        <span class="k">return</span> <span class="s1">&#39;PLP</span><span class="si">{0:07d}</span><span class="s1">.nx.hdf&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># you may have been given full filename</span>
        <span class="k">if</span> <span class="n">run_number</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.nx.hdf&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">run_number</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">run_number</span> <span class="o">+</span> <span class="s1">&#39;.nx.hdf&#39;</span></div>


<div class="viewcode-block" id="datafile_number"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.datafile_number">[docs]</a><span class="k">def</span> <span class="nf">datafile_number</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    From a filename figure out what the run number was</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        The filename to be processed</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    run_number : int</span>
<span class="sd">        The run number</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; datafile_number(&#39;PLP0000708.nx.hdf&#39;)</span>
<span class="sd">    708</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;.*PLP([0-9]</span><span class="si">{7}</span><span class="s2">).nx.hdf&quot;</span><span class="p">)</span>
    <span class="n">_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">_fname</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="PlatypusNexus"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.PlatypusNexus">[docs]</a><span class="k">class</span> <span class="nc">PlatypusNexus</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes Platypus NeXus files to produce an intensity vs wavelength</span>
<span class="sd">    spectrum</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5data : HDF5 NeXus file or str</span>
<span class="sd">        An HDF5 NeXus file for Platypus, or a `str` containing the path</span>
<span class="sd">        to one</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialises the PlatypusNexus object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">_possibly_open_hdf_file</span><span class="p">(</span><span class="n">h5data</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cat</span> <span class="o">=</span> <span class="n">Catalogue</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># _arguments is a dict that contains all the parameters used to call</span>
        <span class="c1"># `process`. If the arguments don&#39;t change then you shouldn&#39;t need to</span>
        <span class="c1"># call process again, thereby saving time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arguments</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>

    <span class="k">def</span> <span class="nf">__short_circuit_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_arguments</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the truth that two sets of arguments from successive calls to</span>
<span class="sd">        the `process` method are the same.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        _arguments : dict</span>
<span class="sd">            arguments passed to the `process` method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        val : bool</span>
<span class="sd">            Truth that __arguments is the same as self.__arguments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_arguments</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_dict_compare</span><span class="p">(</span><span class="n">_arguments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arguments</span><span class="p">)</span>

<div class="viewcode-block" id="PlatypusNexus.process"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.PlatypusNexus.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lo_wavelength</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">hi_wavelength</span><span class="o">=</span><span class="mf">19.</span><span class="p">,</span>
                <span class="n">background</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">direct</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">twotheta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">rebin_percent</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">wavelength_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">integrate</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">eventmode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">event_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">peak_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_pos_tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
                <span class="n">background_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalise_bins</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">manual_beam_find</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">event_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Processes the ProcessNexus object to produce a time of flight spectrum.</span>
<span class="sd">        The processed spectrum is stored in the `processed_spectrum` attribute.</span>
<span class="sd">        The specular spectrum is also returned from this function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5norm : str or HDF5 NeXus file</span>
<span class="sd">            If a str then `h5norm` is a path to the floodfield data, otherwise</span>
<span class="sd">            it is a hdf5 file handle containing the floodfield data.</span>
<span class="sd">        lo_wavelength : float</span>
<span class="sd">            The low wavelength cutoff for the rebinned data (A).</span>
<span class="sd">        hi_wavelength : float</span>
<span class="sd">            The high wavelength cutoff for the rebinned data (A).</span>
<span class="sd">        background : bool</span>
<span class="sd">            Should a background subtraction be carried out?</span>
<span class="sd">        direct : bool</span>
<span class="sd">            Is it a direct beam you measured? This is so a gravity correction</span>
<span class="sd">            can be applied.</span>
<span class="sd">        omega : float</span>
<span class="sd">            Expected angle of incidence of beam. If this is None, then the</span>
<span class="sd">            rough angle of incidence is obtained from the NeXus file.</span>
<span class="sd">        twotheta : float</span>
<span class="sd">            Expected two theta value of specular beam. If this is None then</span>
<span class="sd">            the rough angle of incidence is obtained from the NeXus file.</span>
<span class="sd">        rebin_percent : float</span>
<span class="sd">            Specifies the rebinning percentage for the spectrum.  If</span>
<span class="sd">            `rebin_percent is None`, then no rebinning is done.</span>
<span class="sd">        wavelength_bins : array_like</span>
<span class="sd">            The wavelength bins for rebinning.  If `wavelength_bins is not</span>
<span class="sd">            None` then the `rebin_percent` parameter is ignored.</span>
<span class="sd">        normalise : bool</span>
<span class="sd">            Normalise by the monitor counts.</span>
<span class="sd">        integrate : int</span>
<span class="sd">            Specifies which scanpoints to use.</span>

<span class="sd">             - integrate == -1</span>
<span class="sd">               the spectrum is integrated over all the scanpoints.</span>
<span class="sd">             - integrate &gt;= 0</span>
<span class="sd">               the individual spectra are calculated individually.</span>
<span class="sd">               If `eventmode is not None`, or `event_filter is not None` then</span>
<span class="sd">               integrate specifies which scanpoint to examine.</span>

<span class="sd">        eventmode : None or array_like</span>
<span class="sd">            If eventmode is `None` then the integrated detector image is used.</span>
<span class="sd">            If eventmode is an array then the array specifies the integration</span>
<span class="sd">            times (in seconds) for the detector image, e.g. [0, 20, 30] would</span>
<span class="sd">            result in two spectra. The first would contain data for 0 s to 20s,</span>
<span class="sd">            the second would contain data for 20 s to 30 s.  This option can</span>
<span class="sd">            only be used when `integrate &gt;= -1`.</span>
<span class="sd">            If eventmode has zero length (e.g. []), then a single time interval</span>
<span class="sd">            for the entire acquisition is used, [0, acquisition_time].  This</span>
<span class="sd">            would source the image from the eventmode file, rather than the</span>
<span class="sd">            NeXUS file. The two approaches will probably not give</span>
<span class="sd">            identical results, because the eventmode method adjusts the total</span>
<span class="sd">            acquisition time and beam monitor counts to the frame number of the</span>
<span class="sd">            last event detected (which may be quite different if the count rate</span>
<span class="sd">            is very low). This parameter is disregarded if `event_filter` is</span>
<span class="sd">            provided.</span>
<span class="sd">        event_folder : None or str</span>
<span class="sd">            Specifies the path for the eventmode data. If</span>
<span class="sd">            `event_folder is None` then the eventmode data is assumed to reside</span>
<span class="sd">            in the same directory as the NeXUS file. If event_folder is a</span>
<span class="sd">            string, then the string specifies the path to the eventmode data.</span>
<span class="sd">        peak_pos : -1, None, or (float, float)</span>
<span class="sd">            Options for finding specular peak position and peak standard</span>
<span class="sd">            deviation.</span>

<span class="sd">            - \-1</span>
<span class="sd">               use `manual_beam_find`.</span>
<span class="sd">            - None</span>
<span class="sd">               use the automatic beam finder, falling back to</span>
<span class="sd">               `manual_beam_find` if it&#39;s provided.</span>
<span class="sd">            - (float, float)</span>
<span class="sd">               specify the peak and peak standard deviation.</span>

<span class="sd">        peak_pos_tol : float</span>
<span class="sd">            Convergence tolerance for the beam position and width to be</span>
<span class="sd">            accepted from successive beam-finder calculations; see the</span>
<span class="sd">            `tol` parameter in the `find_specular_ridge` function.</span>
<span class="sd">        background_mask : array_like</span>
<span class="sd">            An array of bool that specifies which y-pixels to use for</span>
<span class="sd">            background subtraction.  Should be the same length as the number of</span>
<span class="sd">            y pixels in the detector image.  Otherwise an automatic mask is</span>
<span class="sd">            applied (if background is True).</span>
<span class="sd">        normalise_bins : bool</span>
<span class="sd">            Divides the intensity in each wavelength bin by the width of the</span>
<span class="sd">            bin. This allows one to compare spectra even if they were processed</span>
<span class="sd">            with different rebin percentages.</span>
<span class="sd">        manual_beam_find : callable, optional</span>
<span class="sd">            A function which allows the location of the specular ridge to be</span>
<span class="sd">            determined. Has the signature `f(detector, detector_err)` where</span>
<span class="sd">            `detector` and `detector_err` is the detector image and its</span>
<span class="sd">            uncertainty. `detector` and `detector_err` have shape (n, t, y)</span>
<span class="sd">            where `n` is the number of detector images, `t` is the number of</span>
<span class="sd">            time of flight bins and `y` is the number of y pixels. The function</span>
<span class="sd">            should return a tuple,</span>
<span class="sd">            `(centre, centre_sd, lopx, hipx, background_pixels)`. `centre`,</span>
<span class="sd">            `centre_sd`, `lopx`, `hipx` should be arrays of shape `(n, )`,</span>
<span class="sd">            specifying the beam centre, beam width (standard deviation), lowest</span>
<span class="sd">            pixel of foreground region, highest pixel of foreground region.</span>
<span class="sd">            `background_pixels` is a list of length `n`. Each of the entries</span>
<span class="sd">            should contain arrays of pixel numbers that specify the background</span>
<span class="sd">            region for each of the detector images.</span>
<span class="sd">        event_filter : callable, optional</span>
<span class="sd">            A function, that processes the event stream, returning a `detector`</span>
<span class="sd">            array, and a `frame_count` array. `detector` has shape</span>
<span class="sd">            `(N, T, Y, X)`, where `N` is the number of detector images, `T` is</span>
<span class="sd">            the number of time bins (`len(t_bins)`), etc. `frame_count` has</span>
<span class="sd">            shape `(N,)` and contains the number of frames for each of the</span>
<span class="sd">            detector images. The frame_count is used to determine what fraction</span>
<span class="sd">            of the overall monitor counts should be ascribed to each detector</span>
<span class="sd">            image (by dividing by the total number of frames). The function has</span>
<span class="sd">            signature:</span>

<span class="sd">            detector, frame_count = event_filter(loaded_events,</span>
<span class="sd">                                                 t_bins=None,</span>
<span class="sd">                                                 y_bins=None,</span>
<span class="sd">                                                 x_bins=None)</span>

<span class="sd">            `loaded_events` is a 4-tuple of numpy arrays:</span>
<span class="sd">            `(f_events, t_events, y_events, x_events)`, where `f_events`</span>
<span class="sd">            contains the frame number for each neutron, landing at position</span>
<span class="sd">            `x_events, y_events` on the detector, with time-of-flight</span>
<span class="sd">            `t_events`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        After processing this object contains the following the following</span>
<span class="sd">        attributes:</span>

<span class="sd">        - path - path to the data file</span>
<span class="sd">        - datafilename - name of the datafile</span>
<span class="sd">        - datafile_number - datafile number.</span>
<span class="sd">        - m_topandtail - the corrected 2D detector image, (n_spectra, TOF, Y)</span>
<span class="sd">        - m_topandtail_sd - corresponding standard deviations</span>
<span class="sd">        - n_spectra - number of spectra in processed data</span>
<span class="sd">        - bm1_counts - beam montor counts, (n_spectra,)</span>
<span class="sd">        - m_spec - specular intensity, (n_spectra, TOF)</span>
<span class="sd">        - m_spec_sd - corresponding standard deviations</span>
<span class="sd">        - m_beampos - beam_centre for each spectrum, (n_spectra, )</span>
<span class="sd">        - m_lambda - wavelengths for each spectrum, (n_spectra, TOF)</span>
<span class="sd">        - m_lambda_fwhm - corresponding FWHM of wavelength distribution</span>
<span class="sd">        - m_lambda_hist - wavelength bins for each spectrum, (n_spectra, TOF)</span>
<span class="sd">        - m_spec_tof - TOF for each wavelength bin, (n_spectra, TOF)</span>
<span class="sd">        - mode - the Platypus mode, e.g. FOC/MT/POL/POLANAL/SB/DB</span>
<span class="sd">        - detector_z - detector height, (n_spectra, )</span>
<span class="sd">        - detector_y - sample-detector distance, (n_spectra, )</span>
<span class="sd">        - domega - collimation uncertainty</span>
<span class="sd">        - lopx - lowest extent of specular beam (in y pixels), (n_spectra, )</span>
<span class="sd">        - hipx - highest extent of specular beam (in y pixels), (n_spectra, )</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        m_lambda, m_spec, m_spec_sd: np.ndarray</span>
<span class="sd">            Arrays containing the wavelength, specular intensity as a function</span>
<span class="sd">            of wavelength, standard deviation of specular intensity</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># it can be advantageous to save processing time if the arguments</span>
        <span class="c1"># haven&#39;t changed</span>
        <span class="n">_arguments</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_arguments</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_arguments&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">_arguments</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># if you&#39;ve already processed, then you may not need to process again</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__short_circuit_process</span><span class="p">(</span><span class="n">_arguments</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_lambda&#39;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_spec&#39;</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_spec_sd&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_arguments</span> <span class="o">=</span> <span class="n">_arguments</span>

        <span class="n">cat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat</span>

        <span class="n">scanpoint</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># beam monitor counts for normalising data</span>
        <span class="n">bm1_counts</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">bm1_counts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

        <span class="c1"># TOF bins</span>
        <span class="n">TOF</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">t_bins</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

        <span class="c1"># This section controls how multiple detector images are handled.</span>
        <span class="c1"># We want event streaming.</span>
        <span class="k">if</span> <span class="n">eventmode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">event_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scanpoint</span> <span class="o">=</span> <span class="n">integrate</span>
            <span class="k">if</span> <span class="n">integrate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">scanpoint</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_event_stream</span><span class="p">(</span><span class="n">scanpoint</span><span class="o">=</span><span class="n">scanpoint</span><span class="p">,</span>
                                               <span class="n">frame_bins</span><span class="o">=</span><span class="n">eventmode</span><span class="p">,</span>
                                               <span class="n">event_folder</span><span class="o">=</span><span class="n">event_folder</span><span class="p">,</span>
                                               <span class="n">event_filter</span><span class="o">=</span><span class="n">event_filter</span><span class="p">)</span>
            <span class="n">detector</span><span class="p">,</span> <span class="n">frame_count</span><span class="p">,</span> <span class="n">bm1_counts</span> <span class="o">=</span> <span class="n">output</span>

            <span class="n">start_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">cat</span><span class="o">.</span><span class="n">start_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_time</span> <span class="o">+=</span> <span class="n">cat</span><span class="o">.</span><span class="n">start_time</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span>
                <span class="n">start_time</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">frame_count</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span>
                                   <span class="n">cat</span><span class="o">.</span><span class="n">frequency</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we don&#39;t want detector streaming</span>
            <span class="n">detector</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">detector</span>
            <span class="n">scanpoint</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># integrate over all spectra</span>
            <span class="k">if</span> <span class="n">integrate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">detector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="mi">0</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">]</span>
                <span class="n">bm1_counts</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bm1_counts</span><span class="p">)</span>

            <span class="n">start_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">cat</span><span class="o">.</span><span class="n">start_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_time</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">start_time</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">start_time</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">n_spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Up until this point detector.shape=(N, T, Y)</span>
        <span class="c1"># pre-average over x, leaving (n, t, y) also convert to dp</span>
        <span class="n">detector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

        <span class="c1"># detector shape should now be (n, t, y)</span>
        <span class="c1"># calculate the counting uncertainties</span>
        <span class="n">detector_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">detector</span><span class="p">)</span>
        <span class="n">bm1_counts_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bm1_counts</span><span class="p">)</span>

        <span class="c1"># detector normalisation with a water file</span>
        <span class="k">if</span> <span class="n">h5norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_bins</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">x_bins</span>

            <span class="k">with</span> <span class="n">_possibly_open_hdf_file</span><span class="p">(</span><span class="n">h5norm</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="c1"># shape (y,)</span>
                <span class="n">detector_norm</span><span class="p">,</span> <span class="n">detector_norm_sd</span> <span class="o">=</span> <span class="n">create_detector_norm</span><span class="p">(</span>
                    <span class="n">f</span><span class="p">,</span> <span class="n">x_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># detector has shape (N, T, Y), shape of detector_norm should</span>
            <span class="c1"># broadcast to (1, 1, y)</span>
            <span class="c1"># TODO: Correlated Uncertainties?</span>
            <span class="n">detector</span><span class="p">,</span> <span class="n">detector_sd</span> <span class="o">=</span> <span class="n">EP</span><span class="o">.</span><span class="n">EPdiv</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">detector_sd</span><span class="p">,</span>
                                             <span class="n">detector_norm</span><span class="p">,</span> <span class="n">detector_norm_sd</span><span class="p">)</span>

        <span class="c1"># shape of these is (n_spectra, TOFbins)</span>
        <span class="n">m_spec_tof_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_spectra</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">TOF</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
                                   <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">m_lambda_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_spectra</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">TOF</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">m_spec_tof_hist</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">TOF</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        chopper to detector distances</span>
<span class="sd">        note that if eventmode is specified the n_spectra is NOT</span>
<span class="sd">        equal to the number of entries in e.g. /longitudinal_translation</span>
<span class="sd">        this means you have to copy values in from the correct scanpoint</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flight_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_spectra</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">d_cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_spectra</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
        <span class="n">detpositions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_spectra</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

        <span class="c1"># The angular divergence of the instrument</span>
        <span class="n">domega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_spectra</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

        <span class="n">phase_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_spectra</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

        <span class="c1"># process each of the spectra taken in the detector image</span>
        <span class="n">originalscanpoint</span> <span class="o">=</span> <span class="n">scanpoint</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_spectra</span><span class="p">):</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">frequency</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span>

            <span class="c1"># calculate the angular divergence</span>
            <span class="n">domega</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">general</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">ss2vg</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">],</span>
                                      <span class="n">cat</span><span class="o">.</span><span class="n">ss3vg</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">],</span>
                                      <span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">slit3_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
                                       <span class="n">cat</span><span class="o">.</span><span class="n">slit2_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            work out the total flight length</span>
<span class="sd">            IMPORTANT: this varies as a function of twotheta. This is</span>
<span class="sd">            because the Platypus detector does not move on an arc.</span>
<span class="sd">            At high angles chod can be ~ 0.75% different. This is will</span>
<span class="sd">            visibly shift fringes.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">omega</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">omega</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">twotheta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">twotheta</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">twotheta</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chod</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">twotheta</span><span class="p">,</span> <span class="n">scanpoint</span><span class="o">=</span><span class="n">scanpoint</span><span class="p">)</span>
            <span class="n">flight_distance</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">d_cx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span>

            <span class="c1"># calculate phase openings</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_angle</span><span class="p">(</span><span class="n">scanpoint</span><span class="p">)</span>
            <span class="n">phase_angle</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">],</span> <span class="n">master_opening</span> <span class="o">=</span> <span class="n">output</span>

            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            toffset - the time difference between the magnet pickup on the</span>
<span class="sd">            choppers (TTL pulse), which is situated in the middle of the</span>
<span class="sd">            chopper window, and the trailing edge of chopper 1, which is</span>
<span class="sd">            supposed to be time0.  However, if there is a phase opening this</span>
<span class="sd">            time offset has to be relocated slightly, as time0 is not at the</span>
<span class="sd">            trailing edge.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">poff</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper1_phase_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">poffset</span> <span class="o">=</span> <span class="mf">1.e6</span> <span class="o">*</span> <span class="n">poff</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="mf">360.</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
            <span class="n">toffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">poffset</span> <span class="o">+</span>
                       <span class="mf">1.e6</span> <span class="o">*</span> <span class="n">master_opening</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="n">freq</span> <span class="o">-</span>
                       <span class="mf">1.e6</span> <span class="o">*</span> <span class="n">phase_angle</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">360</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">freq</span><span class="p">))</span>
            <span class="n">m_spec_tof_hist</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-=</span> <span class="n">toffset</span>

            <span class="n">detpositions</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">eventmode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">m_spec_tof_hist</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">TOF</span> <span class="o">-</span> <span class="n">toffset</span>
                <span class="n">flight_distance</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">flight_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">detpositions</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">detpositions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">domega</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">domega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">d_cx</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">d_cx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">phase_angle</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">phase_angle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scanpoint</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">scanpoint</span> <span class="o">=</span> <span class="n">originalscanpoint</span>

        <span class="c1"># convert TOF to lambda</span>
        <span class="c1"># m_spec_tof_hist (n, t) and chod is (n,)</span>
        <span class="n">m_lambda_hist</span> <span class="o">=</span> <span class="n">general</span><span class="o">.</span><span class="n">velocity_wavelength</span><span class="p">(</span>
            <span class="mf">1.e3</span> <span class="o">*</span> <span class="n">flight_distance</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span> <span class="n">m_spec_tof_hist</span><span class="p">)</span>

        <span class="n">m_lambda</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">m_lambda_hist</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">m_lambda_hist</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">TOF</span> <span class="o">-=</span> <span class="n">toffset</span>

        <span class="c1"># gravity correction if direct beam</span>
        <span class="k">if</span> <span class="n">direct</span><span class="p">:</span>
            <span class="c1"># TODO: Correlated Uncertainties?</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">correct_for_gravity</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span>
                                         <span class="n">detector_sd</span><span class="p">,</span>
                                         <span class="n">m_lambda</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">collimation_distance</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span>
                                         <span class="n">lo_wavelength</span><span class="p">,</span>
                                         <span class="n">hi_wavelength</span><span class="p">)</span>
            <span class="n">detector</span><span class="p">,</span> <span class="n">detector_sd</span><span class="p">,</span> <span class="n">m_gravcorrcoefs</span> <span class="o">=</span> <span class="n">output</span>

        <span class="c1"># where is the specular ridge?</span>
        <span class="k">if</span> <span class="n">peak_pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># you always want to find the beam manually</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">manual_beam_find</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">detector_sd</span><span class="p">)</span>
            <span class="n">beam_centre</span><span class="p">,</span> <span class="n">beam_sd</span><span class="p">,</span> <span class="n">lopx</span><span class="p">,</span> <span class="n">hipx</span><span class="p">,</span> <span class="n">bp</span> <span class="o">=</span> <span class="n">ret</span>

            <span class="n">full_backgnd_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bp</span><span class="p">):</span>
                <span class="n">full_backgnd_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="n">peak_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># use the auto finder, falling back to manual_beam_find</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">find_specular_ridge</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span>
                                      <span class="n">detector_sd</span><span class="p">,</span>
                                      <span class="n">tol</span><span class="o">=</span><span class="n">peak_pos_tol</span><span class="p">,</span>
                                      <span class="n">manual_beam_find</span><span class="o">=</span><span class="n">manual_beam_find</span><span class="p">)</span>
            <span class="n">beam_centre</span><span class="p">,</span> <span class="n">beam_sd</span><span class="p">,</span> <span class="n">lopx</span><span class="p">,</span> <span class="n">hipx</span><span class="p">,</span> <span class="n">full_backgnd_mask</span> <span class="o">=</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># the specular ridge has been specified</span>
            <span class="n">beam_centre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_spectra</span><span class="p">)</span> <span class="o">*</span> <span class="n">peak_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">beam_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_spectra</span><span class="p">)</span> <span class="o">*</span> <span class="n">peak_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">lopx</span><span class="p">,</span> <span class="n">hipx</span><span class="p">,</span> <span class="n">bp</span> <span class="o">=</span> <span class="n">fore_back_region</span><span class="p">(</span><span class="n">beam_centre</span><span class="p">,</span>
                                              <span class="n">beam_sd</span><span class="p">)</span>

            <span class="n">full_backgnd_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bp</span><span class="p">):</span>
                <span class="n">full_backgnd_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">lopx</span> <span class="o">=</span> <span class="n">lopx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">hipx</span> <span class="o">=</span> <span class="n">hipx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">beam_centre</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_spectra</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The number of beam centres should be equal&#39;</span>
                               <span class="s1">&#39;to the number of detector images.&#39;</span><span class="p">)</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Rebinning in lambda for all detector</span>
<span class="sd">        Rebinning is the default option, but sometimes you don&#39;t want to.</span>
<span class="sd">        detector shape input is (n, t, y)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">wavelength_bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rebinning</span> <span class="o">=</span> <span class="n">wavelength_bins</span>
        <span class="k">elif</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">rebin_percent</span> <span class="o">&lt;</span> <span class="mf">15.</span><span class="p">:</span>
            <span class="n">rebinning</span> <span class="o">=</span> <span class="n">calculate_wavelength_bins</span><span class="p">(</span><span class="n">lo_wavelength</span><span class="p">,</span>
                                                  <span class="n">hi_wavelength</span><span class="p">,</span>
                                                  <span class="n">rebin_percent</span><span class="p">)</span>

        <span class="c1"># rebin_percent percentage is zero. No rebinning, just cutoff</span>
        <span class="c1"># wavelength</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rebinning</span> <span class="o">=</span> <span class="n">m_lambda_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">rebinning</span> <span class="o">=</span> <span class="n">rebinning</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">rebinning</span><span class="p">,</span> <span class="n">lo_wavelength</span><span class="p">):</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">rebinning</span><span class="p">,</span> <span class="n">hi_wavelength</span><span class="p">)]</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        now do the rebinning for all the N detector images</span>
<span class="sd">        rebin.rebinND could do all of these at once.  However, m_lambda_hist</span>
<span class="sd">        could vary across the range of spectra.  If it was the same I could</span>
<span class="sd">        eliminate the loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">output_sd</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_spectra</span><span class="p">):</span>
            <span class="c1"># TODO: Correlated Uncertainties?</span>
            <span class="n">plane</span><span class="p">,</span> <span class="n">plane_sd</span> <span class="o">=</span> <span class="n">rebin_along_axis</span><span class="p">(</span><span class="n">detector</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                               <span class="n">m_lambda_hist</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                               <span class="n">rebinning</span><span class="p">,</span>
                                               <span class="n">y1_sd</span><span class="o">=</span><span class="n">detector_sd</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span>
            <span class="n">output_sd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plane_sd</span><span class="p">)</span>

        <span class="n">detector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="n">detector_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output_sd</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">detector</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">detector</span> <span class="o">=</span> <span class="n">detector</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">]</span>
            <span class="n">detector_sd</span> <span class="o">=</span> <span class="n">detector_sd</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">]</span>

        <span class="c1"># (1, T)</span>
        <span class="n">m_lambda_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">rebinning</span><span class="p">)</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide the detector intensities by the width of the wavelength bin.</span>
<span class="sd">        This is so the intensities between different rebinning strategies can</span>
<span class="sd">        be compared.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">normalise_bins</span><span class="p">:</span>
            <span class="n">div</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">m_lambda_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">detector</span><span class="p">,</span> <span class="n">detector_sd</span> <span class="o">=</span> <span class="n">EP</span><span class="o">.</span><span class="n">EPmulk</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span>
                                              <span class="n">detector_sd</span><span class="p">,</span>
                                              <span class="n">div</span><span class="p">)</span>

        <span class="c1"># convert the wavelength base to a timebase</span>
        <span class="n">m_spec_tof_hist</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.001</span> <span class="o">*</span> <span class="n">flight_distance</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span>
                           <span class="n">general</span><span class="o">.</span><span class="n">wavelength_velocity</span><span class="p">(</span><span class="n">m_lambda_hist</span><span class="p">))</span>

        <span class="n">m_lambda</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">m_lambda_hist</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">m_lambda_hist</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">m_spec_tof</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.001</span> <span class="o">*</span> <span class="n">flight_distance</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span>
                      <span class="n">general</span><span class="o">.</span><span class="n">wavelength_velocity</span><span class="p">(</span><span class="n">m_lambda</span><span class="p">))</span>

        <span class="n">m_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_spectra</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">m_spec_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m_spec</span><span class="p">)</span>

        <span class="c1"># background subtraction</span>
        <span class="k">if</span> <span class="n">background</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">background_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># background_mask is (Y), need to make 3 dimensional (N, T, Y)</span>
                <span class="c1"># first make into (T, Y)</span>
                <span class="n">backgnd_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">background_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                                         <span class="n">detector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                         <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># make into (N, T, Y)</span>
                <span class="n">full_backgnd_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">backgnd_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                                              <span class="n">n_spectra</span><span class="p">,</span>
                                              <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># TODO: Correlated Uncertainties?</span>
            <span class="n">detector</span><span class="p">,</span> <span class="n">detector_sd</span> <span class="o">=</span> <span class="n">background_subtract</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span>
                                                        <span class="n">detector_sd</span><span class="p">,</span>
                                                        <span class="n">full_backgnd_mask</span><span class="p">)</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        top and tail the specular beam with the known beam centres.</span>
<span class="sd">        All this does is produce a specular intensity with shape (N, T),</span>
<span class="sd">        i.e. integrate over specular beam</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_spectra</span><span class="p">):</span>
            <span class="n">m_spec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">detector</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="n">lopx</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">hipx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">detector_sd</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="n">lopx</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">hipx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">m_spec_sd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span>

        <span class="c1"># assert np.isfinite(m_spec).all()</span>
        <span class="c1"># assert np.isfinite(m_specSD).all()</span>
        <span class="c1"># assert np.isfinite(detector).all()</span>
        <span class="c1"># assert np.isfinite(detectorSD).all()</span>

        <span class="c1"># normalise by beam monitor 1.</span>
        <span class="k">if</span> <span class="n">normalise</span><span class="p">:</span>
            <span class="n">m_spec</span><span class="p">,</span> <span class="n">m_spec_sd</span> <span class="o">=</span> <span class="n">EP</span><span class="o">.</span><span class="n">EPdiv</span><span class="p">(</span><span class="n">m_spec</span><span class="p">,</span>
                                         <span class="n">m_spec_sd</span><span class="p">,</span>
                                         <span class="n">bm1_counts</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                         <span class="n">bm1_counts_sd</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

            <span class="n">output</span> <span class="o">=</span> <span class="n">EP</span><span class="o">.</span><span class="n">EPdiv</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span>
                              <span class="n">detector_sd</span><span class="p">,</span>
                              <span class="n">bm1_counts</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                              <span class="n">bm1_counts_sd</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
            <span class="n">detector</span><span class="p">,</span> <span class="n">detector_sd</span> <span class="o">=</span> <span class="n">output</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        now work out dlambda/lambda, the resolution contribution from</span>
<span class="sd">        wavelength.</span>
<span class="sd">        van Well, Physica B,  357(2005) pp204-207), eqn 4.</span>
<span class="sd">        this is only an approximation for our instrument, as the 2nd and 3rd</span>
<span class="sd">        discs have smaller openings compared to the master chopper.</span>
<span class="sd">        Therefore the burst time needs to be looked at.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">tau_da</span> <span class="o">=</span> <span class="n">m_spec_tof_hist</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">m_spec_tof_hist</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">m_lambda_fwhm</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">resolution_double_chopper</span><span class="p">(</span><span class="n">m_lambda</span><span class="p">,</span>
                                      <span class="n">z0</span><span class="o">=</span><span class="n">d_cx</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1000.</span><span class="p">,</span>
                                      <span class="n">freq</span><span class="o">=</span><span class="n">cat</span><span class="o">.</span><span class="n">frequency</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                      <span class="n">L</span><span class="o">=</span><span class="n">flight_distance</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1000.</span><span class="p">,</span>
                                      <span class="n">H</span><span class="o">=</span><span class="n">cat</span><span class="o">.</span><span class="n">ss2vg</span><span class="p">[</span><span class="n">originalscanpoint</span><span class="p">]</span> <span class="o">/</span> <span class="mf">1000.</span><span class="p">,</span>
                                      <span class="n">xsi</span><span class="o">=</span><span class="n">phase_angle</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                      <span class="n">tau_da</span><span class="o">=</span><span class="n">tau_da</span><span class="p">))</span>

        <span class="n">m_lambda_fwhm</span> <span class="o">*=</span> <span class="n">m_lambda</span>

        <span class="c1"># put the detector positions and mode into the dictionary as well.</span>
        <span class="n">detector_z</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">dz</span>
        <span class="n">detector_y</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">dy</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">mode</span>

        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">path</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;datafilename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">filename</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;datafile_number&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">datafile_number</span>

        <span class="k">if</span> <span class="n">h5norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">h5norm</span><span class="p">)</span> <span class="o">==</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;normfilename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5norm</span><span class="o">.</span><span class="n">filename</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;normfilename&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">h5norm</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;m_topandtail&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detector</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;m_topandtail_sd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detector_sd</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;n_spectra&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_spectra</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;bm1_counts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bm1_counts</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;m_spec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_spec</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;m_spec_sd&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_spec_sd</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;m_beampos&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">beam_centre</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;m_lambda&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_lambda</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;m_lambda_fwhm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_lambda_fwhm</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;m_lambda_hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_lambda_hist</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;m_spec_tof&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_spec_tof</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;detector_z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detector_z</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;detector_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detector_y</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;domega&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">domega</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;lopx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lopx</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;hipx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hipx</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;start_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_time</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">m_lambda</span><span class="p">,</span> <span class="n">m_spec</span><span class="p">,</span> <span class="n">m_spec_sd</span></div>

<div class="viewcode-block" id="PlatypusNexus.phase_angle"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.PlatypusNexus.phase_angle">[docs]</a>    <span class="k">def</span> <span class="nf">phase_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scanpoint</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the phase angle for a given scanpoint</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scanpoint : int</span>
<span class="sd">            The scanpoint you&#39;re interested in</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        phase_angle, master_opening : float</span>
<span class="sd">            The phase angle in degrees, and the angular opening of the master</span>
<span class="sd">            chopper</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat</span>
        <span class="n">master</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">master</span>
        <span class="n">slave</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">slave</span>
        <span class="n">disc_phase</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">phase</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span>
        <span class="n">phase_angle</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">master</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">phase_angle</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">O_C1d</span>
            <span class="n">master_opening</span> <span class="o">=</span> <span class="n">O_C1</span>
        <span class="k">elif</span> <span class="n">master</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">phase_angle</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">O_C2d</span>
            <span class="n">master_opening</span> <span class="o">=</span> <span class="n">O_C2</span>
        <span class="k">elif</span> <span class="n">master</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">phase_angle</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">O_C3d</span>
            <span class="n">master_opening</span> <span class="o">=</span> <span class="n">O_C3</span>

        <span class="k">if</span> <span class="n">slave</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">phase_angle</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">O_C2d</span>
            <span class="n">phase_angle</span> <span class="o">+=</span> <span class="o">-</span><span class="n">disc_phase</span> <span class="o">-</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper2_phase_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">slave</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">phase_angle</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">O_C3d</span>
            <span class="n">phase_angle</span> <span class="o">+=</span> <span class="o">-</span><span class="n">disc_phase</span> <span class="o">-</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper3_phase_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">slave</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">phase_angle</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">O_C4d</span>
            <span class="n">phase_angle</span> <span class="o">+=</span> <span class="n">disc_phase</span> <span class="o">-</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper4_phase_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">phase_angle</span><span class="p">,</span> <span class="n">master_opening</span></div>

<div class="viewcode-block" id="PlatypusNexus.chod"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.PlatypusNexus.chod">[docs]</a>    <span class="k">def</span> <span class="nf">chod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">twotheta</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">scanpoint</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the flight length of the neutrons in the Platypus</span>
<span class="sd">        instrument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        omega : float, optional</span>
<span class="sd">            Rough angle of incidence</span>
<span class="sd">        twotheta : float, optional</span>
<span class="sd">            Rough 2 theta angle</span>
<span class="sd">        scanpoint : int, optional</span>
<span class="sd">            Which dataset is being considered</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chod, d_cx : float, float</span>
<span class="sd">            Flight distance (mm), distance between chopper discs (mm)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">chod</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># guide 1 is the single deflection mirror (SB)</span>
        <span class="c1"># its distance is from chopper 1 to the middle of the mirror (1m long)</span>
        <span class="c1"># guide 2 is the double deflection mirror (DB)</span>
        <span class="c1"># its distance is from chopper 1 to the middle of the second of the</span>
        <span class="c1"># compound mirrors! (a bit weird, I know).</span>

        <span class="n">cat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">mode</span>

        <span class="c1"># Find out chopper pairing</span>
        <span class="n">master</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">master</span>
        <span class="n">slave</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">slave</span>

        <span class="n">d_cx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">master</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">chod</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">master</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">chod</span> <span class="o">-=</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper2_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d_cx</span> <span class="o">-=</span> <span class="n">chod</span>
        <span class="k">elif</span> <span class="n">master</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">chod</span> <span class="o">-=</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper3_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d_cx</span> <span class="o">-=</span> <span class="n">chod</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Chopper pairing should be one of &#39;12&#39;, &#39;13&#39;,&quot;</span>
                             <span class="s2">&quot;&#39;14&#39;, &#39;23&#39;, &#39;24&#39;, &#39;34&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">slave</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">chod</span> <span class="o">-=</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper2_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d_cx</span> <span class="o">+=</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper2_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">slave</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">chod</span> <span class="o">-=</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper3_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d_cx</span> <span class="o">+=</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper3_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">slave</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">chod</span> <span class="o">-=</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper4_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">d_cx</span> <span class="o">+=</span> <span class="n">cat</span><span class="o">.</span><span class="n">chopper4_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># start of flight length is midway between master and slave, but master</span>
        <span class="c1"># may not necessarily be disk 1. However, all instrument lengths are</span>
        <span class="c1"># measured from disk1</span>
        <span class="n">chod</span> <span class="o">/=</span> <span class="mf">2.</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;FOC&#39;</span><span class="p">,</span> <span class="s1">&#39;POL&#39;</span><span class="p">,</span> <span class="s1">&#39;MT&#39;</span><span class="p">,</span> <span class="s1">&#39;POLANAL&#39;</span><span class="p">]:</span>
            <span class="n">chod</span> <span class="o">+=</span> <span class="n">cat</span><span class="o">.</span><span class="n">sample_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">chod</span> <span class="o">+=</span> <span class="n">cat</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">twotheta</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;SB&#39;</span><span class="p">:</span>
            <span class="c1"># assumes guide1_distance is in the MIDDLE OF THE MIRROR</span>
            <span class="n">chod</span> <span class="o">+=</span> <span class="n">cat</span><span class="o">.</span><span class="n">guide1_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">chod</span> <span class="o">+=</span> <span class="p">((</span><span class="n">cat</span><span class="o">.</span><span class="n">sample_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cat</span><span class="o">.</span><span class="n">guide1_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">omega</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">twotheta</span> <span class="o">&gt;</span> <span class="n">omega</span><span class="p">:</span>
                <span class="n">chod</span> <span class="o">+=</span> <span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span> <span class="o">/</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">twotheta</span> <span class="o">-</span> <span class="n">omega</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chod</span> <span class="o">+=</span> <span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span> <span class="o">/</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">omega</span> <span class="o">-</span> <span class="n">twotheta</span><span class="p">)))</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;DB&#39;</span><span class="p">:</span>
            <span class="c1"># guide2_distance in in the middle of the 2nd compound mirror</span>
            <span class="c1"># guide2_distance - longitudinal length from midpoint1 -&gt; midpoint2</span>
            <span class="c1">#  + direct length from midpoint1-&gt;midpoint2</span>
            <span class="n">chod</span> <span class="o">+=</span> <span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">guide2_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                     <span class="mf">600.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">1.2</span><span class="p">))</span> <span class="o">*</span>
                     <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">2.4</span><span class="p">))))</span>

            <span class="c1"># add on distance from midpoint2 to sample</span>
            <span class="n">chod</span> <span class="o">+=</span> <span class="p">((</span><span class="n">cat</span><span class="o">.</span><span class="n">sample_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cat</span><span class="o">.</span><span class="n">guide2_distance</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span>
                     <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">4.8</span><span class="p">)))</span>

            <span class="c1"># add on sample -&gt; detector</span>
            <span class="k">if</span> <span class="n">twotheta</span> <span class="o">&gt;</span> <span class="n">omega</span><span class="p">:</span>
                <span class="n">chod</span> <span class="o">+=</span> <span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span> <span class="o">/</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">twotheta</span> <span class="o">-</span> <span class="mf">4.8</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chod</span> <span class="o">+=</span> <span class="p">(</span><span class="n">cat</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span> <span class="o">/</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">4.8</span> <span class="o">-</span> <span class="n">twotheta</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">chod</span><span class="p">,</span> <span class="n">d_cx</span></div>

<div class="viewcode-block" id="PlatypusNexus.process_event_stream"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.PlatypusNexus.process_event_stream">[docs]</a>    <span class="k">def</span> <span class="nf">process_event_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">frame_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scanpoint</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">event_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">event_filter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Processes the event mode dataset for the NeXUS file. Assumes that</span>
<span class="sd">        there is a event mode directory in the same directory as the NeXUS</span>
<span class="sd">        file, as specified by in &#39;entry1/instrument/detector/daq_dirname&#39;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t_bins : array_like, optional</span>
<span class="sd">            specifies the time bins required in the image</span>
<span class="sd">        x_bins : array_like, optional</span>
<span class="sd">            specifies the x bins required in the image</span>
<span class="sd">        y_bins : array_like, optional</span>
<span class="sd">            specifies the y bins required in the image</span>
<span class="sd">        scanpoint : int, optional</span>
<span class="sd">            Scanpoint you are interested in</span>
<span class="sd">        event_folder : None or str</span>
<span class="sd">            Specifies the path for the eventmode data. If</span>
<span class="sd">            `event_folder is None` then the eventmode data is assumed to reside</span>
<span class="sd">            in the same directory as the NeXUS file. If event_folder is a</span>
<span class="sd">            string, then the string specifies the path to the eventmode data.</span>
<span class="sd">        frame_bins : array_like, optional</span>
<span class="sd">            specifies the frame bins required in the image. If</span>
<span class="sd">            frame_bins = [5, 10, 120] you will get 2 images.  The first starts</span>
<span class="sd">            at 5s and finishes at 10s. The second starts at 10s and finishes</span>
<span class="sd">            at 120s. If frame_bins has zero length, e.g. [], then a single</span>
<span class="sd">            interval consisting of the entire acquisition time is used:</span>
<span class="sd">            [0, acquisition_time]. If `event_filter` is provided then this</span>
<span class="sd">            parameter is ignored.</span>
<span class="sd">        event_filter : callable, optional</span>
<span class="sd">            A function, that processes the event stream, returning a `detector`</span>
<span class="sd">            array, and a `frame_count` array. `detector` has shape</span>
<span class="sd">            `(N, T, Y, X)`, where `N` is the number of detector images, `T` is</span>
<span class="sd">            the number of time bins (`len(t_bins)`), etc. `frame_count` has</span>
<span class="sd">            shape `(N,)` and contains the number of frames for each of the</span>
<span class="sd">            detector images. The frame_count is used to determine what fraction</span>
<span class="sd">            of the overall monitor counts should be ascribed to each detector</span>
<span class="sd">            image. The function has signature:</span>

<span class="sd">            detector, frame_count = event_filter(loaded_events,</span>
<span class="sd">                                                 t_bins=None,</span>
<span class="sd">                                                 y_bins=None,</span>
<span class="sd">                                                 x_bins=None)</span>

<span class="sd">            `loaded_events` is a 4-tuple of numpy arrays:</span>
<span class="sd">            `(f_events, t_events, y_events, x_events)`, where `f_events`</span>
<span class="sd">            contains the frame number for each neutron, landing at position</span>
<span class="sd">            `x_events, y_events` on the detector, with time-of-flight</span>
<span class="sd">            `t_events`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        detector, frame_count, bm1_counts : np.ndarray, np.ndarray, np.ndarray</span>

<span class="sd">        Create a new detector image based on the t_bins, x_bins, y_bins and</span>
<span class="sd">        frame_bins you supply to the method (these should all be lists/numpy</span>
<span class="sd">        arrays specifying the edges of the required bins). If these are not</span>
<span class="sd">        specified, then the default bins are taken from the nexus file. This</span>
<span class="sd">        would essentially return the same detector image as the nexus file.</span>
<span class="sd">        However, you can specify the frame_bins list to generate detector</span>
<span class="sd">        images based on subdivided periods of the total acquisition.</span>
<span class="sd">        For example if frame_bins = [5, 10, 120] you will get 2 images.  The</span>
<span class="sd">        first starts at 5s and finishes at 10s. The second starts at 10s</span>
<span class="sd">        and finishes at 120s. The frame_bins are clipped to the total</span>
<span class="sd">        acquisition time if necessary.</span>
<span class="sd">        `frame_count` is how many frames went into making each detector image.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">t_bins</span><span class="p">:</span>
            <span class="n">t_bins</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">t_bins</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">y_bins</span><span class="p">:</span>
            <span class="n">y_bins</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">y_bins</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x_bins</span><span class="p">:</span>
            <span class="n">x_bins</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">x_bins</span>
        <span class="k">if</span> <span class="n">frame_bins</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">frame_bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">frame_bins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">cat</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]]</span>

        <span class="n">total_acquisition_time</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span>
        <span class="n">frequency</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">frequency</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span>

        <span class="n">bm1_counts_for_scanpoint</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">bm1_counts</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span>

        <span class="n">event_directory_name</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">daq_dirname</span>

        <span class="n">_eventpath</span> <span class="o">=</span> <span class="n">cat</span><span class="o">.</span><span class="n">path</span>
        <span class="k">if</span> <span class="n">event_folder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_eventpath</span> <span class="o">=</span> <span class="n">event_folder</span>

        <span class="n">stream_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_eventpath</span><span class="p">,</span>
                                       <span class="n">event_directory_name</span><span class="p">,</span>
                                       <span class="s1">&#39;DATASET_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">scanpoint</span><span class="p">,</span>
                                       <span class="s1">&#39;EOS.bin&#39;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">stream_filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">last_frame</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">frequency</span><span class="p">)</span>
            <span class="n">loaded_events</span><span class="p">,</span> <span class="n">end_of_last_event</span> <span class="o">=</span> <span class="n">events</span><span class="p">(</span><span class="n">f</span><span class="p">,</span>
                                                      <span class="n">max_frames</span><span class="o">=</span><span class="n">last_frame</span><span class="p">)</span>

        <span class="c1"># convert frame_bins to list of filter frames</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">framebins_to_frames</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asfarray</span><span class="p">(</span><span class="n">frame_bins</span><span class="p">)</span> <span class="o">*</span>
                                     <span class="n">frequency</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">event_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">event_filter</span><span class="p">(</span><span class="n">loaded_events</span><span class="p">,</span> <span class="n">t_bins</span><span class="p">,</span> <span class="n">y_bins</span><span class="p">,</span> <span class="n">x_bins</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">process_event_stream</span><span class="p">(</span><span class="n">loaded_events</span><span class="p">,</span>
                                          <span class="n">frames</span><span class="p">,</span>
                                          <span class="n">t_bins</span><span class="p">,</span>
                                          <span class="n">y_bins</span><span class="p">,</span>
                                          <span class="n">x_bins</span><span class="p">)</span>

        <span class="n">detector</span><span class="p">,</span> <span class="n">frame_count</span> <span class="o">=</span> <span class="n">output</span>

        <span class="n">bm1_counts</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame_count</span> <span class="o">*</span> <span class="n">bm1_counts_for_scanpoint</span> <span class="o">/</span>
                      <span class="n">total_acquisition_time</span> <span class="o">/</span>
                      <span class="n">frequency</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">detector</span><span class="p">,</span> <span class="n">frame_count</span><span class="p">,</span> <span class="n">bm1_counts</span></div>

<div class="viewcode-block" id="PlatypusNexus.write_spectrum_dat"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.PlatypusNexus.write_spectrum_dat">[docs]</a>    <span class="k">def</span> <span class="nf">write_spectrum_dat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">scanpoint</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method writes a dat representation of the corrected spectrum to</span>
<span class="sd">        file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f : file-like or str</span>
<span class="sd">            The file to write the spectrum to, or a str that specifies the file</span>
<span class="sd">            name</span>
<span class="sd">        scanpoint : int</span>
<span class="sd">            Which scanpoint to write</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        processed : bool</span>
<span class="sd">            If the file hasn&#39;t been processed then the `processed is False` and</span>
<span class="sd">            vice versa</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">m_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_lambda&#39;</span><span class="p">][</span><span class="n">scanpoint</span><span class="p">]</span>
        <span class="n">m_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_spec&#39;</span><span class="p">][</span><span class="n">scanpoint</span><span class="p">]</span>
        <span class="n">m_spec_sd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_spec_sd&#39;</span><span class="p">][</span><span class="n">scanpoint</span><span class="p">]</span>
        <span class="n">m_lambda_fwhm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_lambda_fwhm&#39;</span><span class="p">][</span><span class="n">scanpoint</span><span class="p">]</span>

        <span class="n">stacked_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">m_lambda</span><span class="p">,</span> <span class="n">m_spec</span><span class="p">,</span> <span class="n">m_spec_sd</span><span class="p">,</span> <span class="n">m_lambda_fwhm</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">stacked_data</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="PlatypusNexus.write_spectrum_xml"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.PlatypusNexus.write_spectrum_xml">[docs]</a>    <span class="k">def</span> <span class="nf">write_spectrum_xml</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">scanpoint</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method writes an XML representation of the corrected spectrum to</span>
<span class="sd">        file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f : file-like or str</span>
<span class="sd">            The file to write the spectrum to, or a str that specifies the file</span>
<span class="sd">            name</span>
<span class="sd">        scanpoint : int</span>
<span class="sd">            Which scanpoint to write</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">Template</span><span class="p">(</span><span class="n">spectrum_template</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">sample_name</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%a, </span><span class="si">%d</span><span class="s2"> %b %Y %H:%M:%S +0000&quot;</span><span class="p">,</span> <span class="n">gmtime</span><span class="p">())</span>

        <span class="n">m_lambda</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_lambda&#39;</span><span class="p">]</span>
        <span class="n">m_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_spec&#39;</span><span class="p">]</span>
        <span class="n">m_spec_sd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_spec_sd&#39;</span><span class="p">]</span>
        <span class="n">m_lambda_fwhm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_lambda_fwhm&#39;</span><span class="p">]</span>

        <span class="c1"># sort the data</span>
        <span class="nb">sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m_lambda</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">m_spec</span><span class="p">[:,</span> <span class="nb">sorted</span><span class="p">]</span>
        <span class="n">lmda</span> <span class="o">=</span> <span class="n">m_lambda</span><span class="p">[:,</span> <span class="nb">sorted</span><span class="p">]</span>
        <span class="n">dlmda</span> <span class="o">=</span> <span class="n">m_lambda_fwhm</span><span class="p">[:,</span> <span class="nb">sorted</span><span class="p">]</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">m_spec_sd</span><span class="p">[:,</span> <span class="nb">sorted</span><span class="p">]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;n_spectra&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;n_spectra&#39;</span><span class="p">]</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;runnumber&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;PLP</span><span class="si">{:07d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">datafile_number</span><span class="p">)</span>

        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;,[]&#39;</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">dr</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;,[]&#39;</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;lmda&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">lmda</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;,[]&#39;</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;dlmda&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">dlmda</span><span class="p">[</span><span class="n">scanpoint</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;,[]&#39;</span><span class="p">)</span>
        <span class="n">thefile</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">safe_substitute</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">f</span>
        <span class="n">auto_fh</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;write&#39;</span><span class="p">):</span>
            <span class="n">auto_fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">auto_fh</span>

        <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">mode</span><span class="p">:</span>
            <span class="n">thefile</span> <span class="o">=</span> <span class="n">thefile</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

        <span class="n">g</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">thefile</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">auto_fh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">auto_fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_lambda&#39;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_spec&#39;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_spec_sd&#39;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">processed_spectrum</span><span class="p">[</span><span class="s1">&#39;m_lambda_fwhm&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="create_detector_norm"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.create_detector_norm">[docs]</a><span class="k">def</span> <span class="nf">create_detector_norm</span><span class="p">(</span><span class="n">h5norm</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produces a detector normalisation array for Platypus.</span>
<span class="sd">    Here we average over N, T and X to provide  a relative efficiency for each</span>
<span class="sd">    y wire.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5norm : hdf5 file</span>
<span class="sd">        Containing a flood field run (water)</span>
<span class="sd">    x_min : float, int</span>
<span class="sd">        Minimum x location to use</span>
<span class="sd">    x_max : float, int</span>
<span class="sd">        Maximum x location to use</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    norm, norm_sd : array_like</span>
<span class="sd">        1D array containing the normalisation data for each y pixel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sum over N and T</span>
    <span class="n">detector</span> <span class="o">=</span> <span class="n">h5norm</span><span class="p">[</span><span class="s1">&#39;entry1/data/hmm&#39;</span><span class="p">]</span>
    <span class="n">x_bin</span> <span class="o">=</span> <span class="n">h5norm</span><span class="p">[</span><span class="s1">&#39;entry1/data/x_bin&#39;</span><span class="p">]</span>

    <span class="c1"># find out what pixels to use</span>
    <span class="n">x_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x_bin</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x_bin</span><span class="p">))</span>
    <span class="n">x_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x_bin</span><span class="p">)[</span><span class="n">x_low</span><span class="p">]</span>
    <span class="n">x_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x_bin</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x_bin</span><span class="p">))</span>
    <span class="n">x_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x_bin</span><span class="p">)[</span><span class="n">x_high</span><span class="p">]</span>

    <span class="k">if</span><span class="p">(</span><span class="n">x_low</span> <span class="o">&gt;</span> <span class="n">x_high</span><span class="p">):</span>
        <span class="n">x_low</span><span class="p">,</span> <span class="n">x_high</span> <span class="o">=</span> <span class="n">x_high</span><span class="p">,</span> <span class="n">x_low</span>

    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                  <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

    <span class="c1"># By this point you have norm[y][x]</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span><span class="p">[:,</span> <span class="n">x_low</span><span class="p">:</span> <span class="n">x_high</span><span class="p">]</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">norm</span> <span class="o">/</span> <span class="n">mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span> <span class="o">/</span> <span class="n">mean</span></div>


<div class="viewcode-block" id="background_subtract"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.background_subtract">[docs]</a><span class="k">def</span> <span class="nf">background_subtract</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">detector_sd</span><span class="p">,</span> <span class="n">background_mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Background subtraction of Platypus detector image.</span>
<span class="sd">    Shape of detector is (N, T, Y), do a linear background subn for each</span>
<span class="sd">    (N, T) slice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    detector : np.ndarray</span>
<span class="sd">        detector array with shape (N, T, Y).</span>
<span class="sd">    detector_sd : np.ndarray</span>
<span class="sd">        standard deviations for detector array</span>
<span class="sd">    background_mask : array_like</span>
<span class="sd">        array of bool with shape (N, T, Y) that specifies which Y pixels to use</span>
<span class="sd">        for background subtraction.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    detector, detector_sd : np.ndarray, np.ndarray</span>
<span class="sd">        Detector image with background subtracted</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">detector</span><span class="p">)</span>
    <span class="n">ret_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">detector</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">detector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">]):</span>
        <span class="n">ret</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">ret_sd</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">background_subtract_line</span><span class="p">(</span><span class="n">detector</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                         <span class="n">detector_sd</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                                         <span class="n">background_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ret_sd</span></div>


<div class="viewcode-block" id="background_subtract_line"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.background_subtract_line">[docs]</a><span class="k">def</span> <span class="nf">background_subtract_line</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">profile_sd</span><span class="p">,</span> <span class="n">background_mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs a linear background subtraction on a 1D peak profile</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    profile : np.ndarray</span>
<span class="sd">        1D profile</span>
<span class="sd">    profile_sd : np.ndarray</span>
<span class="sd">        standard deviations for profile</span>
<span class="sd">    background_mask : array_like</span>
<span class="sd">        array of bool that specifies which Y pixels to use for background</span>
<span class="sd">        subtraction.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    profile_subt, profile_subt_err : np.ndarray, np.ndarray</span>
<span class="sd">        Background subtracted profile and its uncertainty</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># which values to use as a background region</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">background_mask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="n">x_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># can&#39;t do a background subtraction if you have less than 2 points in</span>
        <span class="c1"># the background</span>
        <span class="k">return</span> <span class="n">profile</span><span class="p">,</span> <span class="n">profile_sd</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">y_vals</span> <span class="o">=</span> <span class="n">profile</span><span class="p">[</span><span class="n">x_vals</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)</span>

    <span class="n">y_sdvals</span> <span class="o">=</span> <span class="n">profile_sd</span><span class="p">[</span><span class="n">x_vals</span><span class="p">]</span>
    <span class="n">x_vals</span> <span class="o">=</span> <span class="n">x_vals</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>

    <span class="c1"># some SD values may have 0 SD, which will screw up curvefitting.</span>
    <span class="n">y_sdvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_sdvals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y_sdvals</span><span class="p">)</span>

    <span class="c1"># equation for a straight line</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span>

    <span class="c1"># estimate the linear fit</span>
    <span class="n">y_bar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_vals</span><span class="p">)</span>
    <span class="n">x_bar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x_vals</span><span class="p">)</span>
    <span class="n">bhat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x_vals</span> <span class="o">-</span> <span class="n">x_bar</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_vals</span> <span class="o">-</span> <span class="n">y_bar</span><span class="p">))</span>
    <span class="n">bhat</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x_vals</span> <span class="o">-</span> <span class="n">x_bar</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">ahat</span> <span class="o">=</span> <span class="n">y_bar</span> <span class="o">-</span> <span class="n">bhat</span> <span class="o">*</span> <span class="n">x_bar</span>

    <span class="c1"># get the weighted fit values</span>
    <span class="c1"># we know the absolute sigma values</span>
    <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x_vals</span><span class="p">,</span> <span class="n">y_vals</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">y_sdvals</span><span class="p">,</span>
                           <span class="n">p0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ahat</span><span class="p">,</span> <span class="n">bhat</span><span class="p">]),</span> <span class="n">absolute_sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CI</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">pcovmat</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">pcovmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">pcovmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">xx</span> <span class="o">+</span>
                <span class="n">pcovmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">xx</span> <span class="o">+</span> <span class="n">pcovmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">xx</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">bkgd</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">popt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">popt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># now work out confidence intervals</span>
    <span class="c1"># TODO, should this be confidence interval or prediction interval?</span>
    <span class="c1"># if you try to do a fit which has a singular matrix</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">pcov</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="n">bkgd_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">CI</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pcov</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="p">))],</span>
                             <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bkgd_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">bkgd</span><span class="p">)</span>

    <span class="n">bkgd_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">bkgd_sd</span><span class="p">)</span>

    <span class="c1"># get the t value for a two sided student t test at the 68.3 confidence</span>
    <span class="c1"># level</span>
    <span class="n">bkgd_sd</span> <span class="o">*=</span> <span class="n">t</span><span class="o">.</span><span class="n">isf</span><span class="p">(</span><span class="mf">0.1585</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">EP</span><span class="o">.</span><span class="n">EPsub</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">profile_sd</span><span class="p">,</span> <span class="n">bkgd</span><span class="p">,</span> <span class="n">bkgd_sd</span><span class="p">)</span></div>


<div class="viewcode-block" id="find_specular_ridge"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.find_specular_ridge">[docs]</a><span class="k">def</span> <span class="nf">find_specular_ridge</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">detector_sd</span><span class="p">,</span> <span class="n">starting_offset</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                        <span class="n">tol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">manual_beam_find</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the specular ridges in a detector(n, t, y) plot.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    detector : array_like</span>
<span class="sd">        detector array</span>
<span class="sd">    detector_sd : array_like</span>
<span class="sd">        standard deviations of detector array</span>
<span class="sd">    tol : float</span>
<span class="sd">        specifies threshold of fractional change for beam centre to be found</span>
<span class="sd">    manual_beam_find : callable, optional</span>
<span class="sd">        A function which allows the location of the specular ridge to be</span>
<span class="sd">        determined, IFF the autodetection of specular ridge fails.</span>
<span class="sd">        Has the signature `f(detector, detector_sd)`. `detector` and</span>
<span class="sd">        `detector_sd` have shape (n, t, y) where `n` is the number of detector</span>
<span class="sd">        images, `t` is the number of time of flight bins and `y` is the number</span>
<span class="sd">        of y pixels. The function should return a tuple,</span>
<span class="sd">        `(centre, centre_sd, lopx, hipx, background_pixels)`. `centre`,</span>
<span class="sd">        `centre_sd`, `lopx`, `hipx` should be arrays of shape `(n, )`,</span>
<span class="sd">        specifying the beam centre, beam width (standard deviation), lowest</span>
<span class="sd">        pixel of foreground region, highest pixel of foreground region.</span>
<span class="sd">        `background_pixels` is a list of length `n`. Each of the entries</span>
<span class="sd">        should contain arrays of pixel numbers that specify the background</span>
<span class="sd">        region for each of the detector images.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    centre, SD, lopx, hipx, background_mask : np.ndarrays</span>
<span class="sd">        peak centre, standard deviation of peak width, lowest pixel to be</span>
<span class="sd">        included from background region, highest pixel to be included from</span>
<span class="sd">        background region, array specifying points to be used for background</span>
<span class="sd">        subtraction</span>
<span class="sd">        `np.size(centre) == n`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">beam_centre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">beam_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">beam_centre</span><span class="p">)</span>

    <span class="c1"># lopx and hipx specify the foreground region to integrate over</span>
    <span class="n">lopx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">beam_centre</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">hipx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">beam_centre</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># background mask specifies which pixels are background</span>
    <span class="n">background_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="n">search_increment</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="n">starting_offset</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">starting_offset</span><span class="p">)</span>

    <span class="n">n_increments</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">starting_offset</span><span class="p">)</span> <span class="o">//</span>
                    <span class="n">search_increment</span><span class="p">)</span>

    <span class="c1"># we want to integrate over the following pixel region</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="n">last_centre</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="n">last_sd</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="n">converged</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_increments</span><span class="p">):</span>
            <span class="n">how_many</span> <span class="o">=</span> <span class="o">-</span><span class="n">starting_offset</span> <span class="o">-</span> <span class="n">search_increment</span> <span class="o">*</span> <span class="n">i</span>

            <span class="n">det_subset</span> <span class="o">=</span> <span class="n">detector</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">how_many</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">det_sd_subset</span> <span class="o">=</span> <span class="n">detector_sd</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="n">how_many</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Uncertainties code takes a while to run</span>
            <span class="c1"># total_y = np.sum(det_subset, axis=0)</span>
            <span class="n">y_cross</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">det_subset</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">y_cross_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">det_sd_subset</span> <span class="o">**</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1"># find the centroid and gauss peak in the last sections of the TOF</span>
            <span class="c1"># plot</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">centroid</span><span class="p">,</span> <span class="n">gauss_peak</span> <span class="o">=</span> <span class="n">peak_finder</span><span class="p">(</span><span class="n">y_cross</span><span class="p">,</span>
                                                   <span class="n">sigma</span><span class="o">=</span><span class="n">y_cross_sd</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">((</span><span class="n">gauss_peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">last_centre</span><span class="p">)</span> <span class="o">/</span> <span class="n">last_centre</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span>
                    <span class="nb">abs</span><span class="p">((</span><span class="n">gauss_peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">last_sd</span><span class="p">)</span> <span class="o">/</span> <span class="n">last_sd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">):</span>
                <span class="n">last_centre</span> <span class="o">=</span> <span class="n">gauss_peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">last_sd</span> <span class="o">=</span> <span class="n">gauss_peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">converged</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="n">last_centre</span> <span class="o">=</span> <span class="n">gauss_peak</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last_sd</span> <span class="o">=</span> <span class="n">gauss_peak</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">converged</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;specular ridge search did not work properly&#39;</span>
                          <span class="s1">&#39; using last known centre&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">manual_beam_find</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">manual_beam_find</span><span class="p">(</span><span class="n">detector</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">detector_sd</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">beam_centre</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">beam_sd</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">lopx</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">hipx</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">bp</span> <span class="o">=</span> <span class="n">ret</span>
                <span class="n">background_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="n">bp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># don&#39;t assign to beam_centre, etc, at the end of this loop</span>
                <span class="k">continue</span>

        <span class="n">beam_centre</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_centre</span>
        <span class="n">beam_sd</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">last_sd</span><span class="p">)</span>
        <span class="n">lp</span><span class="p">,</span> <span class="n">hp</span><span class="p">,</span> <span class="n">bp</span> <span class="o">=</span> <span class="n">fore_back_region</span><span class="p">(</span><span class="n">beam_centre</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">beam_sd</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">lopx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lp</span>
        <span class="n">hipx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">hp</span>
        <span class="n">background_mask</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="n">bp</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">beam_centre</span><span class="p">,</span> <span class="n">beam_sd</span><span class="p">,</span> <span class="n">lopx</span><span class="p">,</span> <span class="n">hipx</span><span class="p">,</span> <span class="n">background_mask</span></div>


<div class="viewcode-block" id="fore_back_region"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.fore_back_region">[docs]</a><span class="k">def</span> <span class="nf">fore_back_region</span><span class="p">(</span><span class="n">beam_centre</span><span class="p">,</span> <span class="n">beam_sd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the fore and background regions based on the beam centre and</span>
<span class="sd">    width</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    beam_centre : float</span>
<span class="sd">        beam_centre</span>
<span class="sd">    beam_sd : float</span>
<span class="sd">        beam width (standard deviation)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lopx, hipx, background_pixels: float, float, list</span>
<span class="sd">        Lowest pixel of foreground region</span>
<span class="sd">        Highest pixel of foreground region</span>
<span class="sd">        Pixels that are in the background region</span>
<span class="sd">        Each of these should have `len(lopx) == len(beam_centre)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_b_centre</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">beam_centre</span><span class="p">)</span>
    <span class="n">_b_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">beam_sd</span><span class="p">)</span>

    <span class="n">lopx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">_b_centre</span> <span class="o">-</span> <span class="n">_b_sd</span> <span class="o">*</span> <span class="n">EXTENT_MULT</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="n">hipx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">_b_centre</span> <span class="o">+</span> <span class="n">_b_sd</span> <span class="o">*</span> <span class="n">EXTENT_MULT</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="n">background_pixels</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># limit of background regions</span>
    <span class="c1"># from refnx.reduce.platypusnexus</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lopx</span> <span class="o">-</span> <span class="n">PIXEL_OFFSET</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lopx</span> <span class="o">-</span> <span class="n">PIXEL_OFFSET</span> <span class="o">-</span> <span class="p">(</span><span class="n">EXTENT_MULT</span> <span class="o">*</span> <span class="n">_b_sd</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>

    <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">hipx</span> <span class="o">+</span> <span class="n">PIXEL_OFFSET</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>
    <span class="n">y3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">hipx</span> <span class="o">+</span> <span class="n">PIXEL_OFFSET</span> <span class="o">+</span> <span class="p">(</span><span class="n">EXTENT_MULT</span> <span class="o">*</span> <span class="n">_b_sd</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">))</span>

    <span class="c1"># now generate background pixels</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">y0</span><span class="p">)):</span>
        <span class="n">background_pixels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">lopx</span><span class="p">,</span> <span class="n">hipx</span><span class="p">,</span> <span class="n">background_pixels</span></div>


<div class="viewcode-block" id="correct_for_gravity"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.correct_for_gravity">[docs]</a><span class="k">def</span> <span class="nf">correct_for_gravity</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">detector_sd</span><span class="p">,</span> <span class="n">lamda</span><span class="p">,</span> <span class="n">coll_distance</span><span class="p">,</span>
                        <span class="n">sample_det</span><span class="p">,</span> <span class="n">lo_wavelength</span><span class="p">,</span> <span class="n">hi_wavelength</span><span class="p">,</span>
                        <span class="n">theta</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a gravity corrected yt plot, given the data, its associated errors,</span>
<span class="sd">    the wavelength corresponding to each of the time bins, and the trajectory</span>
<span class="sd">    of the neutrons. Low lambda and high Lambda are wavelength cutoffs to</span>
<span class="sd">    ignore.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    detector : np.ndarray</span>
<span class="sd">        Detector image. Has shape (N, T, Y)</span>
<span class="sd">    detector_sd : np.ndarray</span>
<span class="sd">        Standard deviations of detector image</span>
<span class="sd">    lamda : np.ndarray</span>
<span class="sd">        Wavelengths corresponding to the detector image, has shape (N, T)</span>
<span class="sd">    coll_distance : float</span>
<span class="sd">        Collimation distance between slits, mm</span>
<span class="sd">    sample_det : float</span>
<span class="sd">        Sample - detector distance, mm</span>
<span class="sd">    lo_wavelength : float</span>
<span class="sd">        Low wavelength cut off, Angstrom</span>
<span class="sd">    hi_wavelength : float</span>
<span class="sd">        High wavelength cutoff, Angstrom</span>
<span class="sd">    theta : float</span>
<span class="sd">        Angle between second collimation slit, first collimation slit, and</span>
<span class="sd">        horizontal</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    corrected_data, corrected_data_sd, m_gravcorrcoefs :</span>
<span class="sd">        np.ndarray, np.ndarray, np.ndarray</span>

<span class="sd">        Corrected image. This is a theoretical prediction where the spectral</span>
<span class="sd">        ridge is for each wavelength.  This will be used to calculate the</span>
<span class="sd">        actual angle of incidence in the reduction process.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>

    <span class="n">m_gravcorrcoefs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

    <span class="n">corrected_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">detector</span><span class="p">)</span>
    <span class="n">corrected_data_sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">detector</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="n">neutron_speeds</span> <span class="o">=</span> <span class="n">general</span><span class="o">.</span><span class="n">wavelength_velocity</span><span class="p">(</span><span class="n">lamda</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
        <span class="n">trajectories</span> <span class="o">=</span> <span class="n">find_trajectory</span><span class="p">(</span><span class="n">coll_distance</span> <span class="o">/</span> <span class="mf">1000.</span><span class="p">,</span>
                                       <span class="n">theta</span><span class="p">,</span>
                                       <span class="n">neutron_speeds</span><span class="p">)</span>
        <span class="n">travel_distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">coll_distance</span> <span class="o">+</span> <span class="n">sample_det</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1000.</span>

        <span class="c1"># centres(t,)</span>
        <span class="c1"># TODO, don&#39;t use centroids, use Gaussian peak</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">centroid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">detector</span><span class="p">[</span><span class="n">spec</span><span class="p">])</span>
        <span class="n">lopx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">lamda</span><span class="p">[</span><span class="n">spec</span><span class="p">],</span> <span class="n">lo_wavelength</span><span class="p">)</span>
        <span class="n">hipx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">lamda</span><span class="p">[</span><span class="n">spec</span><span class="p">],</span> <span class="n">hi_wavelength</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">tru_centre</span><span class="p">):</span>
            <span class="n">deflections</span> <span class="o">=</span> <span class="n">y_deflection</span><span class="p">(</span><span class="n">trajectories</span><span class="p">[</span><span class="n">lopx</span><span class="p">:</span> <span class="n">hipx</span><span class="p">],</span>
                                       <span class="n">neutron_speeds</span><span class="p">[</span><span class="n">lopx</span><span class="p">:</span> <span class="n">hipx</span><span class="p">],</span>
                                       <span class="n">travel_distance</span><span class="p">)</span>

            <span class="n">model</span> <span class="o">=</span> <span class="mf">1000.</span> <span class="o">*</span> <span class="n">deflections</span> <span class="o">/</span> <span class="n">Y_PIXEL_SPACING</span> <span class="o">+</span> <span class="n">tru_centre</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">model</span> <span class="o">-</span> <span class="n">centroids</span><span class="p">[</span><span class="n">lopx</span><span class="p">:</span> <span class="n">hipx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">diff</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">diff</span><span class="p">)]</span>
            <span class="k">return</span> <span class="n">diff</span>

        <span class="c1"># find the beam centre for an infinitely fast neutron</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">centroids</span><span class="p">[</span><span class="n">lopx</span><span class="p">:</span> <span class="n">hipx</span><span class="p">,</span> <span class="mi">0</span><span class="p">])])</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">leastsq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
        <span class="n">m_gravcorrcoefs</span><span class="p">[</span><span class="n">spec</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">total_deflection</span> <span class="o">=</span> <span class="mf">1000.</span> <span class="o">*</span> <span class="n">y_deflection</span><span class="p">(</span><span class="n">trajectories</span><span class="p">,</span>
                                                <span class="n">neutron_speeds</span><span class="p">,</span>
                                                <span class="n">travel_distance</span><span class="p">)</span>
        <span class="n">total_deflection</span> <span class="o">/=</span> <span class="n">Y_PIXEL_SPACING</span>

        <span class="n">x_rebin</span> <span class="o">=</span> <span class="n">x_init</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">total_deflection</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">wavelength</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">rebin</span><span class="p">(</span><span class="n">x_init</span><span class="p">,</span>
                           <span class="n">detector</span><span class="p">[</span><span class="n">spec</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">],</span>
                           <span class="n">x_rebin</span><span class="p">[</span><span class="n">wavelength</span><span class="p">],</span>
                           <span class="n">y1_sd</span><span class="o">=</span><span class="n">detector_sd</span><span class="p">[</span><span class="n">spec</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">])</span>

            <span class="n">corrected_data</span><span class="p">[</span><span class="n">spec</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">corrected_data_sd</span><span class="p">[</span><span class="n">spec</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">corrected_data</span><span class="p">,</span> <span class="n">corrected_data_sd</span><span class="p">,</span> <span class="n">m_gravcorrcoefs</span></div>


<div class="viewcode-block" id="calculate_wavelength_bins"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.calculate_wavelength_bins">[docs]</a><span class="k">def</span> <span class="nf">calculate_wavelength_bins</span><span class="p">(</span><span class="n">lo_wavelength</span><span class="p">,</span> <span class="n">hi_wavelength</span><span class="p">,</span> <span class="n">rebin_percent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates optimal logarithmically spaced wavelength histogram bins. The</span>
<span class="sd">    bins are equal size in log10 space, but they may not be exactly be</span>
<span class="sd">    `rebin_percent` in size. The limits would have to change slightly for that.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lo_wavelength : float</span>
<span class="sd">        Low wavelength cutoff</span>
<span class="sd">    hi_wavelength : float</span>
<span class="sd">        High wavelength cutoff</span>
<span class="sd">    rebin_percent : float</span>
<span class="sd">        Rebinning percentage</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    wavelength_bins : np.ndarray</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">rebin_percent</span> <span class="o">/</span> <span class="mf">100.</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">lowspac</span> <span class="o">=</span> <span class="n">rebin_percent</span> <span class="o">/</span> <span class="mf">100.</span> <span class="o">*</span> <span class="n">lo_wavelength</span>
    <span class="n">hispac</span> <span class="o">=</span> <span class="n">rebin_percent</span> <span class="o">/</span> <span class="mf">100.</span> <span class="o">*</span> <span class="n">hi_wavelength</span>

    <span class="n">lowl</span> <span class="o">=</span> <span class="n">lo_wavelength</span> <span class="o">-</span> <span class="n">lowspac</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">hil</span> <span class="o">=</span> <span class="n">hi_wavelength</span> <span class="o">+</span> <span class="n">hispac</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">num_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">hil</span> <span class="o">/</span> <span class="n">lowl</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">frac</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">rebinning</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">lowl</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">hil</span><span class="p">),</span> <span class="n">num</span><span class="o">=</span><span class="n">num_steps</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rebinning</span></div>


<div class="viewcode-block" id="accumulate_HDF_files"><a class="viewcode-back" href="../../../refnx.reduce.html#refnx.reduce.platypusnexus.accumulate_HDF_files">[docs]</a><span class="k">def</span> <span class="nf">accumulate_HDF_files</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Accumulates HDF files together, writing an accumulated file in the current</span>
<span class="sd">    directory. The accumulated datafile is written in the current directory</span>
<span class="sd">    (os.getcwd()) and has a filename based on the first file, prepended by</span>
<span class="sd">    &#39;ADD\_&#39;. For example, if the first file is PLP0000708.nx.hdf then the</span>
<span class="sd">    accumulated file is ADD_PLP0000708.nx.hdf.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    files : list</span>
<span class="sd">        Strings specifying NeXUS filenames to be added together.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># don&#39;t do anything if no files were supplied.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># the first file is the &quot;master file&quot;, lets copy it.</span>
    <span class="n">file</span> <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">pth</span> <span class="o">=</span> <span class="n">_check_HDF_file</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pth</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All files must refer to an hdf5 file&#39;</span><span class="p">)</span>

    <span class="n">new_name</span> <span class="o">=</span> <span class="s1">&#39;ADD_&#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">pth</span><span class="p">)</span>

    <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pth</span><span class="p">,</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">new_name</span><span class="p">))</span>

    <span class="n">master_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">(),</span> <span class="n">new_name</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">master_file</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5master</span><span class="p">:</span>
        <span class="c1"># now go through each file and accumulate numbers:</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">pth</span> <span class="o">=</span> <span class="n">_check_HDF_file</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
            <span class="n">h5data</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">pth</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>

            <span class="n">h5master</span><span class="p">[</span><span class="s1">&#39;entry1/data/hmm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> \
                <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/data/hmm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">h5master</span><span class="p">[</span><span class="s1">&#39;entry1/monitor/bm1_counts&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> \
                <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/monitor/bm1_counts&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">h5master</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/detector/total_counts&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> \
                <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/detector/total_counts&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">h5master</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/detector/time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> \
                <span class="n">h5data</span><span class="p">[</span><span class="s1">&#39;entry1/instrument/detector/time&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">h5master</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

            <span class="n">h5data</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<span class="k">def</span> <span class="nf">_check_HDF_file</span><span class="p">(</span><span class="n">h5data</span><span class="p">):</span>
    <span class="c1"># If a file is an HDF5 file, then return the filename.</span>
    <span class="c1"># otherwise return False</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">h5data</span><span class="p">)</span> <span class="o">==</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">h5data</span><span class="o">.</span><span class="n">filename</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5data</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5data</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">h5data</span><span class="p">)</span> <span class="o">==</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">h5data</span><span class="o">.</span><span class="n">filename</span>

    <span class="k">return</span> <span class="kc">False</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">_possibly_open_hdf_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Context manager for hdf5 files.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f : file-like or str</span>
<span class="sd">        If `f` is a file, then yield the file. If `f` is a str then open the</span>
<span class="sd">        file and yield the newly opened file.</span>
<span class="sd">        On leaving this context manager the file is closed, if it was opened</span>
<span class="sd">        by this context manager (i.e. `f` was a string).</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        mode is an optional string that specifies the mode in which the file</span>
<span class="sd">        is opened.</span>

<span class="sd">    Yields</span>
<span class="sd">    ------</span>
<span class="sd">    g : file-like</span>
<span class="sd">        On leaving the context manager the file is closed, if it was opened by</span>
<span class="sd">        this context manager.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">close_file</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">f</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="n">close_file</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">yield</span> <span class="n">g</span>
    <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;Process some Platypus NeXUS&#39;</span>
                                                 <span class="s1">&#39;files to produce their TOF &#39;</span>
                                                 <span class="s1">&#39;spectra.&#39;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;file_list&#39;</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;integer file numbers&#39;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-b&#39;</span><span class="p">,</span> <span class="s1">&#39;--bdir&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;define the location to find the nexus files&#39;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-d&#39;</span><span class="p">,</span> <span class="s1">&#39;--direct&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;is the file a direct beam?&#39;</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-r&#39;</span><span class="p">,</span> <span class="s1">&#39;--rebin&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;rebin percentage for the wavelength -1&lt;rebin&lt;10&#39;</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-ll&#39;</span><span class="p">,</span> <span class="s1">&#39;--lolambda&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;lo wavelength cutoff for the rebinning&#39;</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-hl&#39;</span><span class="p">,</span> <span class="s1">&#39;--hilambda&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;lo wavelength cutoff for the rebinning&#39;</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="mf">19.</span><span class="p">)</span>

    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-i&#39;</span><span class="p">,</span> <span class="s1">&#39;--integrate&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;-1 to integrate all spectra, otherwise enter the&#39;</span>
                             <span class="s1">&#39; spectrum number.&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">file_list</span><span class="p">:</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;PLP</span><span class="si">%07d</span><span class="s1">.nx.hdf&#39;</span> <span class="o">%</span> <span class="n">file</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">bdir</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">PlatypusNexus</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">lo_wavelength</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">lolambda</span><span class="p">,</span>
                      <span class="n">hi_wavelength</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">hilambda</span><span class="p">,</span>
                      <span class="n">direct</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">direct</span><span class="p">,</span>
                      <span class="n">rebin_percent</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">rebin</span><span class="p">,</span>
                      <span class="n">integrate</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">integrate</span><span class="p">)</span>

            <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;PLP</span><span class="si">%07d</span><span class="s1">.spectrum&#39;</span> <span class="o">%</span> <span class="n">file</span>
            <span class="n">out_fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">bdir</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>

            <span class="n">integrate</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">integrate</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">integrate</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">integrate</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">a</span><span class="o">.</span><span class="n">write_spectrum_dat</span><span class="p">(</span><span class="n">out_fname</span><span class="p">,</span> <span class="n">scanpoint</span><span class="o">=</span><span class="n">integrate</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Couldn&#39;t find file: </span><span class="si">%d</span><span class="s2">.  Use --basedir option&quot;</span> <span class="o">%</span> <span class="n">file</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015-2017, Andrew Nelson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>